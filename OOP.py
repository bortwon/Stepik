# Добрый, добрый Python ООП - обучающий курс от Сергея Балакирева
# ======================================================================================================================
# 1. ПЕРВЫЕ ШАГИ В ООП.

# ----------------------------------------------------------------------------------------------------------------------
# 1.2 Концепция ООП простыми словами


# Подвиг 1. Что составляет основу ООП?
# - инкапсуляция
# - наследование
# - полиморфизм

# Подвиг 2. Как следует воспринимать класс в ООП?
# - как шаблон, по которому конструируются объекты этого класса

# Подвиг 3. В чем суть идеи наследования в ООП?
# - на основе одного или нескольких классов создается новый (дочерний) класс
# - наследование позволяет как бы вынести «за скобки» общее для разных классов

# Подвиг 4. Можно ли создавать программы без использования ООП?
# - да, например, используя парадигму структурного программирования (не включая ООП)

# Подвиг 5. Вам предстоит написать программу хранения информации по книгам: автор, заголовок, год издания, число
# страниц. Помогут ли здесь классы для представления этой разнородной информации?
# - да, описать каждую книгу как объект класса "Книга" хорошая идея

# Подвиг 6. Каким термином из ООП можно охарактеризовать ограничение доступа к элементам класса?
# - инкапсуляция

# Подвиг 7. Вам предстоит создать программу несложного графического редактора с рисованием различных графических
# примитивов (линия, прямоугольник, эллипс, треугольник и т.п.). Будет ли иметь смысл использовать при ее реализации
# концепцию ООП?
# - да, ООП здесь может заметно упростить программный код

# Подвиг 8. Каким термином из ООП можно охарактеризовать универсальность интерфейса доступа к разным типам данных?
# - полиморфизм


# ---------------------------------------------------------------------------------------------------------------------
# 1.3. Классы и объекты. Атрибуты классов и объектов

# setattr(Point, 'prop', 1) - функция создает новый атрибут в указанном пространстве имен(в данном случае в классе
# Point) с заданным значением.

# getattr(Point, 'a', False) - функция для обращения к тому или иному атрибуту класса, ей пользуются только в том
# случае, если есть опасность обращения к несуществующим атрибутам.

# delattr(Point, 'type_pt') - функция для удаления атрибута.

# hasattr(Point, 'prop') - проверка существования того или иного свойства атрибута.


# Подвиг 1. Отметьте все верные, с точки зрения стандарта PEP8, имена классов.
# - DataBase
# - SergeyBalakirev
# - Data123

# Подвиг 2. Выберите утверждения справедливые для классов языка Python.
# - Каждый класс (объявленный в программе) можно воспринимать как новый (пользовательский) тип данных.
# - Класс описывает шаблон для формирования его объектов.
# - Класс образует пространство имен для переменных и методов, объявленных в нем.


# Подвиг 3. Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12

# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими
# значениями.

class DataBase:
    pk = 1
    title = 'Классы и объекты'
    author = 'Сергей Балакирев'
    views = 14356
    comments = 12


# Подвиг 4. Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
#
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:
#
# inflation: 100

class Goods:
    title = 'Мороженое'
    weight = 154
    tp = 'Еда'
    price = 1024
Goods.price = 2048
setattr(Goods, 'inflation', 100)


# Подвиг 5. Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"

# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.

class Car:
    pass
setattr(Car, 'model', 'Тойота')
setattr(Car, 'color', 'Розовый')
setattr(Car, 'number', 'П111УУ77')
print(Car.__dict__['color'])


# Подвиг 6. Объявите класс с именем Notes и определите в нем следующие атрибуты:
#
# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

class Notes:
    uid = 1005435
    title = 'Шутка'
    author = 'И.С. Бах'
    pages = 2
res = getattr(Notes, 'author')
print(res)


# Подвиг 7. Объявите класс с именем Dictionary и определите в нем следующие атрибуты:
#
# rus: "Питон"
# eng: "Python"

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в
# классе нет, то функция getattr() должна возвращать булево значение False.

class Dictionary:
    rus = "Питон"
    eng = "Python"

print(getattr(Dictionary, 'rus_word', False))


# Подвиг 8. Объявите класс с именем TravelBlog и объявите в нем атрибут:
#
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
#
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
#
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
#
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

class TravelBlog:
    total_blogs = 0


tb1 = TravelBlog()
tb1.name = 'Франция'
tb1.days = 6
TravelBlog.total_blogs += 1
tb2 = TravelBlog()
tb2.name = 'Италия'
tb2.days = 5
TravelBlog.total_blogs += 1


class TravelBlog:
    total_blogs = 0

    def __init__(self, name, days):
        self.name = name
        self.days = days
        TravelBlog.total_blogs += 1


tb1 = TravelBlog('Франция', 6)
tb2 = TravelBlog('Италия', 5)


# Подвиг 9. Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'

# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:

# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'

# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта
# fig1 в одну строчку через пробел в порядке, указанном в задании.

class Figure:
    type_fig = 'ellipse'
    color = 'red'

fig1 = Figure()
fig1.start_pt = (10, 5)
fig1.end_pt = (100, 20)
fig1.color = 'blue'
delattr(fig1, 'color')
print(*fig1.__dict__.keys())


# Подвиг 10. Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'

# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите
# True, если оно присутствует в объекте p1 и False - если отсутствует.

class Person:
    name = 'Сергей Балакирев'
    job = 'Программист'
    city = 'Москва'

p1 = Person()
print('job' in p1.__dict__)


# Подвиг 11. Выберите верное значение атрибута, которое будет выведено на экран при выполнении следующей программы:
#
# class Figures:
#     type = 'ellipse'
#     color = 'red'
#
#
# fig1 = Figures()
# print(fig1.color)

# - red


# Подвиг 12. Установите соответствия между функциями и их описаниями.

# setattr() - позволяет создавать новый атрибут или устанавливать значение уже существующего в классе или объекте
# getattr() - позволяет получать значение указанного атрибута из класса или объекта
# hasattr() - позволяет проверять атрибут на наличие в классе или объекте
# delattr() - позволяет удалять атрибут в классе или объекте


# Подвиг 13. Выберите верные способы удаления атрибута tp из класса Point.
# - delattr(Point, 'tp')
# - del Point.tp

# Подвиг 14. В программе объявлен следующий класс:
#
# class Magazine:
#     name = 'Наука и жизнь'
#     price = 1101
# Что произойдет при выполнении команды:
# print(getattr(Magazine, 'id'))


# - Ошибка, так как атрибут id отсутствует в классе Magazine

# ----------------------------------------------------------------------------------------------------------------------
# 1.4. Методы классов. Параметр self

# Подвиг 1. Что называется методом класса?
# - Любая (не статическая) функция, объявленная внутри класса


# Подвиг 2. Что называют атрибутами класса?
# - Переменные и имена методов (ссылки на методы) класса


# Подвиг 3. Какую роль играет параметр self в методах класса?
# - это ссылка на объект класса, из которого был вызван метод



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/AbMOpQSt1fA
# Подвиг 4. Объявите класс с именем MediaPlayer с двумя методами:
#
# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")
#
# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):
#
# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

class MediaPlayer:

    def open(self, file):
        self.filename = file

    def play(self):
        print(f'Воспроизведение {self.filename}')


media1 = MediaPlayer()
media2 = MediaPlayer()
media1.open('filemedia1')
media2.open('filemedia2')
media1.play()
media2.play()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/XNbphw3bYAI
# Подвиг 5. Объявите класс с именем Graph и методами:
#
# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)
#
# и атрибутом:
#
# LIMIT_Y = [0, 10]
#
# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на
# переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных
# пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).
#
# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:
#
# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]
#
# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором
# чисел, записанных через пробел. Например (вывод без кавычек):
#
# "10 0 2 5 7"

class Graph:
    LIMIT_Y = [0, 10]

    def set_data(self, data):
        self.data = data

    def draw(self):
        print(*filter(lambda x: self.LIMIT_Y[0] <= x <= self.LIMIT_Y[1], self.data))


graph_1 = Graph()
graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
graph_1.draw()



# Подвиг 6. Имеется следующий класс:
#
# class Stepik:
#     def next_task(self):
#         return "Следующее задание"
# И создается объект этого класса:
#
# my_st = Stepik()

# Выберите все верные варианты вызова метода next_task()
# - my_st.next_task()
# - Stepik.next_task(my_st)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/IxXtZXrnnDY
# Подвиг 7. Имеется следующий класс для считывания информации из входного потока:
#
# import sys
#
#
# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')
#
#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res

# Которым, затем, можно воспользоваться следующим образом:
#
# sr = StreamReader()
# data, result = sr.readlines()

# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:
#
# def create(self, fields, lst_values): ...
#
# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.
#
# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.
#
# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.
#
# Пример входной информации (Sample Input):
#
# 10
# Питон - основы мастерства
# 512


import sys


# здесь объявляется класс StreamData

class StreamData:
    def create(self, fields, lst_values):
        if len(fields) != len(lst_values):
            return False
        else:
            for x in list(zip(fields, lst_values)):
                setattr(self, str(x[0]), x[1])
            return True


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res


sr = StreamReader()
data, result = sr.readlines()


# Подвиг 8. В программе объявлен класс:
#
# class String:
#     is_empty = False
# А, затем, создаются два его экземпляра:
#
# s1 = String()
# s2 = String()
# После этого выполняется команда:
#
# s2.is_empty = True

# Выберите верные утверждения, связанные с этой программой.
# - Значение s1.is_empty будет по-прежнему False, а значение s2.is_empty примет новое значение True
# - Переменная a = s1.is_empty будет ссылаться на атрибут is_empty класса String
# - Переменная b = s2.is_empty будет ссылаться на локальный атрибут is_empty объекта s2
# - Последняя команда создаст локальное свойство is_empty со значением True в экземпляре s2



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ljahVEppmxM
# Подвиг 9. Из входного потока читаются строки данных с помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...
#
# То есть, каждая строка - это элемент списка lst_in.
#
# Необходимо в класс DataBase:
#
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:
#
# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам
# (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;
#
# Каждая запись в списке lst_data должна быть представлена словарем в формате:
#
# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}
#
# Например:
#
# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
#
# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в
# коллекции FIELDS.
#
# P. S. Ваша задача только добавить два метода в класс DataBase.
#
# Sample Input:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200


import sys

# программу не менять, только добавить два метода
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока


class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')

    # здесь добавлять методы
    def select(self, a, b):
        return self.lst_data[a: b + 1]

    def insert(self, data):
        for i in data:
            self.lst_data.append(dict(zip(self.FIELDS, i.split())))


db = DataBase()
db.insert(lst_in)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/butyKEUntK0
# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует,
# то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus
# уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских
# слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е.
# связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go.
# Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить


class Translator:
    res = {}

    def add(self, eng, rus):
        if eng in self.res.keys():
            if rus not in self.res[eng]:
                self.res[eng].append(rus)
        else:
            self.res[eng] = [rus]

    def remove(self, eng):
        del self.res[eng]

    def translate(self, eng):
        return self.res[eng]


tr = Translator()
tr.add("tree", "дерево")
tr.add("car", "машина")
tr.add("car", "автомобиль")
tr.add("leaf", "лист")
tr.add("river", "река")
tr.add("go", "идти")
tr.add("go", "ехать")
tr.add("go", "ходить")
tr.add("milk", "молоко")

tr.remove('car')
print(*tr.translate('go'))


# ----------------------------------------------------------------------------------------------------------------------
# 1.5 Инициализатор __init__ и финализатор __del__


#Подвиг 1. Какой магический метод вызывается автоматически для инициализации объекта класса?
# - __init__()


# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/nT_sMhJsw1E
# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте)
# money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.

class Money:
    def __init__(self, x = 0):
        self.money = x

my_money = Money(100)
your_money = Money(1000)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/DEyOq7Gpko4
# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный
# ргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение
# black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой
# новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points
# укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.


class Point:
    def __init__(self, x, y, color='black'):
        self.x = x
        self.y = y
        self.color = color


points = [Point(c, c) for c in range(1, 2000, 2)]

points[1].color = 'yellow'



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/bPH4It1_d0c
# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты
# каждого класса следующими командами:
#
# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные
# числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний
# левый) в виде кортежей (a, b) и (c, d) соответственно.
#
# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect,
# или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке
# elements.
#
# В списке elements обнулите координаты объектов только для класса Line.
#
# P.S. На экран в программе ничего выводить не нужно.


import random

class Line:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Rect:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Ellipse:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)


elements = []
while len(elements) != 217:
    a, b, c, d = [random.randint(0, 9) for _ in range(4)]
    elements.append(random.choice([Line(0, 0, 0, 0), Rect(a, b, c, d), Ellipse(a, b, c, d)]))



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Vr4c1LgE91o
# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:
#
# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.
#
# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:
#
# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.
#
# Проверку параметров a, b, c проводить именно в таком порядке.
#
# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:
#
# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод
# is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).
#
# Sample Input:
# 3 4 5

# Sample Output:
# 3


# здесь объявите класс TriangleChecker
class TriangleChecker:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def is_triangle(self):
        if not all(map(lambda x: type(x) in (int, float), [self.a, self.b, self.c])):
            return 1
        elif not all(map(lambda x: x > 0, [self.a, self.b, self.c])):
            return 1
        elif self.a >= self.b + self.c or self.b >= self.a + self.c or self.c >= self.a + self.b:
            return 2
        else:
            return 3


a, b, c = map(int, input().split())  # эту строчку не менять
# здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
tr = TriangleChecker(a, b, c)
print(tr.is_triangle())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/a3Har3Z_89Q
# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
# 8 11 10 -32 0 7 18

# Sample Output:
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто


class Graph:

    def __init__(self, data, is_show = True):
        self.data = data[:]
        self.is_show = is_show

    def set_data(self, data):
        self.data = data
        return data

    def show_table(self):
        if self.is_show == True:
            return f'{" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_graph(self):
        if self.is_show == True:
            return f'Графическое отображение данных: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_bar(self):
        if self.is_show == True:
            return f'Столбчатая диаграмма: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def set_show(self, fl_show):
        self.is_show = fl_show

data_graph = list(map(int, input().split()))
gr = Graph(data=data_graph)
print(gr.show_bar())
gr.set_show(fl_show=False)
print(gr.show_table())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZTCdEB_6h1I
# Подвиг 7. Объявите в программе следующие несколько классов:
#
# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.
#
# Обеспечить возможность создания объектов каждого класса командами:
#
# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory,
# максимум N - по числу слотов памяти на материнской плате (N = 4).
#
# Объекты классов должны иметь следующие локальные свойства:
#
# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число
# слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory
# (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).
#
# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской
# плате в виде следующего списка из четырех строк:
#
# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']
#
# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).
#
# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.


class CPU:

    def __init__(self, name, fr):
        self.name = name
        self.fr = fr


class Memory:

    def __init__(self, name, volume):
        self.name = name
        self.volume = volume


class MotherBoard:

    def __init__(self,  name, cpu,  *mems):
        self.name = name
        self.cpu = cpu
        self.total_mem_slots = 4
        self.mem_slots = mems[:self.total_mem_slots]

    def get_config(self):
        return [f'Материнская плата: {self.name}',
                f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
                f'Слотов памяти: {self.total_mem_slots}',
                'Память: ' + "; ".join(map(lambda x: f"{x.name} - {x.volume}", self.mem_slots))]

mb = MotherBoard('', CPU('INTEL', 2000), Memory('Kingston', 2000))




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HbtVara1GPI
# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:
#
# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки
# (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.
#
# В классе Cart объявить методы:
#
# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:
#
# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']
#
# Объявите в программе следующие классы для описания товаров:
#
# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.
#
# Объекты этих классов должны создаваться командой:
#
# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:
#
# name - наименование;
# price - цена.
#
# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука
# (Notebook) и одну кружку (Cup). Названия и цены придумайте сами.
#
# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.


class Cart:

    def __init__(self, goods=[]):
        self.goods = goods

    def add(self, gd):
        self.goods.append(gd)

    def remove(self, indx):
        self.goods.remove(self.goods[indx])

    def get_list(self):
        return [f'{i.name}: {i.price}' for i in self.goods]


class Table:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class TV:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Notebook:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Cup:

    def __init__(self, name, price):
        self.name = name
        self.price = price


cart = Cart()
tv1 = TV('Samsung', 11000)
table = Table('IKEA', 5000)
notebook = Notebook('Mac', 100000)
notebook2 = Notebook('HP', 50000)
cup = Cup('Best Mommy', 500)

cart.add(tv1)
cart.add(tv1)
cart.add(table)
cart.add(notebook)
cart.add(notebook2)
cart.add(cup)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/3WfWCBKRKIM
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 9. Вам необходимо реализовать односвязный список (не список языка Python, объекты в списке не хранить, а
# формировать связанную структуру, показанную на рисунке) из объектов класса ListObject:
#
#
#
# Для этого объявите в программе класс ListObject, объекты которого создаются командой:
#
# obj = ListObject(data)
# Каждый объект класса ListObject должен содержать локальные свойства:
#
# next_obj - ссылка на следующий присоединенный объект (если следующего объекта нет, то next_obj = None);
# data - данные объекта в виде строки.
#
# В самом классе ListObject должен быть объявлен метод:
#
# link(self, obj) - для присоединения объекта obj такого же класса к текущему объекту self (то есть, атрибут next_obj
# объекта self должен ссылаться на obj).
#
# Прочитайте список строк из входного потока командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Затем сформируйте односвязный список, в объектах которых (в атрибуте data) хранятся строки из списка lst_in (первая
# строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса ListObject должна ссылаться
# переменная head_obj.
#
# P.S. В программе что-либо выводить на экран не нужно.
#
# Sample Input:
# 1. Первые шаги в ООП
# 1.1 Как правильно проходить этот курс
# 1.2 Концепция ООП простыми словами
# 1.3 Классы и объекты. Атрибуты классов и объектов
# 1.4 Методы классов. Параметр self
# 1.5 Инициализатор init и финализатор del
# 1.6 Магический метод new. Пример паттерна Singleton
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)

# Sample Output:


import sys


# здесь объявляются все необходимые классы
class ListObject:

    def __init__(self, data):
        self.data = data
        self.next_obj = None

    def link(self, obj):
        self.next_obj = obj


# считывание списка из входного потока (эту строку не менять)
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять

# здесь создаются объекты классов и вызываются нужные методы
head_obj = ListObject(lst_in[0])
obj = head_obj
for i in range(1, len(lst_in)):
    obj_new = ListObject(lst_in[i])
    obj.link(obj_new)
    obj = obj_new



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/gmjwMakXk0c
# Большой подвиг 10. Объявите два класса:
#
# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.
#
# С помощью класса Cell предполагается создавать отдельные клетки командой:
#
# c1 = Cell(around_mines, mine)
# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева величина (True/False), означающая наличие
# мины в текущей клетке. При этом, в каждом объекте класса Cell должны создаваться локальные свойства:
#
# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).

# С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N x N:
#
# pole_game = GamePole(N, M)
# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все
# объекты хранятся в двумерном списке N x N элементов - локальном свойстве pole объекта класса GamePole.
#
# В классе GamePole должны быть также реализованы следующие методы:
#
# init() - инициализация поля с новой расстановкой M мин (случайным образом по игровому полю, разумеется каждая мина
# должна находиться в отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается
# символ #).
#
# При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной
# инициализации игрового поля.
#
# В классе GamePole могут быть и другие вспомогательные методы.
#
# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и числом мин M = 12.
#
# P.S. На экран в программе ничего выводить не нужно.


from random import randint

class Cell:
    def __init__(self, around_mines=0, mine=False):
        self.around_mines = around_mines
        self.mine = mine
        self.fl_open = False

class GamePole:
    def __init__(self, N, M):
        self._n = N
        self._m = M
        self.pole = [[Cell() for n in range(self._n)] for n in range(self._n)]
        self.init()

    def init(self):
        m = 0
        while m < self._m:
            i = randint(0, self._n - 1)
            j = randint(0, self._n - 1)
            if self.pole[i][j].mine:
                continue
            self.pole[i][j].mine = True
            m += 1

        indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
        for x in range(self._n):
            for y in range(self._n):
                if not self.pole[x][y].mine:
                    mines = sum((self.pole[x+i][y+j].mine for i, j in indx if 0 <= x+i < self._n and 0 <= y+j < self._n))
                    self.pole[x][y].around_mines = mines

    def show(self):
        for row in self.pole:
            print(*map(lambda x: '#' if not x.fl_open else x.around_mines if not x.mine else '*', row))


pole_game = GamePole(10, 12)
pole_game.show()



# ----------------------------------------------------------------------------------------------------------------------
# 1.6 Магический метод __new__. Пример паттерна Singleton
# ----------------------------------------------------------------------------------------------------------------------


# Подвиг 1. В какой момент вызывается магический метод __new__()?
# - непосредственно перед созданием объекта класса


# Подвиг 2. Что должен возвращать магический метод __new__() для успешного создания объектов класса?
# - адрес нового созданного объекта


# Подвиг 3. Конструктор класса (метод __new__) можно записать со следующей сигнатурой:
#
# def __new__(cls, *args, **kwargs): ...

# Какую роль здесь играет первый параметр cls?
# - ссылка на класс, для которого создается объект


# Подвиг 4. В каком порядке вызывается конструктор класса __new__() и инициализатор __init__() при создании объекта
# класса?
# - сначала всегда вызывается метод __new__(), затем метод __init__()


# Подвиг 5. При переопределении метода __new__() объект создается командой super().__new__(cls):
#
# def __new__(cls, *args, **kwargs):
#    return super().__new__(cls)

# Выберите верное утверждение для ее объяснения.
# - Идет обращение к базовому классу, из которого вызывается конструктор - метод __new__(cls) с аргументом cls - ссылки
# на текущий класс



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/7aVqWfrAdqw
# Подвиг 6. Объявите класс AbstractClass, объекты которого нельзя было бы создавать. При выполнении команды:
#
# obj = AbstractClass()
# переменная obj должна ссылаться на строку с содержимым:
#
# "Ошибка: нельзя создавать объекты абстрактного класса"
#
# P.S. В программе объявить только класс, выводить на экран ничего не нужно.

class AbstractClass:

    def __new__(cls, *args, **kwargs):
        return "Ошибка: нельзя создавать объекты абстрактного класса"



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/uE1uf7Qtbh4
#
# Подвиг 7. Объявите класс SingletonFive, с помощью которого можно было бы создавать объекты командой:
#
# a = SingletonFive(<наименование>)
# Здесь <наименование> - это данные, которые сохраняются в локальном свойстве name созданного объекта.
#
# Этот класс должен формировать только первые пять объектов. Остальные (шестой, седьмой и т.д.) должны быть ссылкой на
# последний (пятый) созданный объект.
#
# Создайте первые десять объектов класса SingletonFive с помощью следующего фрагмента программы:
#
# objs = [SingletonFive(str(n)) for n in range(10)]
# P.S. В программе на экран ничего выводить не нужно.


class SingletonFive:
    __instance = None
    __count = 0

    def __new__(cls, *args, **kwargs):
        if cls.__count < 5:
            cls.__instance = super().__new__(cls)
            cls.__count += 1

        return cls.__instance

    def __init__(self, name):
        self.name = name


obj = [SingletonFive(str(n)) for n in range(10)]



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/sX_uP7GVqkc
# Подвиг 8. В программе объявлена переменная TYPE_OS и два следующих класса:
#
# TYPE_OS = 1 # 1 - Windows; 2 - Linux
#
# class DialogWindows:
#     name_class = "DialogWindows"
#
#
# class DialogLinux:
#     name_class = "DialogLinux"
# Необходимо объявить третий класс с именем Dialog, который бы создавал объекты командой:
#
# dlg = Dialog(<название>)
# Здесь <название> - это строка, которая сохраняется в локальном свойстве name объекта dlg.
#
# Класс Dialog должен создавать объекты класса DialogWindows, если переменная TYPE_OS = 1 и объекты класса DialogLinux,
# если переменная TYPE_OS не равна 1. При этом, переменная TYPE_OS может меняться в последующих строчках программы.
# Имейте это в виду, при объявлении класса Dialog.
#
# P.S. В программе на экран ничего выводить не нужно. Только объявить класс Dialog


TYPE_OS = 1 # 1 - Windows; 2 - Linux

class DialogWindows:
    name_class = "DialogWindows"


class DialogLinux:
    name_class = "DialogLinux"


class Dialog:

    def __new__(cls, *args, **kwargs):
        obj = None
        if TYPE_OS == 1:
            obj = super().__new__(DialogWindows)
        else:
            obj = super().__new__(DialogLinux)

        obj.name = args[0]
        return obj



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/U4zwfmbEiCI
# Подвиг 9 (на повторение материала). Объявите класс Point для представления точек на плоскости. Создавать объекты
# этого класса предполагается командой:
#
# pt = Point(x, y)
# Здесь x, y - числовые координаты точки на плоскости (числа), то есть, в каждом объекте этого класса создаются
# локальные свойства x, y, которые хранят конкретные координаты точки.
#
# Необходимо в классе Point реализовать метод clone(self), который бы создавал новый объект класса Point как копию
# текущего объекта с локальными атрибутами x, y и соответствующими значениями.
#
# Создайте в программе объект pt класса Point и еще один объект pt_clone через вызов метода clone.
#
# P.S. В программе на экран ничего выводить не нужно.


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def clone(self):
        return Point(self.x, self.y)

pt = Point(1, 2)
pt_clone = pt.clone()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5aJVuJ5jGqk
# Подвиг 10 (на повторение материала). В программе предполагается реализовать парсер (обработчик) строки (string) в
# определенный выходной формат. Для этого объявлен следующий класс:
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#
#         return seq
#
# И предполагается его использовать следующим образом:
#
# ld = Loader()
# res = ld.parse_format("4, 5, -6.5", Factory())
# На выходе (в переменной res) ожидается получить список из набора вещественных чисел. Например, для заданной строки,
# должно получиться:
#
# [4.0, 5.0, -6.5]
#
# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя методами:
#
# build_sequence(self) - для создания начального пустого списка (метод должен возвращать пустой список);
# build_number(self, string) - для преобразования переданной в метод строки (string) в вещественное значение (метод
# должен возвращать полученное вещественное число).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


class Factory:

    def build_sequence(self):
        return []


    def build_number(self, string):
        return float(string)


class Loader:
    def parse_format(self, string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
ld = Loader()
s = input()
res = ld.parse_format(s, Factory())



# ----------------------------------------------------------------------------------------------------------------------
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)
# ----------------------------------------------------------------------------------------------------------------------

# Теория
class Test:
    x = 1
    y = 2

    def __init__(self):
        self.x = 3
        self.y = 4

    @staticmethod
    def static_method(x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    @classmethod
    def class_method(cls, x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y
        d = Test.x + Test.y
        return a, b, c, d

    def self_method(self, x, y):
        a = x + y
        b = self.x + self.y
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    def func_method(x, y):  # <-- ОШИБКА пихает в х ссылку на объект, ошибка при вызове
        a = x + y  # <-- ОШИБКА ^
        b = self.x + self.y  # <-- ОШИБКА ^
        c = cls.x + cls.y  # <-- ОШИБКА ^
        d = Test.x + Test.y
        return a, b, c, d

    def empty_method():  # <-- ОШИБКА не знает куда бы запихнуть ссылку на объект
        return 123




# Подвиг 1. В программе объявлен следующий класс с одним методом:
class Stepik:
    def get_certificate(self):
        return False

# И создается объект этого класса:

st = Stepik()
# Выберите все верные варианты вызова метода get_certificate:
# - Stepik.get_certificate(st)
# - st.get_certificate()


# Подвиг 2. В программе объявлен следующий класс с одним методом:
class Loader:
    @classmethod
    def json_parse(cls):
        return ""

# И создается объект этого класса:

ld = Loader()

# Выберите все верные варианты вызова метода json_parse:
# - Loader.json_parse()
# - ld.json_parse()
# - res = Loader.json_parse()
# - res = ld.json_parse()



# Подвиг 3. В программе объявлен следующий класс с одним методом:
class Math:
    @staticmethod
    def sqrt(x):
        return x ** 0.5

# И создается объект этого класса:

m = Math()

# Выберите все верные варианты вызова метода sqrt:
# - res = m.sqrt(2)
# - res = Math.sqrt(4)


# Подвиг 4. За что отвечает параметр cls в методах класса, объявленных следующим образом:
class Loader:
    @classmethod
    def json_parse(cls): ...

# - Ссылка на класс Loader


# Подвиг 5. В чем отличие между методами класса (объявленными через @classmethod) и статическими методами
# (объявленными через @staticmethod)?

# - методы класса предназначены для работы с атрибутами класса и переданными аргументами, а статические - только с
# переданными им аргументами


# Подвиг 6. В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной
# формат. Для этого объявлен следующий класс:

class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)

class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq

# И предполагается его использовать следующим образом:

res = Loader.parse_format("4, 5, -6", Factory)

# На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки,
# должно получиться:

[4, 5, -6]

# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:
#
# build_sequence() - для создания пустого списка (метод возвращает пустой список);
# build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное
# значение).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


# Здесь объявляется класс Factory
class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)


class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
res = Loader.parse_format("1, 2, 3, -5, 10", Factory)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/D02X5B6zLi8
# Подвиг 7. В программе объявлен следующий класс для работы с формами ввода логин/пароль:

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])

# Который предполагается использовать следующим образом:

# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()

# Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

# login = TextInput(name, size)
# psw = PasswordInput(name, size)

# В каждом объекте этих классов должны быть следующие локальные свойства:

# name - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");
# size - размер поля ввода (целое число, по умолчанию 10).

# Также классы TextInput и PasswordInput должны иметь метод:

# get_html(self) - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса
# PasswordInput):

# <p class='login'><имя поля>: <input type='text' size=<размер поля> />
# <p class='password'><имя поля>: <input type='text' size=<размер поля> />

# Например, для поля login:

# <p class='login'>Логин: <input type='text' size=10 />

# Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

# check_name(cls, name) - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по
# следующим критериям:

# - длина имени не менее 3 символов и не более 50;
# - в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

# Если проверка не проходит, то генерировать исключение командой:

# raise ValueError("некорректное поле name")
# Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

# CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
# CHARS_CORRECT = CHARS + CHARS.upper() + digits
# По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

# P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это
# нормально.

from string import ascii_lowercase, digits

# здесь объявляйте классы TextInput и PasswordInput
class TextInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size


    def get_html(self):
        return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class PasswordInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size

    def get_html(self):
        return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class FormLogin:
    def __init__(self, lgn, psw):
        self.login = lgn
        self.password = psw

    def render_template(self):
        return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])


# эти строчки не менять
login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
html = login.render_template()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/9766M0dS1qc
#
# Подвиг 8. Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь
# следующие методы:
#
# check_card_number(number) - проверяет строку с номером карты и возвращает булево значение True, если номер в верном
# формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).
# check_name(name) - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя
# записано верно и False - в противном случае.
#
# Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами.
# Например, SERGEI BALAKIREV.
#
# Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):

# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# Для проверки допустимых символов в классе должен быть прописан атрибут:

# CHARS_FOR_NAME = ascii_lowercase.upper() + digits
# Подумайте, как правильнее объявить методы check_card_number и check_name (декораторами @classmethod и @staticmethod).

# P.S. В программе только объявить класс. На экран ничего выводить не нужно.
from string import ascii_lowercase, digits
class CardCheck:
    CHARS_FOR_NAME = ascii_lowercase.upper() + digits

    @staticmethod
    def check_card_number(number):
        number_card_list = number.split('-')
        if len(number_card_list) != 4:
            return False
        for i in number_card_list:
            if len(i) == 4 and i.isdigit():
                continue
            else:
                return False
        return True

    @classmethod
    def check_name(cls, name):
        if name.count(' ') == 1:
            name = name.replace(' ', '')
            for i in name:
                if i in cls.CHARS_FOR_NAME:
                    continue
                else:
                    return False
        else:
            return False
        return True


# При помощи регулярок
import re


class CardCheck:
    @staticmethod
    def check_card_number(number):
        return bool(re.fullmatch(r"\d{4}(?:-\d{4}){3}", number))

    @staticmethod
    def check_name(name):
        return bool(re.fullmatch(r"[A-Z\d]+ [A-Z\d]+", name))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YkDq9p8n17A
#
# Подвиг 9. Объявите в программе класс Video с двумя методами:
#
# create(self, name) - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name
# объекта класса Video);
# play(self) - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео <name>").
#
# Объявите еще один класс с именем YouTube, в котором объявите два метода (с декоратором @classmethod):
#
# add_video(cls, video) - для добавления нового видео (метод помещает объект video класса Video в список);
# play(cls, video_indx) - для проигрывания видео из списка по указанному индексу (индексация с нуля).
#
# (здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):
#
# videos - для хранения добавленных объектов класса Video (изначально список пуст).
#
# Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать
# метод play() класса Video.
#
# Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.
#
# Создайте два объекта v1 и v2 класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП".
# После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью
# метода play класса YouTube) сначала первое, а затем, второе видео.
#
# Sample Input:
#
# Sample Output:
#
# воспроизведение видео Python
# воспроизведение видео Python ООП

class Video:
    name = None
    def create(self, name):
        self.name = name

    def play(self):
        print(f'воспроизведение видео {self.name}')


class YouTube:
    videos = []

    @classmethod
    def add_video(cls, video):
        cls.videos.append(video)

    @classmethod
    def play(cls, video_indx):
        cls.videos[video_indx].play()

v1 = Video()
v2 = Video()
v1.create('Python')
v2.create('Python ООП')
YouTube.add_video(v1)
YouTube.add_video(v2)
YouTube.play(0)
YouTube.play(1)




# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Y4Hvpg4FuKs
#
# Подвиг 10 (на повторение). Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом
# классе должны быть реализованы следующие методы:
#
# add_application(self, app) - добавление нового приложения app в магазин;
# remove_application(self, app) - удаление приложения app из магазина;
# block_application(self, app) - блокировка приложения app (устанавливает локальное свойство blocked объекта app в
# значение True);
# total_apps(self) - возвращает общее число приложений в магазине.
#
# Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):
#
# store = AppStore()
# app_youtube = Application("Youtube")
# store.add_application(app_youtube)
# store.remove_application(app_youtube)
# Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application
# должен содержать локальные свойства:
#
# name - наименование приложения (строка);
# blocked - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).
#
# Как хранить список приложений в объектах класса AppStore решите сами.
#
# P.S. В программе нужно только объявить классы с указанным функционалом.


class AppStore:

    def __init__(self):
        self.apps = []
    def add_application(self, app):
        self.apps.append(app)

    def remove_application(self, app):
        self.apps.remove(app)

    def block_application(self, app):
        app.blocked = True

    def total_apps(self):
        return len(self.apps)


class Application:
    def __init__(self, name, blocked=False):
        self.name = name
        self.blocked = blocked



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/38QoBSpQqnM
#
# Подвиг 11 (на повторение). Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:
#
# add_message(msg) - добавление нового сообщения в список сообщений;
# remove_message(msg) - удаление сообщения из списка;
# set_like(msg) - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет
# то он ставится, если уже есть, то убирается);
# show_last_message(число) - отображение последних сообщений;
# total_messages() - возвращает общее число сообщений.
#
# Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# Viber.remove_message(msg)
# Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных
# свойств:
#
# text - текст сообщения (строка);
# fl_like - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном
# случае, изначально False);
#
# P.S. Как хранить список сообщений, решите самостоятельно.

class Message:
    def __init__(self, text, fl_like=False):
        self.text = text
        self.fl_like = fl_like

class Viber:

    msgs = []

    @classmethod
    def add_message(cls, msg):
        cls.msgs.append(msg)

    @classmethod
    def remove_message(cls, msg):
        cls.msgs.remove(msg)

    @classmethod
    def set_like(cls, msg):
        if msg.fl_like:
            msg.fl_like = False
        else:
            msg.fl_like = True

    @classmethod
    def show_last_message(cls, amount):
        print(cls.msgs[-amount:])

    @classmethod
    def total_messages(cls):
        return len(cls.msgs)


# ======================================================================================================================
# 1.8 Испытание свойствами и методами
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор (решение смотреть только после своей попытки): https://youtu.be/26pwwOu_-d0
#
# Время первого испытания. Представьте, что вы получили задание от заказчика. Вас просят реализовать простую имитацию
# локальной сети, состоящую из набора серверов, соединенных между собой через роутер.
#
#
#
# Каждый сервер может отправлять пакет любому другому серверу сети. Для этого у каждого есть свой уникальный IP-адрес.
# Для простоты - это просто целое (натуральное) число от 1 и до N, где N - общее число серверов. Алгоритм следующий.
# Предположим, сервер с IP = 2 собирается отправить пакет информации серверу с IP = 3. Для этого, он сначала отправляет
# пакет роутеру, а уже тот, смотрит на IP-адрес и пересылает пакет нужному узлу (серверу).
#
# Для реализации этой схемы программе предлагается объявить три класса:
#
# Server - для описания работы серверов в сети;
# Router - для описания работы роутеров в сети (в данной задаче полагается один роутер);
# Data - для описания пакета информации.
#
# Серверы будут создаваться командой:
#
# sv = Server()
# При этом, уникальный IP-адрес каждого сервера должен формироваться автоматически при создании нового экземпляра
# класса Server.
#
# Далее, роутер должен создаваться аналогичной командой:
#
# router = Router()
# А, пакеты данных, командой:
#
# data = Data(строка с данными, IP-адрес назначения)
# Для формирования и функционирования локальной сети, в классе Router должны быть реализованы следующие методы:
#
# link(server) - для присоединения сервера server (объекта класса Server) к роутеру (для простоты, каждый сервер
# соединен только с одним роутером);
# unlink(server) - для отсоединения сервера server (объекта класса Server) от роутера;
# send_data() - для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после
# отправки буфер должен очищаться).
#
# И одно обязательное локальное свойство (могут быть и другие свойства):
#
# buffer - список для хранения принятых от серверов пакетов (объектов класса Data).
#
# Класс Server должен содержать свой набор методов:
#
# send_data(data) - для отправки информационного пакета data (объекта класса Data) с указанным IP-адресом получателя
# (пакет отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# get_data() - возвращает список принятых пакетов (если ничего принято не было, то возвращается пустой список) и
# очищает входной буфер;
# get_ip() - возвращает свой IP-адрес.
#
# Соответственно в объектах класса Server должны быть локальные свойства:
#
# buffer - список принятых пакетов (объекты класса Data, изначально пустой);
# ip - IP-адрес текущего сервера.
#
# Наконец, объекты класса Data должны содержать два следующих локальных свойства:
#
# data - передаваемые данные (строка);
# ip - IP-адрес назначения.
#
# Пример использования этих классов (эти строчки в программе писать не нужно):
#
# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# Ваша задача реализовать классы Router, Server и Data в соответствии с приведенным техническим заданием (ТЗ).
# Что-либо выводить на экран не нужно.


class Router:

    def __init__(self):
        self.buffer = []
        self.servers = {}

    def link(self, server):
        self.servers[server.ip] = server
        server.router = self

    def unlink(self, server):
        s = self.servers.pop(server.ip, False)
        if s:
            s.router = None

    def send_data(self):
        for d in self.buffer:
            if d.ip in self.servers:
                self.servers[d.ip].buffer.append(d)
        self.buffer.clear()

class Server:
    server_ip = 1

    def __init__(self):
        self.buffer = []
        self.ip = Server.server_ip
        Server.server_ip += 1
        self.router = None

    def send_data(self, data):
        if self.router:
            self.router.buffer.append(data)

    def get_data(self):
        b = self.buffer[:]
        self.buffer.clear()
        return b

    def get_ip(self):
        return self.ip


class Data:

    def __init__(self, msg, ip):
        self.data = msg
        self.ip = ip



# ======================================================================================================================
# 2. Режимы доступа, свойства и дескрипторы
# ======================================================================================================================

# ======================================================================================================================
# 2.1. Режимы доступа public, private, protected. Сеттеры и геттеры
# ----------------------------------------------------------------------------------------------------------------------

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствия между именами атрибутов классов и их режимами доступа.

# self.data - публичный режим доступа (public)
# self._word - защищенный режим доступа (protected)
# self.__buffer - приватный режим доступа (private)

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Какую роль играет приватный (private) режим доступа атрибутов классов?

# - скрывает приватные переменные и методы от прямого доступа к ним (по исходным именам) вне класса
# - предостерегает программиста (использующего класс) от прямого использования приватных атрибутов вне класса

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Lqo3xcfaUZU
# Подвиг 3. Объявите класс с именем Clock и определите в нем следующие переменные и методы:
#
# - приватная локальная переменная time для хранения текущего времени, целое число (своя для каждого объекта класса
# Clock с начальным значением 0);
# - публичный метод set_time(tm) для установки текущего времени (присваивает значение tm приватному локальному свойству
# time, если метод check_time(tm) возвратил True);
# - публичный метод get_time() для получения текущего времени из приватной локальной переменной time;
# - приватный метод класса check_time(tm) для проверки корректности времени в переменной tm (возвращает True, если
# значение корректно и False - в противном случае).
#
# Проверка корректности выполняется по критерию: tm должна быть целым числом, больше или равна нулю и меньше 100 000.
#
# Объекты класса Clock предполагается использовать командой:
#
# clock = Clock(время)
# Создайте объект clock класса Clock и установите время, равным 4530.
#
# P.S. На экран ничего выводить не нужно.

class Clock:

    def __init__(self, time=0):
        self.__time = time

    def __check_time(self, tm):
        return True if type(tm) == int and 0 <= tm <= 100000 else False

    def set_time(self, tm):
        if self.__check_time(tm):
            self.__time = tm

    def get_time(self):
        return self.__time

clock = Clock(4530)


# Вторая версия
class Clock:
    __MIN_TIME = 0
    __MAX_TIME = 100_000

    def __init__(self, time=0):
        self.__time = time if self.__check_time(time) else 0

    def set_time(self, tm):
        if self.__check_time(tm):
            self.__time = tm

    def get_time(self):
        return self.__time

    @classmethod
    def __check_time(cls, tm):
        return type(tm) is int and cls.__MIN_TIME <= tm < cls.__MAX_TIME


clock = Clock()
clock.set_time(4530)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/iYcfCeRTyww
# Подвиг 4. Объявите класс с именем Money и определите в нем следующие переменные и методы:
#
# - приватная локальная переменная money (целочисленная) для хранения количества денег (своя для каждого объекта класса
# Money);
# - публичный метод set_money(money) для передачи нового значения приватной локальной переменной money (изменение
# выполняется только если метод check_money(money) возвращает значение True);
# - публичный метод get_money() для получения текущего объема средств (денег);
# - публичный метод add_money(mn) для прибавления средств из объекта mn класса Money к средствам текущего объекта;
# - приватный метод класса check_money(money) для проверки корректности объема средств в параметре money (возвращает
# True, если значение корректно и False - в противном случае).
#
# Проверка корректности выполняется по критерию: параметр money должен быть целым числом, больше или равным нулю.
#
# Пример использования класса Money (эти строчки в программе не писать):
#
# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120


class Money:

    def __init__(self, money):
        self.__money = money

    def set_money(self, money):
        if self.__check_money(money):
            self.__money = money

    @classmethod
    def __check_money(cls, money):
        return True if type(money) is int and money >= 0 else False

    def get_money(self):
        return self.__money

    def add_money(self, mn):
        self.__money += mn.get_money()


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Какую роль в классах играют сеттеры и геттеры и что они из себя представляют?

# - это публичные методы для считывания и записи значений в приватные переменные класса или его объектов


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/w0SAD6zNLlw
# Подвиг 6. Объявите класс Book со следующим набором сеттеров и геттеров:
#
# set_title(self, title) - запись в локальное приватное свойство __title объектов класса Book значения title;
# set_author(self, author) - запись в локальное приватное свойство __author объектов класса Book значения author;
# set_price(self, price) - запись в локальное приватное свойство __price объектов класса Book значения price;
# get_title(self) - получение значения локального приватного свойства __title объектов класса Book;
# get_author(self) - получение значения локального приватного свойства __author объектов класса Book;
# get_price(self) - получение значения локального приватного свойства __price объектов класса Book;
#
# Объекты класса Book предполагается создавать командой:
#
# book = Book(автор, название, цена)
# При этом, в каждом объекте должны создаваться приватные локальные свойства:
#
# __author - строка с именем автора;
# __title - строка с названием книги;
# __price - целое число с ценой книги.
#
# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.


class Book:

    def __init__(self, author, title, price):
        self.__author = author
        self.__title = title
        self.__price = price

    def set_title(self, title):
        self.__title = title

    def set_author(self, author):
        self.__author = author

    def set_price(self, price):
        self.__price = price

    def get_title(self):
        return self.__title

    def get_author(self):
        return self.__author

    def get_price(self):
        return self.__price


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZX8fVI0KTfE
# Подвиг 7. Объявите класс Line для описания линии на плоскости, объекты которого предполагается создавать командой:
#
# line = Line(x1, y1, x2, y2)
# При этом в объекте line должны создаваться следующие приватные локальные свойства:
#
# __x1, __y1 - начальная координата;
# __x2, __y2 - конечная координата.
#
# В самом классе Line должны быть реализованы следующие сеттеры и геттеры:
#
# set_coords(self, x1, y1, x2, y2) - для изменения координат линии;
# get_coords(self) - для получения кортежа из текущих координат линии.
#
# А также метод:
#
# draw(self) - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).
#
# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

class Line:

    def __init__(self, x1, y1, x2, y2):
        self.__x1 = x1
        self.__x2 = x2
        self.__y1 = y1
        self.__y2 = y2

    def set_coords(self, x1, y1, x2, y2):
        self.__x1 = x1
        self.__x2 = x2
        self.__y1 = y1
        self.__y2 = y2

    def get_coords(self):
        return self.__x1, self.__y1, self.__x2, self.__y2

    def draw(self):
        print(*self.get_coords())


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rcj0pB1aB5M
#
# Подвиг 8. Объявите в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:
#
# pt = Point(x, y)
# где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point должны
# формироваться следующие локальные свойства:
#
# __x, __y - координаты точки на плоскости.
#
# и один геттер:
#
# get_coords() - возвращение кортежа текущих координат __x, __y
#
# Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:
#
# r1 = Rectangle(Point(x1, y1), Point(x2, y2))
# или
#
# r2 = Rectangle(x1, y1, x2, y2)
# Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в
# объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:
#
# __sp - объект класса Point с координатами x1, y1 (верхний левый угол);
# __ep - объект класса Point с координатами x2, y2 (нижний правый угол).
#
# Также к классе Rectangle должны быть реализованы следующие методы:
#
# set_coords(self, sp, ep) - изменение текущих координат, где sp, ep - объекты класса Point;
# get_coords(self) - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника (ссылки на
# локальные свойства __sp и __ep);
# draw(self) - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)".
# Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.
#
# Создайте объект rect класса Rectangle с координатами (0, 0), (20, 34).
#
# P.S. На экран ничего выводить не нужно.


class Point:

    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def get_coords(self):
        return self.__x, self.__y


class Rectangle:

    def __init__(self, *args):
        if len(args) == 4:
            self.__sp = Point(args[0], args[1])
            self.__ep = Point(args[2], args[3])
        else:
            self.__sp = args[0]
            self.__ep = args[1]

    def set_coords(self, sp, ep):
        self.__sp = sp
        self.__ep = ep

    def get_coords(self):
        return self.__sp, self.__ep

    def draw(self):
        print(f'Прямоугольник с координатами: {self.__sp.get_coords()} {self.__ep.get_coords()}')


rect = Rectangle(0, 0, 20, 34)

# Второй вариант
class Point:
    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def get_coords(self):
        return self.__x, self.__y


class Rectangle:
    def __init__(self, *args):
        if len(args) == 2:
            self.set_coords(*args)
        elif len(args) == 4:
            x1, y1, x2, y2 = args
            self.set_coords(Point(x1, y1), Point(x2, y2))

    def set_coords(self, sp, ep):
        self.__sp = sp
        self.__ep = ep

    def get_coords(self):
        return self.__sp, self.__ep

    def draw(self):
        x1, y1, x2, y2 = self.__sp, self.__ep
        print(f'Прямоугольник с координатами: ({x1}, {y1}) ({x2}, {y2})')


rect = Rectangle(0, 0, 20, 34)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YJiPpHVguyE
# Теория по двусвязным спискам (при необходимости): https://youtu.be/0sTH9EwXT1I

# Большой подвиг 9. Необходимо реализовать связный список (не список языка Python и не хранить объекты в списке Python),
# когда объекты класса ObjList связаны с соседними через приватные свойства __next и __prev:

# Для этого объявите класс LinkedList, который будет представлять связный список в целом и иметь набор следующих
# методов:
#
# add_obj(self, obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(self) - удаление последнего объекта из связного списка;
# get_data(self) - получение списка из строк локального свойства __data всех объектов связного списка.
#
# И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пустой, то head = None);
# tail - ссылка на последний объект связного списка (если список пустой, то tail = None).
#
# Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:
#
# __next - ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);
# __prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);
# __data - строка с данными.
#
# Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:
#
# set_next(self, obj) - изменение приватного свойства __next на значение obj;
# set_prev(self, obj) - изменение приватного свойства __prev на значение obj;
# get_next(self) - получение значения приватного свойства __next;
# get_prev(self) - получение значения приватного свойства __prev;
# set_data(self, data) - изменение приватного свойства __data на значение data;
# get_data(self) - получение значения приватного свойства __data.
#
# Создавать объекты класса ObjList предполагается командой:
#
# ob = ObjList("данные 1")
# А использовать класс LinkedList следующим образом (пример, эти строчки писать в программе не нужно):
#
# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
# Объявите в программе классы LinkedList и ObjList в соответствии с заданием.
#
# P.S. На экран ничего выводить не нужно.

class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if self.tail:
            self.tail.set_next(obj)
        obj.set_prev(self.tail)
        self.tail = obj
        if not self.head:
            self.head = obj

    def remove_obj(self):
        if self.tail is None:
            return

        prev = self.tail.get_prev()
        if prev:
            prev.set_next(None)

        self.tail = prev
        if self.tail is None:
            self.head = None

    def get_data(self):
        l = []
        getter = self.head
        while getter:
            l.append(getter.get_data())
            getter = getter.get_next()
        return l



class ObjList:

    def __init__(self, data):
        self.__next = None
        self.__prev = None
        self.__data = data

    def set_next(self, obj):
        self.__next = obj

    def set_prev(self, obj):
        self.__prev = obj

    def set_data(self, data):
        self.__data = data

    def get_next(self):
        return self.__next

    def get_prev(self):
        return self.__prev

    def get_data(self):
        return self.__data


lst = LinkedList()
lst.add_obj(ObjList("данные 1"))
lst.add_obj(ObjList("данные 2"))
lst.add_obj(ObjList("данные 3"))
res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']

print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HPgJtLb2NV8
# Подвиг 10 (на повторение). Объявите класс EmailValidator для проверки корректности email-адреса. Необходимо запретить
# создание объектов этого класса: при создании экземпляров должно возвращаться значение None, например:
#
# em = EmailValidator() # None
# В самом классе реализовать следующие методы класса (@classmethod):
#
# get_random_email(cls) - для генерации случайного email-адреса по формату: xxxxxxx...xxx@gmail.com, где x - любой
# допустимый символ в email (латинский буквы, цифры, символ подчеркивания и точка);
# check_email(cls, email) - возвращает True, если email записан верно и False - в противном случае.
#
# Корректность строки email определяется по следующим критериям:
#
# - допустимые символы: латинский алфавит, цифры, символы подчеркивания, точки и собачка @ (одна);
# - длина email до символа @ не должна превышать 100 (сто включительно);
# - длина email после символа @ не должна быть больше 50 (включительно);
# - после символа @ обязательно должна идти хотя бы одна точка;
# - не должно быть двух точек подряд.
#
# Также в классе нужно реализовать приватный статический метод класса:
#
# is_email_str(email) - для проверки типа переменной email, если строка, то возвращается значение True, иначе - False.
#
# Метод is_email_str() следует использовать в методе check_email() перед проверкой корректности email. Если параметр
# email не является строкой, то check_email() возвращает False.
#
# Пример использования класса EmailValidator (эти строчки в программе писать не нужно):
#
# res = EmailValidator.check_email("sc_lib@list.ru") # True
# res = EmailValidator.check_email("sc_lib@list_ru") # False
# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.

import random
import string

class EmailValidator:
    __CHARS = string.ascii_letters + string.digits + '_.'

    def __new__(cls, *args, **kwargs):
        return None

    @classmethod
    def get_random_email(cls):
        res = ''
        for i in range(random.randint(1, 100)):
            res += random.choice(EmailValidator.__CHARS)
        res += '@gmail.com'
        if EmailValidator.check_email(res):
            return res
        else:
            EmailValidator.get_random_email()

    @classmethod
    def check_email(cls, email):
        if len(email[:email.index('@')]) > 100 or len(email[email.index('@'):]) > 50:
            return False
        if email[email.index('@'):].count('.') < 1:
            return False
        if email.count('..') > 0:
            return False
        for i in email:
            if i == '@':
                continue
            if i not in EmailValidator.__CHARS:
                return False
        return True

    @staticmethod
    def __is_email_str(email):
        if type(email) == str:
            return True
        else:
            return False
