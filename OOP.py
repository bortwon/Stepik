# Добрый, добрый Python ООП - обучающий курс от Сергея Балакирева
# ======================================================================================================================
# 1. ПЕРВЫЕ ШАГИ В ООП.

# ----------------------------------------------------------------------------------------------------------------------
# 1.2 Концепция ООП простыми словами


# Подвиг 1. Что составляет основу ООП?
# - инкапсуляция
# - наследование
# - полиморфизм

# Подвиг 2. Как следует воспринимать класс в ООП?
# - как шаблон, по которому конструируются объекты этого класса

# Подвиг 3. В чем суть идеи наследования в ООП?
# - на основе одного или нескольких классов создается новый (дочерний) класс
# - наследование позволяет как бы вынести «за скобки» общее для разных классов

# Подвиг 4. Можно ли создавать программы без использования ООП?
# - да, например, используя парадигму структурного программирования (не включая ООП)

# Подвиг 5. Вам предстоит написать программу хранения информации по книгам: автор, заголовок, год издания, число
# страниц. Помогут ли здесь классы для представления этой разнородной информации?
# - да, описать каждую книгу как объект класса "Книга" хорошая идея

# Подвиг 6. Каким термином из ООП можно охарактеризовать ограничение доступа к элементам класса?
# - инкапсуляция

# Подвиг 7. Вам предстоит создать программу несложного графического редактора с рисованием различных графических
# примитивов (линия, прямоугольник, эллипс, треугольник и т.п.). Будет ли иметь смысл использовать при ее реализации
# концепцию ООП?
# - да, ООП здесь может заметно упростить программный код

# Подвиг 8. Каким термином из ООП можно охарактеризовать универсальность интерфейса доступа к разным типам данных?
# - полиморфизм


# ---------------------------------------------------------------------------------------------------------------------
# 1.3. Классы и объекты. Атрибуты классов и объектов

# setattr(Point, 'prop', 1) - функция создает новый атрибут в указанном пространстве имен(в данном случае в классе
# Point) с заданным значением.

# getattr(Point, 'a', False) - функция для обращения к тому или иному атрибуту класса, ей пользуются только в том
# случае, если есть опасность обращения к несуществующим атрибутам.

# delattr(Point, 'type_pt') - функция для удаления атрибута.

# hasattr(Point, 'prop') - проверка существования того или иного свойства атрибута.


# Подвиг 1. Отметьте все верные, с точки зрения стандарта PEP8, имена классов.
# - DataBase
# - SergeyBalakirev
# - Data123

# Подвиг 2. Выберите утверждения справедливые для классов языка Python.
# - Каждый класс (объявленный в программе) можно воспринимать как новый (пользовательский) тип данных.
# - Класс описывает шаблон для формирования его объектов.
# - Класс образует пространство имен для переменных и методов, объявленных в нем.


# Подвиг 3. Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12

# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими
# значениями.

class DataBase:
    pk = 1
    title = 'Классы и объекты'
    author = 'Сергей Балакирев'
    views = 14356
    comments = 12


# Подвиг 4. Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
#
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:
#
# inflation: 100

class Goods:
    title = 'Мороженое'
    weight = 154
    tp = 'Еда'
    price = 1024
Goods.price = 2048
setattr(Goods, 'inflation', 100)


# Подвиг 5. Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"

# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.

class Car:
    pass
setattr(Car, 'model', 'Тойота')
setattr(Car, 'color', 'Розовый')
setattr(Car, 'number', 'П111УУ77')
print(Car.__dict__['color'])


# Подвиг 6. Объявите класс с именем Notes и определите в нем следующие атрибуты:
#
# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

class Notes:
    uid = 1005435
    title = 'Шутка'
    author = 'И.С. Бах'
    pages = 2
res = getattr(Notes, 'author')
print(res)


# Подвиг 7. Объявите класс с именем Dictionary и определите в нем следующие атрибуты:
#
# rus: "Питон"
# eng: "Python"

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в
# классе нет, то функция getattr() должна возвращать булево значение False.

class Dictionary:
    rus = "Питон"
    eng = "Python"

print(getattr(Dictionary, 'rus_word', False))


# Подвиг 8. Объявите класс с именем TravelBlog и объявите в нем атрибут:
#
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
#
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
#
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
#
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

class TravelBlog:
    total_blogs = 0


tb1 = TravelBlog()
tb1.name = 'Франция'
tb1.days = 6
TravelBlog.total_blogs += 1
tb2 = TravelBlog()
tb2.name = 'Италия'
tb2.days = 5
TravelBlog.total_blogs += 1


class TravelBlog:
    total_blogs = 0

    def __init__(self, name, days):
        self.name = name
        self.days = days
        TravelBlog.total_blogs += 1


tb1 = TravelBlog('Франция', 6)
tb2 = TravelBlog('Италия', 5)


# Подвиг 9. Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'

# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:

# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'

# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта
# fig1 в одну строчку через пробел в порядке, указанном в задании.

class Figure:
    type_fig = 'ellipse'
    color = 'red'

fig1 = Figure()
fig1.start_pt = (10, 5)
fig1.end_pt = (100, 20)
fig1.color = 'blue'
delattr(fig1, 'color')
print(*fig1.__dict__.keys())


# Подвиг 10. Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'

# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите
# True, если оно присутствует в объекте p1 и False - если отсутствует.

class Person:
    name = 'Сергей Балакирев'
    job = 'Программист'
    city = 'Москва'

p1 = Person()
print('job' in p1.__dict__)


# Подвиг 11. Выберите верное значение атрибута, которое будет выведено на экран при выполнении следующей программы:
#
# class Figures:
#     type = 'ellipse'
#     color = 'red'
#
#
# fig1 = Figures()
# print(fig1.color)

# - red


# Подвиг 12. Установите соответствия между функциями и их описаниями.

# setattr() - позволяет создавать новый атрибут или устанавливать значение уже существующего в классе или объекте
# getattr() - позволяет получать значение указанного атрибута из класса или объекта
# hasattr() - позволяет проверять атрибут на наличие в классе или объекте
# delattr() - позволяет удалять атрибут в классе или объекте


# Подвиг 13. Выберите верные способы удаления атрибута tp из класса Point.
# - delattr(Point, 'tp')
# - del Point.tp

# Подвиг 14. В программе объявлен следующий класс:
#
# class Magazine:
#     name = 'Наука и жизнь'
#     price = 1101
# Что произойдет при выполнении команды:
# print(getattr(Magazine, 'id'))


# - Ошибка, так как атрибут id отсутствует в классе Magazine

# ----------------------------------------------------------------------------------------------------------------------
# 1.4. Методы классов. Параметр self

# Подвиг 1. Что называется методом класса?
# - Любая (не статическая) функция, объявленная внутри класса


# Подвиг 2. Что называют атрибутами класса?
# - Переменные и имена методов (ссылки на методы) класса


# Подвиг 3. Какую роль играет параметр self в методах класса?
# - это ссылка на объект класса, из которого был вызван метод



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/AbMOpQSt1fA
# Подвиг 4. Объявите класс с именем MediaPlayer с двумя методами:
#
# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")
#
# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):
#
# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

class MediaPlayer:

    def open(self, file):
        self.filename = file

    def play(self):
        print(f'Воспроизведение {self.filename}')


media1 = MediaPlayer()
media2 = MediaPlayer()
media1.open('filemedia1')
media2.open('filemedia2')
media1.play()
media2.play()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/XNbphw3bYAI
# Подвиг 5. Объявите класс с именем Graph и методами:
#
# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)
#
# и атрибутом:
#
# LIMIT_Y = [0, 10]
#
# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на
# переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных
# пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).
#
# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:
#
# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]
#
# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором
# чисел, записанных через пробел. Например (вывод без кавычек):
#
# "10 0 2 5 7"

class Graph:
    LIMIT_Y = [0, 10]

    def set_data(self, data):
        self.data = data

    def draw(self):
        print(*filter(lambda x: self.LIMIT_Y[0] <= x <= self.LIMIT_Y[1], self.data))


graph_1 = Graph()
graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
graph_1.draw()



# Подвиг 6. Имеется следующий класс:
#
# class Stepik:
#     def next_task(self):
#         return "Следующее задание"
# И создается объект этого класса:
#
# my_st = Stepik()

# Выберите все верные варианты вызова метода next_task()
# - my_st.next_task()
# - Stepik.next_task(my_st)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/IxXtZXrnnDY
# Подвиг 7. Имеется следующий класс для считывания информации из входного потока:
#
# import sys
#
#
# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')
#
#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res

# Которым, затем, можно воспользоваться следующим образом:
#
# sr = StreamReader()
# data, result = sr.readlines()

# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:
#
# def create(self, fields, lst_values): ...
#
# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.
#
# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.
#
# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.
#
# Пример входной информации (Sample Input):
#
# 10
# Питон - основы мастерства
# 512


import sys


# здесь объявляется класс StreamData

class StreamData:
    def create(self, fields, lst_values):
        if len(fields) != len(lst_values):
            return False
        else:
            for x in list(zip(fields, lst_values)):
                setattr(self, str(x[0]), x[1])
            return True


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res


sr = StreamReader()
data, result = sr.readlines()


# Подвиг 8. В программе объявлен класс:
#
# class String:
#     is_empty = False
# А, затем, создаются два его экземпляра:
#
# s1 = String()
# s2 = String()
# После этого выполняется команда:
#
# s2.is_empty = True

# Выберите верные утверждения, связанные с этой программой.
# - Значение s1.is_empty будет по-прежнему False, а значение s2.is_empty примет новое значение True
# - Переменная a = s1.is_empty будет ссылаться на атрибут is_empty класса String
# - Переменная b = s2.is_empty будет ссылаться на локальный атрибут is_empty объекта s2
# - Последняя команда создаст локальное свойство is_empty со значением True в экземпляре s2



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ljahVEppmxM
# Подвиг 9. Из входного потока читаются строки данных с помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...
#
# То есть, каждая строка - это элемент списка lst_in.
#
# Необходимо в класс DataBase:
#
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:
#
# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам
# (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;
#
# Каждая запись в списке lst_data должна быть представлена словарем в формате:
#
# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}
#
# Например:
#
# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
#
# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в
# коллекции FIELDS.
#
# P. S. Ваша задача только добавить два метода в класс DataBase.
#
# Sample Input:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200


import sys

# программу не менять, только добавить два метода
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока


class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')

    # здесь добавлять методы
    def select(self, a, b):
        return self.lst_data[a: b + 1]

    def insert(self, data):
        for i in data:
            self.lst_data.append(dict(zip(self.FIELDS, i.split())))


db = DataBase()
db.insert(lst_in)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/butyKEUntK0
# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует,
# то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus
# уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских
# слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е.
# связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go.
# Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить


class Translator:
    res = {}

    def add(self, eng, rus):
        if eng in self.res.keys():
            if rus not in self.res[eng]:
                self.res[eng].append(rus)
        else:
            self.res[eng] = [rus]

    def remove(self, eng):
        del self.res[eng]

    def translate(self, eng):
        return self.res[eng]


tr = Translator()
tr.add("tree", "дерево")
tr.add("car", "машина")
tr.add("car", "автомобиль")
tr.add("leaf", "лист")
tr.add("river", "река")
tr.add("go", "идти")
tr.add("go", "ехать")
tr.add("go", "ходить")
tr.add("milk", "молоко")

tr.remove('car')
print(*tr.translate('go'))


# ----------------------------------------------------------------------------------------------------------------------
# 1.5 Инициализатор __init__ и финализатор __del__


#Подвиг 1. Какой магический метод вызывается автоматически для инициализации объекта класса?
# - __init__()


# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/nT_sMhJsw1E
# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте)
# money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.

class Money:
    def __init__(self, x = 0):
        self.money = x

my_money = Money(100)
your_money = Money(1000)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/DEyOq7Gpko4
# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный
# ргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение
# black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой
# новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points
# укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.


class Point:
    def __init__(self, x, y, color='black'):
        self.x = x
        self.y = y
        self.color = color


points = [Point(c, c) for c in range(1, 2000, 2)]

points[1].color = 'yellow'



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/bPH4It1_d0c
# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты
# каждого класса следующими командами:
#
# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные
# числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний
# левый) в виде кортежей (a, b) и (c, d) соответственно.
#
# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect,
# или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке
# elements.
#
# В списке elements обнулите координаты объектов только для класса Line.
#
# P.S. На экран в программе ничего выводить не нужно.


import random

class Line:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Rect:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Ellipse:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)


elements = []
while len(elements) != 217:
    a, b, c, d = [random.randint(0, 9) for _ in range(4)]
    elements.append(random.choice([Line(0, 0, 0, 0), Rect(a, b, c, d), Ellipse(a, b, c, d)]))



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Vr4c1LgE91o
# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:
#
# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.
#
# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:
#
# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.
#
# Проверку параметров a, b, c проводить именно в таком порядке.
#
# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:
#
# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод
# is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).
#
# Sample Input:
# 3 4 5

# Sample Output:
# 3


# здесь объявите класс TriangleChecker
class TriangleChecker:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def is_triangle(self):
        if not all(map(lambda x: type(x) in (int, float), [self.a, self.b, self.c])):
            return 1
        elif not all(map(lambda x: x > 0, [self.a, self.b, self.c])):
            return 1
        elif self.a >= self.b + self.c or self.b >= self.a + self.c or self.c >= self.a + self.b:
            return 2
        else:
            return 3


a, b, c = map(int, input().split())  # эту строчку не менять
# здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
tr = TriangleChecker(a, b, c)
print(tr.is_triangle())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/a3Har3Z_89Q
# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
# 8 11 10 -32 0 7 18

# Sample Output:
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто


class Graph:

    def __init__(self, data, is_show = True):
        self.data = data[:]
        self.is_show = is_show

    def set_data(self, data):
        self.data = data
        return data

    def show_table(self):
        if self.is_show == True:
            return f'{" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_graph(self):
        if self.is_show == True:
            return f'Графическое отображение данных: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_bar(self):
        if self.is_show == True:
            return f'Столбчатая диаграмма: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def set_show(self, fl_show):
        self.is_show = fl_show

data_graph = list(map(int, input().split()))
gr = Graph(data=data_graph)
print(gr.show_bar())
gr.set_show(fl_show=False)
print(gr.show_table())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZTCdEB_6h1I
# Подвиг 7. Объявите в программе следующие несколько классов:
#
# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.
#
# Обеспечить возможность создания объектов каждого класса командами:
#
# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory,
# максимум N - по числу слотов памяти на материнской плате (N = 4).
#
# Объекты классов должны иметь следующие локальные свойства:
#
# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число
# слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory
# (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).
#
# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской
# плате в виде следующего списка из четырех строк:
#
# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']
#
# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).
#
# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.


class CPU:

    def __init__(self, name, fr):
        self.name = name
        self.fr = fr


class Memory:

    def __init__(self, name, volume):
        self.name = name
        self.volume = volume


class MotherBoard:

    def __init__(self,  name, cpu,  *mems):
        self.name = name
        self.cpu = cpu
        self.total_mem_slots = 4
        self.mem_slots = mems[:self.total_mem_slots]

    def get_config(self):
        return [f'Материнская плата: {self.name}',
                f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
                f'Слотов памяти: {self.total_mem_slots}',
                'Память: ' + "; ".join(map(lambda x: f"{x.name} - {x.volume}", self.mem_slots))]

mb = MotherBoard('', CPU('INTEL', 2000), Memory('Kingston', 2000))




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HbtVara1GPI
# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:
#
# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки
# (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.
#
# В классе Cart объявить методы:
#
# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:
#
# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']
#
# Объявите в программе следующие классы для описания товаров:
#
# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.
#
# Объекты этих классов должны создаваться командой:
#
# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:
#
# name - наименование;
# price - цена.
#
# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука
# (Notebook) и одну кружку (Cup). Названия и цены придумайте сами.
#
# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.


class Cart:

    def __init__(self, goods=[]):
        self.goods = goods

    def add(self, gd):
        self.goods.append(gd)

    def remove(self, indx):
        self.goods.remove(self.goods[indx])

    def get_list(self):
        return [f'{i.name}: {i.price}' for i in self.goods]


class Table:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class TV:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Notebook:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Cup:

    def __init__(self, name, price):
        self.name = name
        self.price = price


cart = Cart()
tv1 = TV('Samsung', 11000)
table = Table('IKEA', 5000)
notebook = Notebook('Mac', 100000)
notebook2 = Notebook('HP', 50000)
cup = Cup('Best Mommy', 500)

cart.add(tv1)
cart.add(tv1)
cart.add(table)
cart.add(notebook)
cart.add(notebook2)
cart.add(cup)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/3WfWCBKRKIM
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 9. Вам необходимо реализовать односвязный список (не список языка Python, объекты в списке не хранить, а
# формировать связанную структуру, показанную на рисунке) из объектов класса ListObject:
#
#
#
# Для этого объявите в программе класс ListObject, объекты которого создаются командой:
#
# obj = ListObject(data)
# Каждый объект класса ListObject должен содержать локальные свойства:
#
# next_obj - ссылка на следующий присоединенный объект (если следующего объекта нет, то next_obj = None);
# data - данные объекта в виде строки.
#
# В самом классе ListObject должен быть объявлен метод:
#
# link(self, obj) - для присоединения объекта obj такого же класса к текущему объекту self (то есть, атрибут next_obj
# объекта self должен ссылаться на obj).
#
# Прочитайте список строк из входного потока командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Затем сформируйте односвязный список, в объектах которых (в атрибуте data) хранятся строки из списка lst_in (первая
# строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса ListObject должна ссылаться
# переменная head_obj.
#
# P.S. В программе что-либо выводить на экран не нужно.
#
# Sample Input:
# 1. Первые шаги в ООП
# 1.1 Как правильно проходить этот курс
# 1.2 Концепция ООП простыми словами
# 1.3 Классы и объекты. Атрибуты классов и объектов
# 1.4 Методы классов. Параметр self
# 1.5 Инициализатор init и финализатор del
# 1.6 Магический метод new. Пример паттерна Singleton
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)

# Sample Output:


import sys


# здесь объявляются все необходимые классы
class ListObject:

    def __init__(self, data):
        self.data = data
        self.next_obj = None

    def link(self, obj):
        self.next_obj = obj


# считывание списка из входного потока (эту строку не менять)
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять

# здесь создаются объекты классов и вызываются нужные методы
head_obj = ListObject(lst_in[0])
obj = head_obj
for i in range(1, len(lst_in)):
    obj_new = ListObject(lst_in[i])
    obj.link(obj_new)
    obj = obj_new



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/gmjwMakXk0c
# Большой подвиг 10. Объявите два класса:
#
# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.
#
# С помощью класса Cell предполагается создавать отдельные клетки командой:
#
# c1 = Cell(around_mines, mine)
# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева величина (True/False), означающая наличие
# мины в текущей клетке. При этом, в каждом объекте класса Cell должны создаваться локальные свойства:
#
# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).

# С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N x N:
#
# pole_game = GamePole(N, M)
# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все
# объекты хранятся в двумерном списке N x N элементов - локальном свойстве pole объекта класса GamePole.
#
# В классе GamePole должны быть также реализованы следующие методы:
#
# init() - инициализация поля с новой расстановкой M мин (случайным образом по игровому полю, разумеется каждая мина
# должна находиться в отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается
# символ #).
#
# При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной
# инициализации игрового поля.
#
# В классе GamePole могут быть и другие вспомогательные методы.
#
# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и числом мин M = 12.
#
# P.S. На экран в программе ничего выводить не нужно.


from random import randint

class Cell:
    def __init__(self, around_mines=0, mine=False):
        self.around_mines = around_mines
        self.mine = mine
        self.fl_open = False

class GamePole:
    def __init__(self, N, M):
        self._n = N
        self._m = M
        self.pole = [[Cell() for n in range(self._n)] for n in range(self._n)]
        self.init()

    def init(self):
        m = 0
        while m < self._m:
            i = randint(0, self._n - 1)
            j = randint(0, self._n - 1)
            if self.pole[i][j].mine:
                continue
            self.pole[i][j].mine = True
            m += 1

        indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
        for x in range(self._n):
            for y in range(self._n):
                if not self.pole[x][y].mine:
                    mines = sum((self.pole[x+i][y+j].mine for i, j in indx if 0 <= x+i < self._n and 0 <= y+j < self._n))
                    self.pole[x][y].around_mines = mines

    def show(self):
        for row in self.pole:
            print(*map(lambda x: '#' if not x.fl_open else x.around_mines if not x.mine else '*', row))


pole_game = GamePole(10, 12)
pole_game.show()



# ----------------------------------------------------------------------------------------------------------------------
# 1.6 Магический метод __new__. Пример паттерна Singleton
# ----------------------------------------------------------------------------------------------------------------------


# Подвиг 1. В какой момент вызывается магический метод __new__()?
# - непосредственно перед созданием объекта класса


# Подвиг 2. Что должен возвращать магический метод __new__() для успешного создания объектов класса?
# - адрес нового созданного объекта


# Подвиг 3. Конструктор класса (метод __new__) можно записать со следующей сигнатурой:
#
# def __new__(cls, *args, **kwargs): ...

# Какую роль здесь играет первый параметр cls?
# - ссылка на класс, для которого создается объект


# Подвиг 4. В каком порядке вызывается конструктор класса __new__() и инициализатор __init__() при создании объекта
# класса?
# - сначала всегда вызывается метод __new__(), затем метод __init__()


# Подвиг 5. При переопределении метода __new__() объект создается командой super().__new__(cls):
#
# def __new__(cls, *args, **kwargs):
#    return super().__new__(cls)

# Выберите верное утверждение для ее объяснения.
# - Идет обращение к базовому классу, из которого вызывается конструктор - метод __new__(cls) с аргументом cls - ссылки
# на текущий класс



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/7aVqWfrAdqw
# Подвиг 6. Объявите класс AbstractClass, объекты которого нельзя было бы создавать. При выполнении команды:
#
# obj = AbstractClass()
# переменная obj должна ссылаться на строку с содержимым:
#
# "Ошибка: нельзя создавать объекты абстрактного класса"
#
# P.S. В программе объявить только класс, выводить на экран ничего не нужно.

class AbstractClass:

    def __new__(cls, *args, **kwargs):
        return "Ошибка: нельзя создавать объекты абстрактного класса"



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/uE1uf7Qtbh4
#
# Подвиг 7. Объявите класс SingletonFive, с помощью которого можно было бы создавать объекты командой:
#
# a = SingletonFive(<наименование>)
# Здесь <наименование> - это данные, которые сохраняются в локальном свойстве name созданного объекта.
#
# Этот класс должен формировать только первые пять объектов. Остальные (шестой, седьмой и т.д.) должны быть ссылкой на
# последний (пятый) созданный объект.
#
# Создайте первые десять объектов класса SingletonFive с помощью следующего фрагмента программы:
#
# objs = [SingletonFive(str(n)) for n in range(10)]
# P.S. В программе на экран ничего выводить не нужно.


class SingletonFive:
    __instance = None
    __count = 0

    def __new__(cls, *args, **kwargs):
        if cls.__count < 5:
            cls.__instance = super().__new__(cls)
            cls.__count += 1

        return cls.__instance

    def __init__(self, name):
        self.name = name


obj = [SingletonFive(str(n)) for n in range(10)]



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/sX_uP7GVqkc
# Подвиг 8. В программе объявлена переменная TYPE_OS и два следующих класса:
#
# TYPE_OS = 1 # 1 - Windows; 2 - Linux
#
# class DialogWindows:
#     name_class = "DialogWindows"
#
#
# class DialogLinux:
#     name_class = "DialogLinux"
# Необходимо объявить третий класс с именем Dialog, который бы создавал объекты командой:
#
# dlg = Dialog(<название>)
# Здесь <название> - это строка, которая сохраняется в локальном свойстве name объекта dlg.
#
# Класс Dialog должен создавать объекты класса DialogWindows, если переменная TYPE_OS = 1 и объекты класса DialogLinux,
# если переменная TYPE_OS не равна 1. При этом, переменная TYPE_OS может меняться в последующих строчках программы.
# Имейте это в виду, при объявлении класса Dialog.
#
# P.S. В программе на экран ничего выводить не нужно. Только объявить класс Dialog


TYPE_OS = 1 # 1 - Windows; 2 - Linux

class DialogWindows:
    name_class = "DialogWindows"


class DialogLinux:
    name_class = "DialogLinux"


class Dialog:

    def __new__(cls, *args, **kwargs):
        obj = None
        if TYPE_OS == 1:
            obj = super().__new__(DialogWindows)
        else:
            obj = super().__new__(DialogLinux)

        obj.name = args[0]
        return obj



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/U4zwfmbEiCI
# Подвиг 9 (на повторение материала). Объявите класс Point для представления точек на плоскости. Создавать объекты
# этого класса предполагается командой:
#
# pt = Point(x, y)
# Здесь x, y - числовые координаты точки на плоскости (числа), то есть, в каждом объекте этого класса создаются
# локальные свойства x, y, которые хранят конкретные координаты точки.
#
# Необходимо в классе Point реализовать метод clone(self), который бы создавал новый объект класса Point как копию
# текущего объекта с локальными атрибутами x, y и соответствующими значениями.
#
# Создайте в программе объект pt класса Point и еще один объект pt_clone через вызов метода clone.
#
# P.S. В программе на экран ничего выводить не нужно.


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def clone(self):
        return Point(self.x, self.y)

pt = Point(1, 2)
pt_clone = pt.clone()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5aJVuJ5jGqk
# Подвиг 10 (на повторение материала). В программе предполагается реализовать парсер (обработчик) строки (string) в
# определенный выходной формат. Для этого объявлен следующий класс:
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#
#         return seq
#
# И предполагается его использовать следующим образом:
#
# ld = Loader()
# res = ld.parse_format("4, 5, -6.5", Factory())
# На выходе (в переменной res) ожидается получить список из набора вещественных чисел. Например, для заданной строки,
# должно получиться:
#
# [4.0, 5.0, -6.5]
#
# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя методами:
#
# build_sequence(self) - для создания начального пустого списка (метод должен возвращать пустой список);
# build_number(self, string) - для преобразования переданной в метод строки (string) в вещественное значение (метод
# должен возвращать полученное вещественное число).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


class Factory:

    def build_sequence(self):
        return []


    def build_number(self, string):
        return float(string)


class Loader:
    def parse_format(self, string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
ld = Loader()
s = input()
res = ld.parse_format(s, Factory())



# ----------------------------------------------------------------------------------------------------------------------
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)
# ----------------------------------------------------------------------------------------------------------------------

# Теория
class Test:
    x = 1
    y = 2

    def __init__(self):
        self.x = 3
        self.y = 4

    @staticmethod
    def static_method(x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    @classmethod
    def class_method(cls, x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y
        d = Test.x + Test.y
        return a, b, c, d

    def self_method(self, x, y):
        a = x + y
        b = self.x + self.y
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    def func_method(x, y):  # <-- ОШИБКА пихает в х ссылку на объект, ошибка при вызове
        a = x + y  # <-- ОШИБКА ^
        b = self.x + self.y  # <-- ОШИБКА ^
        c = cls.x + cls.y  # <-- ОШИБКА ^
        d = Test.x + Test.y
        return a, b, c, d

    def empty_method():  # <-- ОШИБКА не знает куда бы запихнуть ссылку на объект
        return 123




# Подвиг 1. В программе объявлен следующий класс с одним методом:
class Stepik:
    def get_certificate(self):
        return False

# И создается объект этого класса:

st = Stepik()
# Выберите все верные варианты вызова метода get_certificate:
# - Stepik.get_certificate(st)
# - st.get_certificate()


# Подвиг 2. В программе объявлен следующий класс с одним методом:
class Loader:
    @classmethod
    def json_parse(cls):
        return ""

# И создается объект этого класса:

ld = Loader()

# Выберите все верные варианты вызова метода json_parse:
# - Loader.json_parse()
# - ld.json_parse()
# - res = Loader.json_parse()
# - res = ld.json_parse()



# Подвиг 3. В программе объявлен следующий класс с одним методом:
class Math:
    @staticmethod
    def sqrt(x):
        return x ** 0.5

# И создается объект этого класса:

m = Math()

# Выберите все верные варианты вызова метода sqrt:
# - res = m.sqrt(2)
# - res = Math.sqrt(4)


# Подвиг 4. За что отвечает параметр cls в методах класса, объявленных следующим образом:
class Loader:
    @classmethod
    def json_parse(cls): ...

# - Ссылка на класс Loader


# Подвиг 5. В чем отличие между методами класса (объявленными через @classmethod) и статическими методами
# (объявленными через @staticmethod)?

# - методы класса предназначены для работы с атрибутами класса и переданными аргументами, а статические - только с
# переданными им аргументами


# Подвиг 6. В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной
# формат. Для этого объявлен следующий класс:

class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)

class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq

# И предполагается его использовать следующим образом:

res = Loader.parse_format("4, 5, -6", Factory)

# На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки,
# должно получиться:

[4, 5, -6]

# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:
#
# build_sequence() - для создания пустого списка (метод возвращает пустой список);
# build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное
# значение).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


# Здесь объявляется класс Factory
class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)


class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
res = Loader.parse_format("1, 2, 3, -5, 10", Factory)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/D02X5B6zLi8
# Подвиг 7. В программе объявлен следующий класс для работы с формами ввода логин/пароль:

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])

# Который предполагается использовать следующим образом:

# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()

# Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

# login = TextInput(name, size)
# psw = PasswordInput(name, size)

# В каждом объекте этих классов должны быть следующие локальные свойства:

# name - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");
# size - размер поля ввода (целое число, по умолчанию 10).

# Также классы TextInput и PasswordInput должны иметь метод:

# get_html(self) - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса
# PasswordInput):

# <p class='login'><имя поля>: <input type='text' size=<размер поля> />
# <p class='password'><имя поля>: <input type='text' size=<размер поля> />

# Например, для поля login:

# <p class='login'>Логин: <input type='text' size=10 />

# Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

# check_name(cls, name) - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по
# следующим критериям:

# - длина имени не менее 3 символов и не более 50;
# - в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

# Если проверка не проходит, то генерировать исключение командой:

# raise ValueError("некорректное поле name")
# Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

# CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
# CHARS_CORRECT = CHARS + CHARS.upper() + digits
# По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

# P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это
# нормально.

from string import ascii_lowercase, digits

# здесь объявляйте классы TextInput и PasswordInput
class TextInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size


    def get_html(self):
        return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class PasswordInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size

    def get_html(self):
        return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class FormLogin:
    def __init__(self, lgn, psw):
        self.login = lgn
        self.password = psw

    def render_template(self):
        return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])


# эти строчки не менять
login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
html = login.render_template()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/9766M0dS1qc
#
# Подвиг 8. Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь
# следующие методы:
#
# check_card_number(number) - проверяет строку с номером карты и возвращает булево значение True, если номер в верном
# формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).
# check_name(name) - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя
# записано верно и False - в противном случае.
#
# Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами.
# Например, SERGEI BALAKIREV.
#
# Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):

# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# Для проверки допустимых символов в классе должен быть прописан атрибут:

# CHARS_FOR_NAME = ascii_lowercase.upper() + digits
# Подумайте, как правильнее объявить методы check_card_number и check_name (декораторами @classmethod и @staticmethod).

# P.S. В программе только объявить класс. На экран ничего выводить не нужно.
from string import ascii_lowercase, digits
class CardCheck:
    CHARS_FOR_NAME = ascii_lowercase.upper() + digits

    @staticmethod
    def check_card_number(number):
        number_card_list = number.split('-')
        if len(number_card_list) != 4:
            return False
        for i in number_card_list:
            if len(i) == 4 and i.isdigit():
                continue
            else:
                return False
        return True

    @classmethod
    def check_name(cls, name):
        if name.count(' ') == 1:
            name = name.replace(' ', '')
            for i in name:
                if i in cls.CHARS_FOR_NAME:
                    continue
                else:
                    return False
        else:
            return False
        return True


# При помощи регулярок
import re


class CardCheck:
    @staticmethod
    def check_card_number(number):
        return bool(re.fullmatch(r"\d{4}(?:-\d{4}){3}", number))

    @staticmethod
    def check_name(name):
        return bool(re.fullmatch(r"[A-Z\d]+ [A-Z\d]+", name))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YkDq9p8n17A
#
# Подвиг 9. Объявите в программе класс Video с двумя методами:
#
# create(self, name) - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name
# объекта класса Video);
# play(self) - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео <name>").
#
# Объявите еще один класс с именем YouTube, в котором объявите два метода (с декоратором @classmethod):
#
# add_video(cls, video) - для добавления нового видео (метод помещает объект video класса Video в список);
# play(cls, video_indx) - для проигрывания видео из списка по указанному индексу (индексация с нуля).
#
# (здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):
#
# videos - для хранения добавленных объектов класса Video (изначально список пуст).
#
# Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать
# метод play() класса Video.
#
# Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.
#
# Создайте два объекта v1 и v2 класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП".
# После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью
# метода play класса YouTube) сначала первое, а затем, второе видео.
#
# Sample Input:
#
# Sample Output:
#
# воспроизведение видео Python
# воспроизведение видео Python ООП

class Video:
    name = None
    def create(self, name):
        self.name = name

    def play(self):
        print(f'воспроизведение видео {self.name}')


class YouTube:
    videos = []

    @classmethod
    def add_video(cls, video):
        cls.videos.append(video)

    @classmethod
    def play(cls, video_indx):
        cls.videos[video_indx].play()

v1 = Video()
v2 = Video()
v1.create('Python')
v2.create('Python ООП')
YouTube.add_video(v1)
YouTube.add_video(v2)
YouTube.play(0)
YouTube.play(1)




# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Y4Hvpg4FuKs
#
# Подвиг 10 (на повторение). Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом
# классе должны быть реализованы следующие методы:
#
# add_application(self, app) - добавление нового приложения app в магазин;
# remove_application(self, app) - удаление приложения app из магазина;
# block_application(self, app) - блокировка приложения app (устанавливает локальное свойство blocked объекта app в
# значение True);
# total_apps(self) - возвращает общее число приложений в магазине.
#
# Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):
#
# store = AppStore()
# app_youtube = Application("Youtube")
# store.add_application(app_youtube)
# store.remove_application(app_youtube)
# Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application
# должен содержать локальные свойства:
#
# name - наименование приложения (строка);
# blocked - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).
#
# Как хранить список приложений в объектах класса AppStore решите сами.
#
# P.S. В программе нужно только объявить классы с указанным функционалом.


class AppStore:

    def __init__(self):
        self.apps = []
    def add_application(self, app):
        self.apps.append(app)

    def remove_application(self, app):
        self.apps.remove(app)

    def block_application(self, app):
        app.blocked = True

    def total_apps(self):
        return len(self.apps)


class Application:
    def __init__(self, name, blocked=False):
        self.name = name
        self.blocked = blocked



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/38QoBSpQqnM
#
# Подвиг 11 (на повторение). Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:
#
# add_message(msg) - добавление нового сообщения в список сообщений;
# remove_message(msg) - удаление сообщения из списка;
# set_like(msg) - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет
# то он ставится, если уже есть, то убирается);
# show_last_message(число) - отображение последних сообщений;
# total_messages() - возвращает общее число сообщений.
#
# Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# Viber.remove_message(msg)
# Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных
# свойств:
#
# text - текст сообщения (строка);
# fl_like - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном
# случае, изначально False);
#
# P.S. Как хранить список сообщений, решите самостоятельно.

class Message:
    def __init__(self, text, fl_like=False):
        self.text = text
        self.fl_like = fl_like

class Viber:

    msgs = []

    @classmethod
    def add_message(cls, msg):
        cls.msgs.append(msg)

    @classmethod
    def remove_message(cls, msg):
        cls.msgs.remove(msg)

    @classmethod
    def set_like(cls, msg):
        if msg.fl_like:
            msg.fl_like = False
        else:
            msg.fl_like = True

    @classmethod
    def show_last_message(cls, amount):
        print(cls.msgs[-amount:])

    @classmethod
    def total_messages(cls):
        return len(cls.msgs)


