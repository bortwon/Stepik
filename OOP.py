# Добрый, добрый Python ООП - обучающий курс от Сергея Балакирева
# ======================================================================================================================
# 1. ПЕРВЫЕ ШАГИ В ООП.

# ----------------------------------------------------------------------------------------------------------------------
# 1.2 Концепция ООП простыми словами


# Подвиг 1. Что составляет основу ООП?
# - инкапсуляция
# - наследование
# - полиморфизм

# Подвиг 2. Как следует воспринимать класс в ООП?
# - как шаблон, по которому конструируются объекты этого класса

# Подвиг 3. В чем суть идеи наследования в ООП?
# - на основе одного или нескольких классов создается новый (дочерний) класс
# - наследование позволяет как бы вынести «за скобки» общее для разных классов

# Подвиг 4. Можно ли создавать программы без использования ООП?
# - да, например, используя парадигму структурного программирования (не включая ООП)

# Подвиг 5. Вам предстоит написать программу хранения информации по книгам: автор, заголовок, год издания, число
# страниц. Помогут ли здесь классы для представления этой разнородной информации?
# - да, описать каждую книгу как объект класса "Книга" хорошая идея

# Подвиг 6. Каким термином из ООП можно охарактеризовать ограничение доступа к элементам класса?
# - инкапсуляция

# Подвиг 7. Вам предстоит создать программу несложного графического редактора с рисованием различных графических
# примитивов (линия, прямоугольник, эллипс, треугольник и т.п.). Будет ли иметь смысл использовать при ее реализации
# концепцию ООП?
# - да, ООП здесь может заметно упростить программный код

# Подвиг 8. Каким термином из ООП можно охарактеризовать универсальность интерфейса доступа к разным типам данных?
# - полиморфизм


# ---------------------------------------------------------------------------------------------------------------------
# 1.3. Классы и объекты. Атрибуты классов и объектов

# setattr(Point, 'prop', 1) - функция создает новый атрибут в указанном пространстве имен(в данном случае в классе
# Point) с заданным значением.

# getattr(Point, 'a', False) - функция для обращения к тому или иному атрибуту класса, ей пользуются только в том
# случае, если есть опасность обращения к несуществующим атрибутам.

# delattr(Point, 'type_pt') - функция для удаления атрибута.

# hasattr(Point, 'prop') - проверка существования того или иного свойства атрибута.


# Подвиг 1. Отметьте все верные, с точки зрения стандарта PEP8, имена классов.
# - DataBase
# - SergeyBalakirev
# - Data123

# Подвиг 2. Выберите утверждения справедливые для классов языка Python.
# - Каждый класс (объявленный в программе) можно воспринимать как новый (пользовательский) тип данных.
# - Класс описывает шаблон для формирования его объектов.
# - Класс образует пространство имен для переменных и методов, объявленных в нем.


# Подвиг 3. Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12

# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими
# значениями.

class DataBase:
    pk = 1
    title = 'Классы и объекты'
    author = 'Сергей Балакирев'
    views = 14356
    comments = 12


# Подвиг 4. Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
#
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:
#
# inflation: 100

class Goods:
    title = 'Мороженое'
    weight = 154
    tp = 'Еда'
    price = 1024
Goods.price = 2048
setattr(Goods, 'inflation', 100)


# Подвиг 5. Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"

# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.

class Car:
    pass
setattr(Car, 'model', 'Тойота')
setattr(Car, 'color', 'Розовый')
setattr(Car, 'number', 'П111УУ77')
print(Car.__dict__['color'])


# Подвиг 6. Объявите класс с именем Notes и определите в нем следующие атрибуты:
#
# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

class Notes:
    uid = 1005435
    title = 'Шутка'
    author = 'И.С. Бах'
    pages = 2
res = getattr(Notes, 'author')
print(res)


# Подвиг 7. Объявите класс с именем Dictionary и определите в нем следующие атрибуты:
#
# rus: "Питон"
# eng: "Python"

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в
# классе нет, то функция getattr() должна возвращать булево значение False.

class Dictionary:
    rus = "Питон"
    eng = "Python"

print(getattr(Dictionary, 'rus_word', False))


# Подвиг 8. Объявите класс с именем TravelBlog и объявите в нем атрибут:
#
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
#
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
#
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
#
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

class TravelBlog:
    total_blogs = 0


tb1 = TravelBlog()
tb1.name = 'Франция'
tb1.days = 6
TravelBlog.total_blogs += 1
tb2 = TravelBlog()
tb2.name = 'Италия'
tb2.days = 5
TravelBlog.total_blogs += 1


class TravelBlog:
    total_blogs = 0

    def __init__(self, name, days):
        self.name = name
        self.days = days
        TravelBlog.total_blogs += 1


tb1 = TravelBlog('Франция', 6)
tb2 = TravelBlog('Италия', 5)


# Подвиг 9. Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'

# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:

# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'

# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта
# fig1 в одну строчку через пробел в порядке, указанном в задании.

class Figure:
    type_fig = 'ellipse'
    color = 'red'

fig1 = Figure()
fig1.start_pt = (10, 5)
fig1.end_pt = (100, 20)
fig1.color = 'blue'
delattr(fig1, 'color')
print(*fig1.__dict__.keys())


# Подвиг 10. Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'

# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите
# True, если оно присутствует в объекте p1 и False - если отсутствует.

class Person:
    name = 'Сергей Балакирев'
    job = 'Программист'
    city = 'Москва'

p1 = Person()
print('job' in p1.__dict__)


# Подвиг 11. Выберите верное значение атрибута, которое будет выведено на экран при выполнении следующей программы:
#
# class Figures:
#     type = 'ellipse'
#     color = 'red'
#
#
# fig1 = Figures()
# print(fig1.color)

# - red


# Подвиг 12. Установите соответствия между функциями и их описаниями.

# setattr() - позволяет создавать новый атрибут или устанавливать значение уже существующего в классе или объекте
# getattr() - позволяет получать значение указанного атрибута из класса или объекта
# hasattr() - позволяет проверять атрибут на наличие в классе или объекте
# delattr() - позволяет удалять атрибут в классе или объекте


# Подвиг 13. Выберите верные способы удаления атрибута tp из класса Point.
# - delattr(Point, 'tp')
# - del Point.tp

# Подвиг 14. В программе объявлен следующий класс:
#
# class Magazine:
#     name = 'Наука и жизнь'
#     price = 1101
# Что произойдет при выполнении команды:
# print(getattr(Magazine, 'id'))


# - Ошибка, так как атрибут id отсутствует в классе Magazine

# ----------------------------------------------------------------------------------------------------------------------
# 1.4. Методы классов. Параметр self

# Подвиг 1. Что называется методом класса?
# - Любая (не статическая) функция, объявленная внутри класса


# Подвиг 2. Что называют атрибутами класса?
# - Переменные и имена методов (ссылки на методы) класса


# Подвиг 3. Какую роль играет параметр self в методах класса?
# - это ссылка на объект класса, из которого был вызван метод



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/AbMOpQSt1fA
# Подвиг 4. Объявите класс с именем MediaPlayer с двумя методами:
#
# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")
#
# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):
#
# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

class MediaPlayer:

    def open(self, file):
        self.filename = file

    def play(self):
        print(f'Воспроизведение {self.filename}')


media1 = MediaPlayer()
media2 = MediaPlayer()
media1.open('filemedia1')
media2.open('filemedia2')
media1.play()
media2.play()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/XNbphw3bYAI
# Подвиг 5. Объявите класс с именем Graph и методами:
#
# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)
#
# и атрибутом:
#
# LIMIT_Y = [0, 10]
#
# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на
# переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных
# пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).
#
# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:
#
# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]
#
# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором
# чисел, записанных через пробел. Например (вывод без кавычек):
#
# "10 0 2 5 7"

class Graph:
    LIMIT_Y = [0, 10]

    def set_data(self, data):
        self.data = data

    def draw(self):
        print(*filter(lambda x: self.LIMIT_Y[0] <= x <= self.LIMIT_Y[1], self.data))


graph_1 = Graph()
graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
graph_1.draw()



# Подвиг 6. Имеется следующий класс:
#
# class Stepik:
#     def next_task(self):
#         return "Следующее задание"
# И создается объект этого класса:
#
# my_st = Stepik()

# Выберите все верные варианты вызова метода next_task()
# - my_st.next_task()
# - Stepik.next_task(my_st)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/IxXtZXrnnDY
# Подвиг 7. Имеется следующий класс для считывания информации из входного потока:
#
# import sys
#
#
# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')
#
#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res

# Которым, затем, можно воспользоваться следующим образом:
#
# sr = StreamReader()
# data, result = sr.readlines()

# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:
#
# def create(self, fields, lst_values): ...
#
# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.
#
# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.
#
# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.
#
# Пример входной информации (Sample Input):
#
# 10
# Питон - основы мастерства
# 512


import sys


# здесь объявляется класс StreamData

class StreamData:
    def create(self, fields, lst_values):
        if len(fields) != len(lst_values):
            return False
        else:
            for x in list(zip(fields, lst_values)):
                setattr(self, str(x[0]), x[1])
            return True


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res


sr = StreamReader()
data, result = sr.readlines()


# Подвиг 8. В программе объявлен класс:
#
# class String:
#     is_empty = False
# А, затем, создаются два его экземпляра:
#
# s1 = String()
# s2 = String()
# После этого выполняется команда:
#
# s2.is_empty = True

# Выберите верные утверждения, связанные с этой программой.
# - Значение s1.is_empty будет по-прежнему False, а значение s2.is_empty примет новое значение True
# - Переменная a = s1.is_empty будет ссылаться на атрибут is_empty класса String
# - Переменная b = s2.is_empty будет ссылаться на локальный атрибут is_empty объекта s2
# - Последняя команда создаст локальное свойство is_empty со значением True в экземпляре s2



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ljahVEppmxM
# Подвиг 9. Из входного потока читаются строки данных с помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...
#
# То есть, каждая строка - это элемент списка lst_in.
#
# Необходимо в класс DataBase:
#
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:
#
# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам
# (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;
#
# Каждая запись в списке lst_data должна быть представлена словарем в формате:
#
# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}
#
# Например:
#
# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
#
# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в
# коллекции FIELDS.
#
# P. S. Ваша задача только добавить два метода в класс DataBase.
#
# Sample Input:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200


import sys

# программу не менять, только добавить два метода
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока


class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')

    # здесь добавлять методы
    def select(self, a, b):
        return self.lst_data[a: b + 1]

    def insert(self, data):
        for i in data:
            self.lst_data.append(dict(zip(self.FIELDS, i.split())))


db = DataBase()
db.insert(lst_in)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/butyKEUntK0
# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует,
# то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus
# уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских
# слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е.
# связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go.
# Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить


class Translator:
    res = {}

    def add(self, eng, rus):
        if eng in self.res.keys():
            if rus not in self.res[eng]:
                self.res[eng].append(rus)
        else:
            self.res[eng] = [rus]

    def remove(self, eng):
        del self.res[eng]

    def translate(self, eng):
        return self.res[eng]


tr = Translator()
tr.add("tree", "дерево")
tr.add("car", "машина")
tr.add("car", "автомобиль")
tr.add("leaf", "лист")
tr.add("river", "река")
tr.add("go", "идти")
tr.add("go", "ехать")
tr.add("go", "ходить")
tr.add("milk", "молоко")

tr.remove('car')
print(*tr.translate('go'))


# ----------------------------------------------------------------------------------------------------------------------
# 1.5 Инициализатор __init__ и финализатор __del__


#Подвиг 1. Какой магический метод вызывается автоматически для инициализации объекта класса?
# - __init__()


# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/nT_sMhJsw1E
# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте)
# money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.

class Money:
    def __init__(self, x = 0):
        self.money = x

my_money = Money(100)
your_money = Money(1000)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/DEyOq7Gpko4
# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный
# ргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение
# black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой
# новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points
# укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.


class Point:
    def __init__(self, x, y, color='black'):
        self.x = x
        self.y = y
        self.color = color


points = [Point(c, c) for c in range(1, 2000, 2)]

points[1].color = 'yellow'



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/bPH4It1_d0c
# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты
# каждого класса следующими командами:
#
# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные
# числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний
# левый) в виде кортежей (a, b) и (c, d) соответственно.
#
# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect,
# или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке
# elements.
#
# В списке elements обнулите координаты объектов только для класса Line.
#
# P.S. На экран в программе ничего выводить не нужно.


import random

class Line:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Rect:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Ellipse:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)


elements = []
while len(elements) != 217:
    a, b, c, d = [random.randint(0, 9) for _ in range(4)]
    elements.append(random.choice([Line(0, 0, 0, 0), Rect(a, b, c, d), Ellipse(a, b, c, d)]))



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Vr4c1LgE91o
# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:
#
# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.
#
# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:
#
# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.
#
# Проверку параметров a, b, c проводить именно в таком порядке.
#
# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:
#
# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод
# is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).
#
# Sample Input:
# 3 4 5

# Sample Output:
# 3


# здесь объявите класс TriangleChecker
class TriangleChecker:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def is_triangle(self):
        if not all(map(lambda x: type(x) in (int, float), [self.a, self.b, self.c])):
            return 1
        elif not all(map(lambda x: x > 0, [self.a, self.b, self.c])):
            return 1
        elif self.a >= self.b + self.c or self.b >= self.a + self.c or self.c >= self.a + self.b:
            return 2
        else:
            return 3


a, b, c = map(int, input().split())  # эту строчку не менять
# здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
tr = TriangleChecker(a, b, c)
print(tr.is_triangle())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/a3Har3Z_89Q
# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
# 8 11 10 -32 0 7 18

# Sample Output:
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто


class Graph:

    def __init__(self, data, is_show = True):
        self.data = data[:]
        self.is_show = is_show

    def set_data(self, data):
        self.data = data
        return data

    def show_table(self):
        if self.is_show == True:
            return f'{" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_graph(self):
        if self.is_show == True:
            return f'Графическое отображение данных: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_bar(self):
        if self.is_show == True:
            return f'Столбчатая диаграмма: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def set_show(self, fl_show):
        self.is_show = fl_show

data_graph = list(map(int, input().split()))
gr = Graph(data=data_graph)
print(gr.show_bar())
gr.set_show(fl_show=False)
print(gr.show_table())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZTCdEB_6h1I
# Подвиг 7. Объявите в программе следующие несколько классов:
#
# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.
#
# Обеспечить возможность создания объектов каждого класса командами:
#
# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory,
# максимум N - по числу слотов памяти на материнской плате (N = 4).
#
# Объекты классов должны иметь следующие локальные свойства:
#
# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число
# слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory
# (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).
#
# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской
# плате в виде следующего списка из четырех строк:
#
# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']
#
# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).
#
# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.


class CPU:

    def __init__(self, name, fr):
        self.name = name
        self.fr = fr


class Memory:

    def __init__(self, name, volume):
        self.name = name
        self.volume = volume


class MotherBoard:

    def __init__(self,  name, cpu,  *mems):
        self.name = name
        self.cpu = cpu
        self.total_mem_slots = 4
        self.mem_slots = mems[:self.total_mem_slots]

    def get_config(self):
        return [f'Материнская плата: {self.name}',
                f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
                f'Слотов памяти: {self.total_mem_slots}',
                'Память: ' + "; ".join(map(lambda x: f"{x.name} - {x.volume}", self.mem_slots))]

mb = MotherBoard('', CPU('INTEL', 2000), Memory('Kingston', 2000))




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HbtVara1GPI
# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:
#
# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки
# (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.
#
# В классе Cart объявить методы:
#
# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:
#
# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']
#
# Объявите в программе следующие классы для описания товаров:
#
# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.
#
# Объекты этих классов должны создаваться командой:
#
# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:
#
# name - наименование;
# price - цена.
#
# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука
# (Notebook) и одну кружку (Cup). Названия и цены придумайте сами.
#
# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.


class Cart:

    def __init__(self, goods=[]):
        self.goods = goods

    def add(self, gd):
        self.goods.append(gd)

    def remove(self, indx):
        self.goods.remove(self.goods[indx])

    def get_list(self):
        return [f'{i.name}: {i.price}' for i in self.goods]


class Table:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class TV:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Notebook:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Cup:

    def __init__(self, name, price):
        self.name = name
        self.price = price


cart = Cart()
tv1 = TV('Samsung', 11000)
table = Table('IKEA', 5000)
notebook = Notebook('Mac', 100000)
notebook2 = Notebook('HP', 50000)
cup = Cup('Best Mommy', 500)

cart.add(tv1)
cart.add(tv1)
cart.add(table)
cart.add(notebook)
cart.add(notebook2)
cart.add(cup)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/3WfWCBKRKIM
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 9. Вам необходимо реализовать односвязный список (не список языка Python, объекты в списке не хранить, а
# формировать связанную структуру, показанную на рисунке) из объектов класса ListObject:
#
#
#
# Для этого объявите в программе класс ListObject, объекты которого создаются командой:
#
# obj = ListObject(data)
# Каждый объект класса ListObject должен содержать локальные свойства:
#
# next_obj - ссылка на следующий присоединенный объект (если следующего объекта нет, то next_obj = None);
# data - данные объекта в виде строки.
#
# В самом классе ListObject должен быть объявлен метод:
#
# link(self, obj) - для присоединения объекта obj такого же класса к текущему объекту self (то есть, атрибут next_obj
# объекта self должен ссылаться на obj).
#
# Прочитайте список строк из входного потока командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Затем сформируйте односвязный список, в объектах которых (в атрибуте data) хранятся строки из списка lst_in (первая
# строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса ListObject должна ссылаться
# переменная head_obj.
#
# P.S. В программе что-либо выводить на экран не нужно.
#
# Sample Input:
# 1. Первые шаги в ООП
# 1.1 Как правильно проходить этот курс
# 1.2 Концепция ООП простыми словами
# 1.3 Классы и объекты. Атрибуты классов и объектов
# 1.4 Методы классов. Параметр self
# 1.5 Инициализатор init и финализатор del
# 1.6 Магический метод new. Пример паттерна Singleton
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)

# Sample Output:


import sys


# здесь объявляются все необходимые классы
class ListObject:

    def __init__(self, data):
        self.data = data
        self.next_obj = None

    def link(self, obj):
        self.next_obj = obj


# считывание списка из входного потока (эту строку не менять)
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять

# здесь создаются объекты классов и вызываются нужные методы
head_obj = ListObject(lst_in[0])
obj = head_obj
for i in range(1, len(lst_in)):
    obj_new = ListObject(lst_in[i])
    obj.link(obj_new)
    obj = obj_new



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/gmjwMakXk0c
# Большой подвиг 10. Объявите два класса:
#
# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.
#
# С помощью класса Cell предполагается создавать отдельные клетки командой:
#
# c1 = Cell(around_mines, mine)
# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева величина (True/False), означающая наличие
# мины в текущей клетке. При этом, в каждом объекте класса Cell должны создаваться локальные свойства:
#
# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).

# С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N x N:
#
# pole_game = GamePole(N, M)
# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все
# объекты хранятся в двумерном списке N x N элементов - локальном свойстве pole объекта класса GamePole.
#
# В классе GamePole должны быть также реализованы следующие методы:
#
# init() - инициализация поля с новой расстановкой M мин (случайным образом по игровому полю, разумеется каждая мина
# должна находиться в отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается
# символ #).
#
# При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной
# инициализации игрового поля.
#
# В классе GamePole могут быть и другие вспомогательные методы.
#
# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и числом мин M = 12.
#
# P.S. На экран в программе ничего выводить не нужно.


from random import randint

class Cell:
    def __init__(self, around_mines=0, mine=False):
        self.around_mines = around_mines
        self.mine = mine
        self.fl_open = False

class GamePole:
    def __init__(self, N, M):
        self._n = N
        self._m = M
        self.pole = [[Cell() for n in range(self._n)] for n in range(self._n)]
        self.init()

    def init(self):
        m = 0
        while m < self._m:
            i = randint(0, self._n - 1)
            j = randint(0, self._n - 1)
            if self.pole[i][j].mine:
                continue
            self.pole[i][j].mine = True
            m += 1

        indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
        for x in range(self._n):
            for y in range(self._n):
                if not self.pole[x][y].mine:
                    mines = sum((self.pole[x+i][y+j].mine for i, j in indx if 0 <= x+i < self._n and 0 <= y+j < self._n))
                    self.pole[x][y].around_mines = mines

    def show(self):
        for row in self.pole:
            print(*map(lambda x: '#' if not x.fl_open else x.around_mines if not x.mine else '*', row))


pole_game = GamePole(10, 12)
pole_game.show()



# ----------------------------------------------------------------------------------------------------------------------
# 1.6 Магический метод __new__. Пример паттерна Singleton
# ----------------------------------------------------------------------------------------------------------------------


# Подвиг 1. В какой момент вызывается магический метод __new__()?
# - непосредственно перед созданием объекта класса


# Подвиг 2. Что должен возвращать магический метод __new__() для успешного создания объектов класса?
# - адрес нового созданного объекта


# Подвиг 3. Конструктор класса (метод __new__) можно записать со следующей сигнатурой:
#
# def __new__(cls, *args, **kwargs): ...

# Какую роль здесь играет первый параметр cls?
# - ссылка на класс, для которого создается объект


# Подвиг 4. В каком порядке вызывается конструктор класса __new__() и инициализатор __init__() при создании объекта
# класса?
# - сначала всегда вызывается метод __new__(), затем метод __init__()


# Подвиг 5. При переопределении метода __new__() объект создается командой super().__new__(cls):
#
# def __new__(cls, *args, **kwargs):
#    return super().__new__(cls)

# Выберите верное утверждение для ее объяснения.
# - Идет обращение к базовому классу, из которого вызывается конструктор - метод __new__(cls) с аргументом cls - ссылки
# на текущий класс



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/7aVqWfrAdqw
# Подвиг 6. Объявите класс AbstractClass, объекты которого нельзя было бы создавать. При выполнении команды:
#
# obj = AbstractClass()
# переменная obj должна ссылаться на строку с содержимым:
#
# "Ошибка: нельзя создавать объекты абстрактного класса"
#
# P.S. В программе объявить только класс, выводить на экран ничего не нужно.

class AbstractClass:

    def __new__(cls, *args, **kwargs):
        return "Ошибка: нельзя создавать объекты абстрактного класса"



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/uE1uf7Qtbh4
#
# Подвиг 7. Объявите класс SingletonFive, с помощью которого можно было бы создавать объекты командой:
#
# a = SingletonFive(<наименование>)
# Здесь <наименование> - это данные, которые сохраняются в локальном свойстве name созданного объекта.
#
# Этот класс должен формировать только первые пять объектов. Остальные (шестой, седьмой и т.д.) должны быть ссылкой на
# последний (пятый) созданный объект.
#
# Создайте первые десять объектов класса SingletonFive с помощью следующего фрагмента программы:
#
# objs = [SingletonFive(str(n)) for n in range(10)]
# P.S. В программе на экран ничего выводить не нужно.


class SingletonFive:
    __instance = None
    __count = 0

    def __new__(cls, *args, **kwargs):
        if cls.__count < 5:
            cls.__instance = super().__new__(cls)
            cls.__count += 1

        return cls.__instance

    def __init__(self, name):
        self.name = name


obj = [SingletonFive(str(n)) for n in range(10)]



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/sX_uP7GVqkc
# Подвиг 8. В программе объявлена переменная TYPE_OS и два следующих класса:
#
# TYPE_OS = 1 # 1 - Windows; 2 - Linux
#
# class DialogWindows:
#     name_class = "DialogWindows"
#
#
# class DialogLinux:
#     name_class = "DialogLinux"
# Необходимо объявить третий класс с именем Dialog, который бы создавал объекты командой:
#
# dlg = Dialog(<название>)
# Здесь <название> - это строка, которая сохраняется в локальном свойстве name объекта dlg.
#
# Класс Dialog должен создавать объекты класса DialogWindows, если переменная TYPE_OS = 1 и объекты класса DialogLinux,
# если переменная TYPE_OS не равна 1. При этом, переменная TYPE_OS может меняться в последующих строчках программы.
# Имейте это в виду, при объявлении класса Dialog.
#
# P.S. В программе на экран ничего выводить не нужно. Только объявить класс Dialog


TYPE_OS = 1 # 1 - Windows; 2 - Linux

class DialogWindows:
    name_class = "DialogWindows"


class DialogLinux:
    name_class = "DialogLinux"


class Dialog:

    def __new__(cls, *args, **kwargs):
        obj = None
        if TYPE_OS == 1:
            obj = super().__new__(DialogWindows)
        else:
            obj = super().__new__(DialogLinux)

        obj.name = args[0]
        return obj



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/U4zwfmbEiCI
# Подвиг 9 (на повторение материала). Объявите класс Point для представления точек на плоскости. Создавать объекты
# этого класса предполагается командой:
#
# pt = Point(x, y)
# Здесь x, y - числовые координаты точки на плоскости (числа), то есть, в каждом объекте этого класса создаются
# локальные свойства x, y, которые хранят конкретные координаты точки.
#
# Необходимо в классе Point реализовать метод clone(self), который бы создавал новый объект класса Point как копию
# текущего объекта с локальными атрибутами x, y и соответствующими значениями.
#
# Создайте в программе объект pt класса Point и еще один объект pt_clone через вызов метода clone.
#
# P.S. В программе на экран ничего выводить не нужно.


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def clone(self):
        return Point(self.x, self.y)

pt = Point(1, 2)
pt_clone = pt.clone()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5aJVuJ5jGqk
# Подвиг 10 (на повторение материала). В программе предполагается реализовать парсер (обработчик) строки (string) в
# определенный выходной формат. Для этого объявлен следующий класс:
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#
#         return seq
#
# И предполагается его использовать следующим образом:
#
# ld = Loader()
# res = ld.parse_format("4, 5, -6.5", Factory())
# На выходе (в переменной res) ожидается получить список из набора вещественных чисел. Например, для заданной строки,
# должно получиться:
#
# [4.0, 5.0, -6.5]
#
# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя методами:
#
# build_sequence(self) - для создания начального пустого списка (метод должен возвращать пустой список);
# build_number(self, string) - для преобразования переданной в метод строки (string) в вещественное значение (метод
# должен возвращать полученное вещественное число).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


class Factory:

    def build_sequence(self):
        return []


    def build_number(self, string):
        return float(string)


class Loader:
    def parse_format(self, string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
ld = Loader()
s = input()
res = ld.parse_format(s, Factory())



# ----------------------------------------------------------------------------------------------------------------------
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)
# ----------------------------------------------------------------------------------------------------------------------

# Теория
class Test:
    x = 1
    y = 2

    def __init__(self):
        self.x = 3
        self.y = 4

    @staticmethod
    def static_method(x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    @classmethod
    def class_method(cls, x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y
        d = Test.x + Test.y
        return a, b, c, d

    def self_method(self, x, y):
        a = x + y
        b = self.x + self.y
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    def func_method(x, y):  # <-- ОШИБКА пихает в х ссылку на объект, ошибка при вызове
        a = x + y  # <-- ОШИБКА ^
        b = self.x + self.y  # <-- ОШИБКА ^
        c = cls.x + cls.y  # <-- ОШИБКА ^
        d = Test.x + Test.y
        return a, b, c, d

    def empty_method():  # <-- ОШИБКА не знает куда бы запихнуть ссылку на объект
        return 123




# Подвиг 1. В программе объявлен следующий класс с одним методом:
class Stepik:
    def get_certificate(self):
        return False

# И создается объект этого класса:

st = Stepik()
# Выберите все верные варианты вызова метода get_certificate:
# - Stepik.get_certificate(st)
# - st.get_certificate()


# Подвиг 2. В программе объявлен следующий класс с одним методом:
class Loader:
    @classmethod
    def json_parse(cls):
        return ""

# И создается объект этого класса:

ld = Loader()

# Выберите все верные варианты вызова метода json_parse:
# - Loader.json_parse()
# - ld.json_parse()
# - res = Loader.json_parse()
# - res = ld.json_parse()



# Подвиг 3. В программе объявлен следующий класс с одним методом:
class Math:
    @staticmethod
    def sqrt(x):
        return x ** 0.5

# И создается объект этого класса:

m = Math()

# Выберите все верные варианты вызова метода sqrt:
# - res = m.sqrt(2)
# - res = Math.sqrt(4)


# Подвиг 4. За что отвечает параметр cls в методах класса, объявленных следующим образом:
class Loader:
    @classmethod
    def json_parse(cls): ...

# - Ссылка на класс Loader


# Подвиг 5. В чем отличие между методами класса (объявленными через @classmethod) и статическими методами
# (объявленными через @staticmethod)?

# - методы класса предназначены для работы с атрибутами класса и переданными аргументами, а статические - только с
# переданными им аргументами


# Подвиг 6. В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной
# формат. Для этого объявлен следующий класс:

class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)

class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq

# И предполагается его использовать следующим образом:

res = Loader.parse_format("4, 5, -6", Factory)

# На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки,
# должно получиться:

[4, 5, -6]

# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:
#
# build_sequence() - для создания пустого списка (метод возвращает пустой список);
# build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное
# значение).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


# Здесь объявляется класс Factory
class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)


class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
res = Loader.parse_format("1, 2, 3, -5, 10", Factory)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/D02X5B6zLi8
# Подвиг 7. В программе объявлен следующий класс для работы с формами ввода логин/пароль:

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])

# Который предполагается использовать следующим образом:

# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()

# Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

# login = TextInput(name, size)
# psw = PasswordInput(name, size)

# В каждом объекте этих классов должны быть следующие локальные свойства:

# name - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");
# size - размер поля ввода (целое число, по умолчанию 10).

# Также классы TextInput и PasswordInput должны иметь метод:

# get_html(self) - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса
# PasswordInput):

# <p class='login'><имя поля>: <input type='text' size=<размер поля> />
# <p class='password'><имя поля>: <input type='text' size=<размер поля> />

# Например, для поля login:

# <p class='login'>Логин: <input type='text' size=10 />

# Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

# check_name(cls, name) - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по
# следующим критериям:

# - длина имени не менее 3 символов и не более 50;
# - в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

# Если проверка не проходит, то генерировать исключение командой:

# raise ValueError("некорректное поле name")
# Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

# CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
# CHARS_CORRECT = CHARS + CHARS.upper() + digits
# По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

# P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это
# нормально.

from string import ascii_lowercase, digits

# здесь объявляйте классы TextInput и PasswordInput
class TextInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size


    def get_html(self):
        return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class PasswordInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size

    def get_html(self):
        return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class FormLogin:
    def __init__(self, lgn, psw):
        self.login = lgn
        self.password = psw

    def render_template(self):
        return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])


# эти строчки не менять
login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
html = login.render_template()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/9766M0dS1qc
#
# Подвиг 8. Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь
# следующие методы:
#
# check_card_number(number) - проверяет строку с номером карты и возвращает булево значение True, если номер в верном
# формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).
# check_name(name) - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя
# записано верно и False - в противном случае.
#
# Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами.
# Например, SERGEI BALAKIREV.
#
# Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):

# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# Для проверки допустимых символов в классе должен быть прописан атрибут:

# CHARS_FOR_NAME = ascii_lowercase.upper() + digits
# Подумайте, как правильнее объявить методы check_card_number и check_name (декораторами @classmethod и @staticmethod).

# P.S. В программе только объявить класс. На экран ничего выводить не нужно.
from string import ascii_lowercase, digits
class CardCheck:
    CHARS_FOR_NAME = ascii_lowercase.upper() + digits

    @staticmethod
    def check_card_number(number):
        number_card_list = number.split('-')
        if len(number_card_list) != 4:
            return False
        for i in number_card_list:
            if len(i) == 4 and i.isdigit():
                continue
            else:
                return False
        return True

    @classmethod
    def check_name(cls, name):
        if name.count(' ') == 1:
            name = name.replace(' ', '')
            for i in name:
                if i in cls.CHARS_FOR_NAME:
                    continue
                else:
                    return False
        else:
            return False
        return True


# При помощи регулярок
import re


class CardCheck:
    @staticmethod
    def check_card_number(number):
        return bool(re.fullmatch(r"\d{4}(?:-\d{4}){3}", number))

    @staticmethod
    def check_name(name):
        return bool(re.fullmatch(r"[A-Z\d]+ [A-Z\d]+", name))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YkDq9p8n17A
#
# Подвиг 9. Объявите в программе класс Video с двумя методами:
#
# create(self, name) - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name
# объекта класса Video);
# play(self) - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео <name>").
#
# Объявите еще один класс с именем YouTube, в котором объявите два метода (с декоратором @classmethod):
#
# add_video(cls, video) - для добавления нового видео (метод помещает объект video класса Video в список);
# play(cls, video_indx) - для проигрывания видео из списка по указанному индексу (индексация с нуля).
#
# (здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):
#
# videos - для хранения добавленных объектов класса Video (изначально список пуст).
#
# Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать
# метод play() класса Video.
#
# Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.
#
# Создайте два объекта v1 и v2 класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП".
# После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью
# метода play класса YouTube) сначала первое, а затем, второе видео.
#
# Sample Input:
#
# Sample Output:
#
# воспроизведение видео Python
# воспроизведение видео Python ООП

class Video:
    name = None
    def create(self, name):
        self.name = name

    def play(self):
        print(f'воспроизведение видео {self.name}')


class YouTube:
    videos = []

    @classmethod
    def add_video(cls, video):
        cls.videos.append(video)

    @classmethod
    def play(cls, video_indx):
        cls.videos[video_indx].play()

v1 = Video()
v2 = Video()
v1.create('Python')
v2.create('Python ООП')
YouTube.add_video(v1)
YouTube.add_video(v2)
YouTube.play(0)
YouTube.play(1)




# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Y4Hvpg4FuKs
#
# Подвиг 10 (на повторение). Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом
# классе должны быть реализованы следующие методы:
#
# add_application(self, app) - добавление нового приложения app в магазин;
# remove_application(self, app) - удаление приложения app из магазина;
# block_application(self, app) - блокировка приложения app (устанавливает локальное свойство blocked объекта app в
# значение True);
# total_apps(self) - возвращает общее число приложений в магазине.
#
# Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):
#
# store = AppStore()
# app_youtube = Application("Youtube")
# store.add_application(app_youtube)
# store.remove_application(app_youtube)
# Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application
# должен содержать локальные свойства:
#
# name - наименование приложения (строка);
# blocked - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).
#
# Как хранить список приложений в объектах класса AppStore решите сами.
#
# P.S. В программе нужно только объявить классы с указанным функционалом.


class AppStore:

    def __init__(self):
        self.apps = []
    def add_application(self, app):
        self.apps.append(app)

    def remove_application(self, app):
        self.apps.remove(app)

    def block_application(self, app):
        app.blocked = True

    def total_apps(self):
        return len(self.apps)


class Application:
    def __init__(self, name, blocked=False):
        self.name = name
        self.blocked = blocked



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/38QoBSpQqnM
#
# Подвиг 11 (на повторение). Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:
#
# add_message(msg) - добавление нового сообщения в список сообщений;
# remove_message(msg) - удаление сообщения из списка;
# set_like(msg) - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет
# то он ставится, если уже есть, то убирается);
# show_last_message(число) - отображение последних сообщений;
# total_messages() - возвращает общее число сообщений.
#
# Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# Viber.remove_message(msg)
# Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных
# свойств:
#
# text - текст сообщения (строка);
# fl_like - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном
# случае, изначально False);
#
# P.S. Как хранить список сообщений, решите самостоятельно.

class Message:
    def __init__(self, text, fl_like=False):
        self.text = text
        self.fl_like = fl_like

class Viber:

    msgs = []

    @classmethod
    def add_message(cls, msg):
        cls.msgs.append(msg)

    @classmethod
    def remove_message(cls, msg):
        cls.msgs.remove(msg)

    @classmethod
    def set_like(cls, msg):
        if msg.fl_like:
            msg.fl_like = False
        else:
            msg.fl_like = True

    @classmethod
    def show_last_message(cls, amount):
        print(cls.msgs[-amount:])

    @classmethod
    def total_messages(cls):
        return len(cls.msgs)


# ======================================================================================================================
# 1.8 Испытание свойствами и методами
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор (решение смотреть только после своей попытки): https://youtu.be/26pwwOu_-d0
#
# Время первого испытания. Представьте, что вы получили задание от заказчика. Вас просят реализовать простую имитацию
# локальной сети, состоящую из набора серверов, соединенных между собой через роутер.
#
#
#
# Каждый сервер может отправлять пакет любому другому серверу сети. Для этого у каждого есть свой уникальный IP-адрес.
# Для простоты - это просто целое (натуральное) число от 1 и до N, где N - общее число серверов. Алгоритм следующий.
# Предположим, сервер с IP = 2 собирается отправить пакет информации серверу с IP = 3. Для этого, он сначала отправляет
# пакет роутеру, а уже тот, смотрит на IP-адрес и пересылает пакет нужному узлу (серверу).
#
# Для реализации этой схемы программе предлагается объявить три класса:
#
# Server - для описания работы серверов в сети;
# Router - для описания работы роутеров в сети (в данной задаче полагается один роутер);
# Data - для описания пакета информации.
#
# Серверы будут создаваться командой:
#
# sv = Server()
# При этом, уникальный IP-адрес каждого сервера должен формироваться автоматически при создании нового экземпляра
# класса Server.
#
# Далее, роутер должен создаваться аналогичной командой:
#
# router = Router()
# А, пакеты данных, командой:
#
# data = Data(строка с данными, IP-адрес назначения)
# Для формирования и функционирования локальной сети, в классе Router должны быть реализованы следующие методы:
#
# link(server) - для присоединения сервера server (объекта класса Server) к роутеру (для простоты, каждый сервер
# соединен только с одним роутером);
# unlink(server) - для отсоединения сервера server (объекта класса Server) от роутера;
# send_data() - для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после
# отправки буфер должен очищаться).
#
# И одно обязательное локальное свойство (могут быть и другие свойства):
#
# buffer - список для хранения принятых от серверов пакетов (объектов класса Data).
#
# Класс Server должен содержать свой набор методов:
#
# send_data(data) - для отправки информационного пакета data (объекта класса Data) с указанным IP-адресом получателя
# (пакет отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# get_data() - возвращает список принятых пакетов (если ничего принято не было, то возвращается пустой список) и
# очищает входной буфер;
# get_ip() - возвращает свой IP-адрес.
#
# Соответственно в объектах класса Server должны быть локальные свойства:
#
# buffer - список принятых пакетов (объекты класса Data, изначально пустой);
# ip - IP-адрес текущего сервера.
#
# Наконец, объекты класса Data должны содержать два следующих локальных свойства:
#
# data - передаваемые данные (строка);
# ip - IP-адрес назначения.
#
# Пример использования этих классов (эти строчки в программе писать не нужно):
#
# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# Ваша задача реализовать классы Router, Server и Data в соответствии с приведенным техническим заданием (ТЗ).
# Что-либо выводить на экран не нужно.


class Router:

    def __init__(self):
        self.buffer = []
        self.servers = {}

    def link(self, server):
        self.servers[server.ip] = server
        server.router = self

    def unlink(self, server):
        s = self.servers.pop(server.ip, False)
        if s:
            s.router = None

    def send_data(self):
        for d in self.buffer:
            if d.ip in self.servers:
                self.servers[d.ip].buffer.append(d)
        self.buffer.clear()

class Server:
    server_ip = 1

    def __init__(self):
        self.buffer = []
        self.ip = Server.server_ip
        Server.server_ip += 1
        self.router = None

    def send_data(self, data):
        if self.router:
            self.router.buffer.append(data)

    def get_data(self):
        b = self.buffer[:]
        self.buffer.clear()
        return b

    def get_ip(self):
        return self.ip


class Data:

    def __init__(self, msg, ip):
        self.data = msg
        self.ip = ip



# ======================================================================================================================
# 2. Режимы доступа, свойства и дескрипторы
# ======================================================================================================================

# ======================================================================================================================
# 2.1. Режимы доступа public, private, protected. Сеттеры и геттеры
# ----------------------------------------------------------------------------------------------------------------------

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствия между именами атрибутов классов и их режимами доступа.

# self.data - публичный режим доступа (public)
# self._word - защищенный режим доступа (protected)
# self.__buffer - приватный режим доступа (private)

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Какую роль играет приватный (private) режим доступа атрибутов классов?

# - скрывает приватные переменные и методы от прямого доступа к ним (по исходным именам) вне класса
# - предостерегает программиста (использующего класс) от прямого использования приватных атрибутов вне класса

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Lqo3xcfaUZU
# Подвиг 3. Объявите класс с именем Clock и определите в нем следующие переменные и методы:
#
# - приватная локальная переменная time для хранения текущего времени, целое число (своя для каждого объекта класса
# Clock с начальным значением 0);
# - публичный метод set_time(tm) для установки текущего времени (присваивает значение tm приватному локальному свойству
# time, если метод check_time(tm) возвратил True);
# - публичный метод get_time() для получения текущего времени из приватной локальной переменной time;
# - приватный метод класса check_time(tm) для проверки корректности времени в переменной tm (возвращает True, если
# значение корректно и False - в противном случае).
#
# Проверка корректности выполняется по критерию: tm должна быть целым числом, больше или равна нулю и меньше 100 000.
#
# Объекты класса Clock предполагается использовать командой:
#
# clock = Clock(время)
# Создайте объект clock класса Clock и установите время, равным 4530.
#
# P.S. На экран ничего выводить не нужно.

class Clock:

    def __init__(self, time=0):
        self.__time = time

    def __check_time(self, tm):
        return True if type(tm) == int and 0 <= tm <= 100000 else False

    def set_time(self, tm):
        if self.__check_time(tm):
            self.__time = tm

    def get_time(self):
        return self.__time

clock = Clock(4530)


# Вторая версия
class Clock:
    __MIN_TIME = 0
    __MAX_TIME = 100_000

    def __init__(self, time=0):
        self.__time = time if self.__check_time(time) else 0

    def set_time(self, tm):
        if self.__check_time(tm):
            self.__time = tm

    def get_time(self):
        return self.__time

    @classmethod
    def __check_time(cls, tm):
        return type(tm) is int and cls.__MIN_TIME <= tm < cls.__MAX_TIME


clock = Clock()
clock.set_time(4530)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/iYcfCeRTyww
# Подвиг 4. Объявите класс с именем Money и определите в нем следующие переменные и методы:
#
# - приватная локальная переменная money (целочисленная) для хранения количества денег (своя для каждого объекта класса
# Money);
# - публичный метод set_money(money) для передачи нового значения приватной локальной переменной money (изменение
# выполняется только если метод check_money(money) возвращает значение True);
# - публичный метод get_money() для получения текущего объема средств (денег);
# - публичный метод add_money(mn) для прибавления средств из объекта mn класса Money к средствам текущего объекта;
# - приватный метод класса check_money(money) для проверки корректности объема средств в параметре money (возвращает
# True, если значение корректно и False - в противном случае).
#
# Проверка корректности выполняется по критерию: параметр money должен быть целым числом, больше или равным нулю.
#
# Пример использования класса Money (эти строчки в программе не писать):
#
# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120


class Money:

    def __init__(self, money):
        self.__money = money

    def set_money(self, money):
        if self.__check_money(money):
            self.__money = money

    @classmethod
    def __check_money(cls, money):
        return True if type(money) is int and money >= 0 else False

    def get_money(self):
        return self.__money

    def add_money(self, mn):
        self.__money += mn.get_money()


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Какую роль в классах играют сеттеры и геттеры и что они из себя представляют?

# - это публичные методы для считывания и записи значений в приватные переменные класса или его объектов


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/w0SAD6zNLlw
# Подвиг 6. Объявите класс Book со следующим набором сеттеров и геттеров:
#
# set_title(self, title) - запись в локальное приватное свойство __title объектов класса Book значения title;
# set_author(self, author) - запись в локальное приватное свойство __author объектов класса Book значения author;
# set_price(self, price) - запись в локальное приватное свойство __price объектов класса Book значения price;
# get_title(self) - получение значения локального приватного свойства __title объектов класса Book;
# get_author(self) - получение значения локального приватного свойства __author объектов класса Book;
# get_price(self) - получение значения локального приватного свойства __price объектов класса Book;
#
# Объекты класса Book предполагается создавать командой:
#
# book = Book(автор, название, цена)
# При этом, в каждом объекте должны создаваться приватные локальные свойства:
#
# __author - строка с именем автора;
# __title - строка с названием книги;
# __price - целое число с ценой книги.
#
# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.


class Book:

    def __init__(self, author, title, price):
        self.__author = author
        self.__title = title
        self.__price = price

    def set_title(self, title):
        self.__title = title

    def set_author(self, author):
        self.__author = author

    def set_price(self, price):
        self.__price = price

    def get_title(self):
        return self.__title

    def get_author(self):
        return self.__author

    def get_price(self):
        return self.__price


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZX8fVI0KTfE
# Подвиг 7. Объявите класс Line для описания линии на плоскости, объекты которого предполагается создавать командой:
#
# line = Line(x1, y1, x2, y2)
# При этом в объекте line должны создаваться следующие приватные локальные свойства:
#
# __x1, __y1 - начальная координата;
# __x2, __y2 - конечная координата.
#
# В самом классе Line должны быть реализованы следующие сеттеры и геттеры:
#
# set_coords(self, x1, y1, x2, y2) - для изменения координат линии;
# get_coords(self) - для получения кортежа из текущих координат линии.
#
# А также метод:
#
# draw(self) - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).
#
# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

class Line:

    def __init__(self, x1, y1, x2, y2):
        self.__x1 = x1
        self.__x2 = x2
        self.__y1 = y1
        self.__y2 = y2

    def set_coords(self, x1, y1, x2, y2):
        self.__x1 = x1
        self.__x2 = x2
        self.__y1 = y1
        self.__y2 = y2

    def get_coords(self):
        return self.__x1, self.__y1, self.__x2, self.__y2

    def draw(self):
        print(*self.get_coords())


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rcj0pB1aB5M
#
# Подвиг 8. Объявите в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:
#
# pt = Point(x, y)
# где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point должны
# формироваться следующие локальные свойства:
#
# __x, __y - координаты точки на плоскости.
#
# и один геттер:
#
# get_coords() - возвращение кортежа текущих координат __x, __y
#
# Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:
#
# r1 = Rectangle(Point(x1, y1), Point(x2, y2))
# или
#
# r2 = Rectangle(x1, y1, x2, y2)
# Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в
# объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:
#
# __sp - объект класса Point с координатами x1, y1 (верхний левый угол);
# __ep - объект класса Point с координатами x2, y2 (нижний правый угол).
#
# Также к классе Rectangle должны быть реализованы следующие методы:
#
# set_coords(self, sp, ep) - изменение текущих координат, где sp, ep - объекты класса Point;
# get_coords(self) - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника (ссылки на
# локальные свойства __sp и __ep);
# draw(self) - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)".
# Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.
#
# Создайте объект rect класса Rectangle с координатами (0, 0), (20, 34).
#
# P.S. На экран ничего выводить не нужно.


class Point:

    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def get_coords(self):
        return self.__x, self.__y


class Rectangle:

    def __init__(self, *args):
        if len(args) == 4:
            self.__sp = Point(args[0], args[1])
            self.__ep = Point(args[2], args[3])
        else:
            self.__sp = args[0]
            self.__ep = args[1]

    def set_coords(self, sp, ep):
        self.__sp = sp
        self.__ep = ep

    def get_coords(self):
        return self.__sp, self.__ep

    def draw(self):
        print(f'Прямоугольник с координатами: {self.__sp.get_coords()} {self.__ep.get_coords()}')


rect = Rectangle(0, 0, 20, 34)

# Второй вариант
class Point:
    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def get_coords(self):
        return self.__x, self.__y


class Rectangle:
    def __init__(self, *args):
        if len(args) == 2:
            self.set_coords(*args)
        elif len(args) == 4:
            x1, y1, x2, y2 = args
            self.set_coords(Point(x1, y1), Point(x2, y2))

    def set_coords(self, sp, ep):
        self.__sp = sp
        self.__ep = ep

    def get_coords(self):
        return self.__sp, self.__ep

    def draw(self):
        x1, y1, x2, y2 = self.__sp, self.__ep
        print(f'Прямоугольник с координатами: ({x1}, {y1}) ({x2}, {y2})')


rect = Rectangle(0, 0, 20, 34)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YJiPpHVguyE
# Теория по двусвязным спискам (при необходимости): https://youtu.be/0sTH9EwXT1I

# Большой подвиг 9. Необходимо реализовать связный список (не список языка Python и не хранить объекты в списке Python),
# когда объекты класса ObjList связаны с соседними через приватные свойства __next и __prev:

# Для этого объявите класс LinkedList, который будет представлять связный список в целом и иметь набор следующих
# методов:
#
# add_obj(self, obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(self) - удаление последнего объекта из связного списка;
# get_data(self) - получение списка из строк локального свойства __data всех объектов связного списка.
#
# И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пустой, то head = None);
# tail - ссылка на последний объект связного списка (если список пустой, то tail = None).
#
# Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:
#
# __next - ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);
# __prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);
# __data - строка с данными.
#
# Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:
#
# set_next(self, obj) - изменение приватного свойства __next на значение obj;
# set_prev(self, obj) - изменение приватного свойства __prev на значение obj;
# get_next(self) - получение значения приватного свойства __next;
# get_prev(self) - получение значения приватного свойства __prev;
# set_data(self, data) - изменение приватного свойства __data на значение data;
# get_data(self) - получение значения приватного свойства __data.
#
# Создавать объекты класса ObjList предполагается командой:
#
# ob = ObjList("данные 1")
# А использовать класс LinkedList следующим образом (пример, эти строчки писать в программе не нужно):
#
# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
# Объявите в программе классы LinkedList и ObjList в соответствии с заданием.
#
# P.S. На экран ничего выводить не нужно.

class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if self.tail:
            self.tail.set_next(obj)
        obj.set_prev(self.tail)
        self.tail = obj
        if not self.head:
            self.head = obj

    def remove_obj(self):
        if self.tail is None:
            return

        prev = self.tail.get_prev()
        if prev:
            prev.set_next(None)

        self.tail = prev
        if self.tail is None:
            self.head = None

    def get_data(self):
        l = []
        getter = self.head
        while getter:
            l.append(getter.get_data())
            getter = getter.get_next()
        return l



class ObjList:

    def __init__(self, data):
        self.__next = None
        self.__prev = None
        self.__data = data

    def set_next(self, obj):
        self.__next = obj

    def set_prev(self, obj):
        self.__prev = obj

    def set_data(self, data):
        self.__data = data

    def get_next(self):
        return self.__next

    def get_prev(self):
        return self.__prev

    def get_data(self):
        return self.__data


lst = LinkedList()
lst.add_obj(ObjList("данные 1"))
lst.add_obj(ObjList("данные 2"))
lst.add_obj(ObjList("данные 3"))
res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']

print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HPgJtLb2NV8
# Подвиг 10 (на повторение). Объявите класс EmailValidator для проверки корректности email-адреса. Необходимо запретить
# создание объектов этого класса: при создании экземпляров должно возвращаться значение None, например:
#
# em = EmailValidator() # None
# В самом классе реализовать следующие методы класса (@classmethod):
#
# get_random_email(cls) - для генерации случайного email-адреса по формату: xxxxxxx...xxx@gmail.com, где x - любой
# допустимый символ в email (латинский буквы, цифры, символ подчеркивания и точка);
# check_email(cls, email) - возвращает True, если email записан верно и False - в противном случае.
#
# Корректность строки email определяется по следующим критериям:
#
# - допустимые символы: латинский алфавит, цифры, символы подчеркивания, точки и собачка @ (одна);
# - длина email до символа @ не должна превышать 100 (сто включительно);
# - длина email после символа @ не должна быть больше 50 (включительно);
# - после символа @ обязательно должна идти хотя бы одна точка;
# - не должно быть двух точек подряд.
#
# Также в классе нужно реализовать приватный статический метод класса:
#
# is_email_str(email) - для проверки типа переменной email, если строка, то возвращается значение True, иначе - False.
#
# Метод is_email_str() следует использовать в методе check_email() перед проверкой корректности email. Если параметр
# email не является строкой, то check_email() возвращает False.
#
# Пример использования класса EmailValidator (эти строчки в программе писать не нужно):
#
# res = EmailValidator.check_email("sc_lib@list.ru") # True
# res = EmailValidator.check_email("sc_lib@list_ru") # False
# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.

import random
import string

class EmailValidator:
    __CHARS = string.ascii_letters + string.digits + '_.'

    def __new__(cls, *args, **kwargs):
        return None

    @classmethod
    def get_random_email(cls):
        res = ''
        for i in range(random.randint(1, 100)):
            res += random.choice(EmailValidator.__CHARS)
        res += '@gmail.com'
        if EmailValidator.check_email(res):
            return res
        else:
            EmailValidator.get_random_email()

    @classmethod
    def check_email(cls, email):
        if len(email[:email.index('@')]) > 100 or len(email[email.index('@'):]) > 50:
            return False
        if email[email.index('@'):].count('.') < 1:
            return False
        if email.count('..') > 0:
            return False
        for i in email:
            if i == '@':
                continue
            if i not in EmailValidator.__CHARS:
                return False
        return True

    @staticmethod
    def __is_email_str(email):
        if type(email) == str:
            return True
        else:
            return False


# ======================================================================================================================
# 2.2 Свойства property. Декоратор @property
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Пусть в программе объявлен следующий класс:
#
class Money:
    def __init__(self):
        self.__money = 0

    def set_money(self, value):
        self.__money = value

    def get_money(self):
        return self.__money

    money = property(get_money, set_money)
# И, затем, выполняются команды:
#
m = Money()
m.money = 10
# Выберите верные утверждения, связанные с этими программными строчками.

# - в строчке m.money = 10 происходит вызов метода set_money и локальной переменной __money присваивается значение 10
# - для считывания информации из локальной переменной __money достаточно записать res = m.money
# - в строчке money = property(get_money, set_money) создается объект-свойство с геттером get_money и сеттером set_money


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Пусть в некотором классе определены три метода:
#
# get_pr() - геттер;
# set_pr() - сеттер;
# del_pr() - делитер.
#
# Выберите все верные варианты использования класса property для создания объектов-свойств на основе этих методов.

# - pr = property(get_pr)
# - pr = property(); pr = pr.setter(set_pr); pr = pr.getter(get_pr); pr = pr.deleter(del_pr)
# - pr = property(get_pr, set_pr)
# - pr = property(); pr = pr.setter(set_pr); pr = pr.getter(get_pr)
# - pr = property(get_pr, set_pr, del_pr)

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. В каких случаях целесообразно использовать объекты-свойства?

# - для инициализации локальных свойств в момент создания объектов
# - для удобства доступа к приватным атрибутам класса или объектов
# - для реализации дополнительной логики (программы) в момент присваивания и считывания информации из атрибутов класса
# или объектов

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PN3SjHz2ZG4
#
# Подвиг 4. Объявите в программе класс Car, в котором реализуйте объект-свойство с именем model для записи и считывания
# информации о модели автомобиля из локальной приватной переменной __model.
#
# Объект-свойство объявите с помощью декоратора @property. Также в объекте-свойстве model должны быть реализованы
# проверки:
#
# - модель автомобиля - это строка;
# - длина строки модели должна быть в диапазоне [2; 100].
#
# Если проверка не проходит, то локальное свойство __model остается без изменений.
#
# Объекты класса Car предполагается создавать командой:
#
# car = Car()
# и далее работа с объектом-свойством, например:
#
# car.model = "Toyota"
# P.S. В программе объявить только класс. На экран ничего выводить не нужно.


class Car:

    def __init__(self):
        self.__model = None

    @property
    def model(self):
        return self.__model

    @model.setter
    def model(self, model):
        if type(model) is str and 2 <= len(model) <= 100:
            self.__model = model


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/P0sI_Eb_i0c
#
# Подвиг 5. Объявите в программе класс WindowDlg, объекты которого предполагается создавать командой:
#
# wnd = WindowDlg(заголовок окна, ширина, высота)
# В каждом объекте класса WindowDlg должны создаваться приватные локальные атрибуты:
#
# __title - заголовок окна (строка);
# __width, __height - ширина и высота окна (числа).
#
# В классе WindowDlg необходимо реализовать метод:
#
# show() - для отображения окна на экране (выводит в консоль строку в формате: "<Заголовок>: <ширина>, <высота>",
# например "Диалог 1: 100, 50").
#
# Также в классе WindowDlg необходимо реализовать два объекта-свойства:
#
# width - для изменения и считывания ширины окна;
# height - для изменения и считывания высоты окна.
#
# При изменении размеров окна необходимо выполнять проверку:
#
# - переданное значение является целым числом в диапазоне [0; 10000].
#
# Если хотя бы один размер изменился (высота или ширина), то следует выполнить автоматическую перерисовку окна
# (вызвать метод show()). При начальной инициализации размеров width, height вызывать метод show() не нужно.
#
# P.S. В программе нужно объявить только класс с требуемой функциональностью.


class WindowDlg:

    def __init__(self, title, width, height):
        self.__title = title
        self.__width = width
        self.__height = height

    def get_title(self):
        return self.__title

    @property
    def width(self):
        return self.__width

    @width.setter
    def width(self, width):
        if type(width) is int and 0 <= width <= 10000:
            self.__width = width
            self.show()

    @property
    def height(self):
        return self.__height

    @height.setter
    def height(self, height):
        if type(height) is int and 0 <= height <= 10000:
            self.__height = height
            self.show()

    def show(self):
        print(f'{self.get_title()}: {self.width}, {self.height}')


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/mg4b8nhVDKY
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 6. Реализуйте односвязный список (не список Python, не использовать список Python для хранения объектов),
# когда один объект ссылается на следующий и так по цепочке до последнего:

# Для этого объявите в программе два класса:
#
# StackObj - для описания объектов односвязного списка;
# Stack - для управления односвязным списком.
#
# Объекты класса StackObj предполагается создавать командой:
#
# obj = StackObj(данные)
# Здесь данные - это строка с некоторым содержимым. Каждый объект класса StackObj должен иметь следующие локальные
# приватные атрибуты:
#
# __data - ссылка на строку с данными, указанными при создании объекта;
# __next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).
#
# Также в классе StackObj должны быть объявлены объекты-свойства:
#
# next - для записи и считывания информации из локального приватного свойства __next;
# data - для записи и считывания информации из локального приватного свойства __data.
#
# При записи необходимо реализовать проверку, что __next будет ссылаться на объект класса StackObj или значение None.
# Если проверка не проходит, то __next остается без изменений.
#
# Класс Stack предполагается использовать следующим образом:
#
# st = Stack() # создание объекта односвязного списка
# В объектах класса Stack должен быть локальный публичный атрибут:
#
# top - ссылка на первый добавленный объект односвязного списка (если список пуст, то top = None).
#
# А в самом классе Stack следующие методы:
#
# push(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
# pop(self) - извлечение последнего объекта с его удалением из односвязного списка;
# get_data(self) - получение списка из объектов односвязного списка (список из строк локального атрибута __data
# каждого объекта в порядке их добавления, или пустой список, если объектов нет).
#
# Пример использования классов Stack и StackObj (эти строчки в программе писать не нужно):
#
# st = Stack()
# st.push(StackObj("obj1"))
# st.push(StackObj("obj2"))
# st.push(StackObj("obj3"))
# st.pop()
# res = st.get_data()    # ['obj1', 'obj2']
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.


class StackObj:

    def __init__(self, data):
        self.__data = data
        self.__next = None

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, data):
        self.__data = data

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, next):
        if isinstance(next, StackObj) or next is None:
            self.__next = next


class Stack:

    def __init__(self):
        self.top = None
        self.last = None

    def push(self, obj):
        if self.last:
            self.last.next = obj
        self.last = obj

        if self.top is None:
            self.top = obj




    def pop(self):
        tail = self.top
        if tail is None:
            return

        while tail and tail.next != self.last:
            tail = tail.next
        if tail:
            tail.next = None
        last = self.last
        self.last = tail
        if self.last is None:
            self.top = None

        return last


    def get_data(self):
        res = []
        tail = self.top
        while tail:
            res.append(tail.data)
            tail = tail.next
        return res


st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st.pop()
res = st.get_data()  # ['obj1', 'obj2']
print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/q_8BdpVWbyE
#
# Подвиг 7. Объявите класс RadiusVector2D, объекты которого должны создаваться командами:
#
# v1 = RadiusVector2D()        # радиус-вектор с координатами (0; 0)
# v2 = RadiusVector2D(1)       # радиус-вектор с координатами (1; 0)
# v3 = RadiusVector2D(1, 2)    # радиус-вектор с координатами (1; 2)
# В каждом объекте класса RadiusVector2D должны формироваться локальные приватные атрибуты:
#
# __x, __y - координаты конца вектора (изначально значения равны 0, если не передано какое-либо другое).
#
# В классе RadiusVector2D необходимо объявить два объекта-свойства:
#
# x - для изменения и считывания локального атрибута __x;
# y - для изменения и считывания локального атрибута __y.
#
# При инициализации и изменении локальных атрибутов, необходимо проверять корректность передаваемых значений:
#
# - значение должно быть числом (целым или вещественным) в диапазоне [MIN_COORD; MAX_COORD].
#
# Если проверка не проходит, то координаты не меняются (напомню, что при инициализации они изначально равны 0).
# Величины MIN_COORD = -100, MAX_COORD = 1024 задаются как публичные атрибуты класса RadiusVector2D.
#
# Также в классе RadiusVector2D необходимо объявить статический метод:
#
# norm2(vector) - для вычисления квадратической нормы vector - переданного объекта класса RadiusVector2D
# (квадратическая норма вектора: x*x + y*y).
#
# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.


class RadiusVector2D:
    MIN_COORD = -100
    MAX_COORD = 1024

    def __init__(self, x=0, y=0):
        self.__x = self.__y = 0
        if self.__is_verify(x):
            self.__x = x
        if self.__is_verify(y):
            self.__y = y

    @property
    def x_coord(self):
        return self.__x

    @x_coord.setter
    def x(self, x):
        if self.__is_verify(x):
            self.__x = x

    @property
    def y_coord(self):
        return self.__y

    @y_coord.setter
    def y(self, y):
        if self.__is_verify(y):
            self.__y = y

    @staticmethod
    def norm2(vector):
        return vector.x_coord ** 2 + vector.y_coord ** 2

    @classmethod
    def __is_verify(cls, value):
        if type(value) in (int, float) and cls.MIN_COORD <= value <= cls.MAX_COORD:
            return True
        else:
            return False


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5Y9qT5grunw
#
# Большой подвиг 8. Требуется реализовать программу по работе с решающими деревьями:
# Здесь в каждом узле дерева делается проверка (задается вопрос). Если проверка проходит, то осуществляется переход к
# следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не
# дойдем до одного из листа дерева (вершины без потомков).
#
# В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет. Каждый элемент
# этого списка соответствует своему вопросу (своей вершине дерева), например:
# Далее, этот вектор применяется к решающему дереву, следующим образом. Корневая вершина "Любит Python" с ней связан
# первый элемент вектора x и содержит значение 1, следовательно, мы переходим по левой ветви. Попадаем в вершину
# "Понимает ООП". С ней связан второй элемент вектора x со значением 0, следовательно, мы переходим по правой ветви
# и попадаем в вершину "будет кодером". Так как эта вершина конечная (листовая), то получаем результат в виде строки
# "будет кодером". По аналогии выполняется обработка вектора x с другими наборами значений 0 и 1.
#
# Для реализации решающих деревьев в программе следует объявить два класса:
#
# TreeObj - для описания вершин и листьев решающего дерева;
# DecisionTree - для работы с решающим деревом в целом.
#
# В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):
#
# def predict(cls, root, x) - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла
# дерева root.
# def add_obj(cls, obj, node=None, left=True) - для добавления вершин в решающее дерево (метод должен возвращать
# добавленную вершину - объект класса TreeObj);
#
# В методе add_obj параметры имеют, следующие значения:
#
# obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);
# node - ссылка на объект дерева, к которому присоединяется вершина obj;
# left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви;
# False - к правой).
#
# В классе TreeObj следует объявить инициализатор:
#
# def __init__(self, indx, value=None): ...
#
# где indx - проверяемый в вершине дерева индекс вектора x; value - значение, хранящееся в вершине (принимает значение
# None для вершин, у которых есть потомки - промежуточных вершин).
#
# При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:
#
# indx - проверяемый индекс (целое число);
# value - значение с данными (строка);
# __left - ссылка на следующий объект дерева по левой ветви (изначально None);
# __right - ссылка на следующий объект дерева по правой ветви (изначально None).
#
# Для работы с локальными приватными атрибутами __left и __right необходимо объявить объекты-свойства с именами
# left и right.
#
# Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):
#
# root = DecisionTree.add_obj(TreeObj(0))
# v_11 = DecisionTree.add_obj(TreeObj(1), root)
# v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
# DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
# DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
# DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
# DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)
#
# x = [1, 1, 0]
# res = DecisionTree.predict(root, x) # будет программистом
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

class DecisionTree:

    @classmethod
    def predict(cls, root, x):
        obj = root
        while obj:
            obj_next = cls.get_next(obj, x)
            if obj_next is None:
                break
            obj = obj_next

        return obj.value

    @classmethod
    def get_next(cls, obj, x):
        if x[obj.index] == 1:
            return obj.left
        return obj.right


    @classmethod
    def add_obj(cls, obj, node=None, left=True):
        if node:
            if left:
                node.left = obj
            else:
                node.right = obj
        return obj


class TreeObj:

    def __init__(self, indx, value=None):
        self.index = indx
        self.value = value
        self.__left = None
        self.__right = None

    @property
    def left(self):
        return self.__left

    @left.setter
    def left(self, left):
        self.__left = left

    @property
    def right(self):
        return self.__right

    @right.setter
    def right(self, right):
        self.__right = right


root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/EAt0fgLNYGg
#
# Подвиг 9 (на закрепление). Вам требуется сформировать класс PathLines для описания маршрутов,
# состоящих из линейных
# сегментов. При этом каждый линейный сегмент предполагается задавать отдельным классом LineTo.
# Объекты этого класса
# будут формироваться командой:
#
# line = LineTo(x, y)
# где x, y - следующая координата линейного участка (начало маршрута из точки 0, 0).
#
# В каждом объекте класса LineTo должны формироваться локальные атрибуты:
#
# x, y - для хранения координат конца линии (начало определяется по координатам предыдущего
# объекта).
#
# Объекты класса PathLines должны создаваться командами:
#
# p = PathLines()                   # начало маршрута из точки 0, 0
# p = PathLines(line1, line2, ...)  # начало маршрута из точки 0, 0
# где line1, line2, ... - объекты класса LineTo.
#
# Сам же класс PathLines должен иметь следующие методы:
#
# get_path() - возвращает список из объектов класса LineTo (если объектов нет, то пустой список);
# get_length() - возвращает суммарную длину пути (сумма длин всех линейных сегментов);
# add_line(self, line) - добавление нового линейного сегмента (объекта класса LineTo) в конец
# маршрута.
#
# Пояснение: суммарный маршрут - это сумма длин всех линейных сегментов, а длина каждого
# линейного сегмента
# определяется как евклидовое расстояние по формуле:
#
# L = sqrt((x1-x0)^2 + (y1-y0)^2)
#
# где x0, y0 - предыдущая точка маршрута; x1, y1 - текущая точка маршрута.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# p = PathLines(LineTo(10, 20), LineTo(10, 30))
# p.add_line(LineTo(20, -10))
# dist = p.get_length()
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

class LineTo:
    def __init__(self, x, y):
        self.x = x
        self.y = y


class PathLines:

    def __init__(self, *args):
        self.lines = list((LineTo(0, 0), ) + args)

    def get_path(self):
        return self.lines[1:]

    def add_line(self, line):
        self.lines.append(line)

    def get_length(self):
        g = ((self.lines[i - 1], self.lines[i]) for i in range(1, len(self.lines)))
        return sum(map(lambda t: ((t[0].x - t[1].x) ** 2 + (t[0].y - t[1].y) ** 2) ** 0.5, g))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/TMPPmryMKD0
#
# Подвиг 10 (на закрепление). Вы создаете телефонную записную книжку. Она определяется классом
# PhoneBook. Объекты этого класса создаются командой:
#
# p = PhoneBook()
# А сам класс должен иметь следующий набор методов:
#
# add_phone(phone) - добавление нового номера телефона (в список);
# remove_phone(indx) - удаление номера телефона по индексу списка;
# get_phone_list() - получение списка из объектов всех телефонных номеров.
#
# Каждый номер телефона должен быть представлен классом PhoneNumber. Объекты этого класса должны
# создаваться командой:
#
# note = PhoneNumber(number, fio)
# где number - номер телефона (число) в формате XXXXXXXXXXX (одиннадцати цифр, X - цифра);
# fio - Ф.И.О. владельца номера (строка).
#
# В каждом объекте класса PhoneNumber должны формироваться локальные атрибуты:
#
# number - номер телефона (число);
# fio - ФИО владельца номера телефона.
#
# Необходимо объявить два класса PhoneBook и PhoneNumber в соответствии с заданием.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# p = PhoneBook()
# p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
# p.add_phone(PhoneNumber(21345678901, "Панда"))
# phones = p.get_phone_list()
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

class PhoneBook:

    def __init__(self):
        self.phones = []

    def add_phone(self, phone):
        self.phones.append(phone)

    def remove_phone(self, indx):
        del self.phones[indx]

    def get_phone_list(self):
        return self.phones


class PhoneNumber:

    def __init__(self, number, fio):
        self.number = number
        self.fio = fio


# ======================================================================================================================
# 2.3. Дескрипторы (data descriptor и non-data descriptor)
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что из себя представляют дескрипторы?

# - это любой класс, в котором объявлены специальные методы __get__, __set__ и/или __del__
# - это любой класс, в котором объявлены специальные методы __get__ и __set__
# - это любой класс, в котором объявлен специальный метод __get__


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Чем дескрипторы концептуально отличаются от объектов-свойств (property)?

# - в одном классе дескриптора можно единожды описать логику взаимодействия с внутренними (приватными или защищенными)
# переменными
# - один класс дескриптора способен заменить множество однотипных объектов-свойств


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Какие виды дескрипторов существуют?

# - дескриптор не данных (non-data descriptor), когда в классе присутствует метод __get__, но отсутствует метод __set__
# - дескриптор данных (data descriptor), когда в классе присутствуют методы __get__ и __set__


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. В программе объявлен дескриптор RealValue и класс Point:

class RealValue:
    def __set_name__(self, owner, name):
        self.name = "_" + name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]


class Point:
    x = RealValue()
    y = RealValue()

    def __init__(self, x, y):
        self.x = x
        self.y = y

# А, затем, выполняются команды:
pt = Point(1.5, 2.3)
pt.__dict__['x'] = 10.0
print(pt.x)

# Какое значение будет выведено в консоль и почему?

# - Будет выведено 10.0, так как RealValue - это дескриптор не данных и в инициализаторе будут созданы локальные
# свойства x, y. Затем, в строчке pt.x идет обращение к локальному свойству x со значением 10.


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. В программе объявлен дескриптор StringField и класс DataBase:

class StringField:
    def __set_name__(self, owner, name):
        self.name = "_" + name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class DataBase:
    x = StringField()
    y = StringField()

    def __init__(self, x, y):
        self.x = x
        self.y = y

# А, затем, выполняются команды:

db = DataBase('hi', 'low')
db.__dict__['x'] = 'top'
print(db.x)

# Какое значение будет выведено в консоль и почему?

# - Будет выведено 'hi', так как StringField - это дескриптор данных и он имеет наибольший приоритет при обращении к
# атрибутам, поэтому в строчке db.x будет обращение к дескриптору, а не к локальному свойству.


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/xHINhSQJh5c
#
# Подвиг 6. Объявите дескриптор данных FloatValue, который бы устанавливал и возвращал вещественные значения. При
# записи вещественного числа должна выполняться проверка на вещественный тип данных. Если проверка не проходит, то
# генерировать исключение командой:
#
# raise TypeError("Присваивать можно только вещественный тип данных.")
# Объявите класс Cell, в котором создается объект value дескриптора FloatValue. А объекты класса Cell должны
# создаваться командой:
#
# cell = Cell(начальное значение ячейки)
# Объявите класс TableSheet, с помощью которого создается таблица из N строк и M столбцов следующим образом:
#
# table = TableSheet(N, M)
# Каждая ячейка этой таблицы должна быть представлена объектом класса Cell, работать с вещественными числами через
# объект value (начальное значение должно быть 0.0).
#
# В каждом объекте класса TableSheet должен формироваться локальный атрибут:
#
# cells - список (вложенный) размером N x M, содержащий ячейки таблицы (объекты класса Cell).
#
# Создайте объект table класса TableSheet с размером таблицы N = 5, M = 3. Запишите в эту таблицу числа от 1.0 до
# 15.0 (по порядку).
#
# P.S. На экран в программе выводить ничего не нужно.


class FloatValue:

    @classmethod
    def verify(cls, value):
        if type(value) != float:
            raise TypeError("Присваивать можно только вещественный тип данных.")

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        self.verify(value)
        instance.__dict__[self.name] = value


class Cell:
    value = FloatValue()

    def __init__(self, value=0.0):
        self.value = value

class TableSheet:

    def __init__(self, N, M):
        self.N = N
        self.M = M
        self.cells = [[Cell() for _ in range(self.M)] for _ in range(self.N)]


table = TableSheet(5, 3)
x = 1.0
for i in range(table.N):
    for j in range(table.M):
        table.cells[i][j].value = x
        x += 1


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/zCD5_APRzes
#
# Подвиг 7. Объявите класс ValidateString для проверки корректности переданной строки. Объекты этого класса создаются
# командой:
#
# validate = ValidateString(min_length=3, max_length=100)
# где min_length - минимальное число символов в строке; max_length - максимальное число символов в строке.
# В классе ValidateString должен быть реализован метод:
#
# validate(self, string) - возвращает True, если string является строкой (тип str) и длина строки в
# пределах [min_length; max_length]. Иначе возвращается False.
#
# Объявите дескриптор данных StringValue для работы со строками, объекты которого создаются командой:
#
# st = StringValue(validator=ValidateString(min_length, max_length))
# При каждом присвоении значения объекту st должен вызываться валидатор (объект класса ValidateString) и с помощью
# метода validate() проверяться корректность присваиваемых данных. Если данные некорректны, то присвоение не
# выполняется (игнорируется).
#
# Объявите класс RegisterForm с тремя объектами дескриптора StringValue:
#
# login = StringValue(...) - для ввода логина;
# password = StringValue(...)  - для ввода пароля;
# email = StringValue(...)  - для ввода Email.
#
# Объекты класса RegisterForm создаются командой:
#
# form = RegisterForm(логин, пароль, email)
# где логин, пароль, email - начальные значения логина, пароля и Email.
# В классе RegisterForm также должны быть объявлены методы:
#
# get_fields() - возвращает список из значений полей в порядке [login, password, email];
# show() - выводит в консоль многострочную строку в формате:
#
# <form>
# Логин: <login>
# Пароль: <password>
# Email: <email>
# </form>
#
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.


class StringValue:

    def __init__(self, validator):
        self.validator = validator

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if self.validator.validate(value):
            setattr(instance, self.name, value)


class ValidateString:

    def __init__(self, min_length=3, max_length=100):
        self.min_length = min_length
        self.max_length = max_length

    def validate(self, string):
        if type(string) == str and self.min_length <= len(string) <= self.max_length:
            return True
        return False


class RegisterForm:

    login = StringValue(validator=ValidateString())
    password = StringValue(validator=ValidateString())
    email = StringValue(validator=ValidateString())

    def __init__(self, login, password, email):
        self.login = login
        self.password = password
        self.email = email

    def get_fields(self):
        return [self.login, self.password, self.email]

    def show(self):
        print(f'<form>\nЛогин: {self.login}\nПароль: {self.password}\nEmail: {self.email}')


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/l0U_3dTJZyc
#
# Подвиг 8. Вы начинаете создавать интернет-магазин. Для этого в программе объявляется класс SuperShop, объекты
# которого создаются командой:
#
# myshop = SuperShop(название магазина)
# В каждом объекте класса SuperShop должны формироваться следующие локальные атрибуты:
#
# name - название магазина (строка);
# goods - список из товаров.
#
# Также в классе SuperShop должны быть методы:
#
# add_product(product) - добавление товара в магазин (в конец списка goods);
# remove_product(product) - удаление товара из магазина (из списка goods).
#
# Здесь product - это объект класса Product, описывающий конкретный товар. В этом классе следует объявить следующие
# дескрипторы:
#
# name = StringValue(min_length, max_length)    # min_length - минимально допустимая длина строки; max_length - максимально допустимая длина строки
# price = PriceValue(max_value)    # max_value - максимально допустимое значение
#
# Объекты класса Product будут создаваться командой:
#
# pr = Product(наименование, цена)
# Классы StringValue и PriceValue - это дескрипторы данных. Класс StringValue должен проверять, что присваивается
# строковый тип с длиной строки в диапазоне [2; 50], т.е. min_length = 2, max_length = 50. Класс PriceValue должен
# проверять, что присваивается вещественное или целочисленное значение в диапазоне [0; 10000], т.е. max_value = 10000.
# Если проверки не проходят, то соответствующие (прежние) значения меняться не должны.
#
# Пример использования класса SuperShop (эти строчки в программе писать не нужно):
#
# shop = SuperShop("У Балакирева")
# shop.add_product(Product("Курс по Python", 0))
# shop.add_product(Product("Курс по Python ООП", 2000))
# for p in shop.goods:
#     print(f"{p.name}: {p.price}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.

class StringValue:


    def __init__(self, min_length, max_length):
        self.min_length = min_length
        self.max_length = max_length

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if type(value) == str and self.min_length <= len(value) <= self.max_length:
            setattr(instance, self.name, value)


class PriceValue:

    def __init__(self, max_price):
        self.max_price = max_price

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if type(value) in (int, float) and 0 <= value <= self.max_price:
            setattr(instance, self.name, value)


class SuperShop:

    def __init__(self, name):
        self.name = name
        self.goods = []

    def add_product(self, product):
        self.goods.append(product)

    def remove_product(self, product):
        if product in self.goods:
            self.goods.remove(product)


class Product:
    name = StringValue(2, 50)
    price = PriceValue(10000)

    def __init__(self, name, price):
        self.name = name
        self.price = price


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/S4CDXCG9nbA
#
# Подвиг 9 (на повторение). Необходимо объявить класс Bag (рюкзак), объекты которого будут создаваться командой:
#
# bag = Bag(max_weight)
# где max_weight - максимальный суммарный вес вещей, который выдерживает рюкзак (целое число).
#
# В каждом объекте этого класса должен создаваться локальный приватный атрибут:
#
# __things - список вещей в рюкзаке (изначально список пуст).
#
# Сам же класс Bag должен иметь объект-свойство:
#
# things - для доступа к локальному приватному атрибуту __things (только для считывания, не записи).
#
# Также в классе Bag должны быть реализованы следующие методы:
#
# add_thing(self, thing) - добавление нового предмета в рюкзак (добавление возможно, если суммарный вес (max_weight)
# не будет превышен, иначе добавление не происходит);
# remove_thing(self, indx) - удаление предмета по индексу списка __things;
# get_total_weight(self) - возвращает суммарный вес предметов в рюкзаке.
#
# Каждая вещь описывается как объект класса Thing и создается командой:
#
# t = Thing(название, вес)
# где название - наименование предмета (строка); вес - вес предмета (целое или вещественное число).
#
# В каждом объекте класса Thing должны формироваться локальные атрибуты:
#
# name - наименование предмета;
# weight - вес предмета.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# bag = Bag(1000)
# bag.add_thing(Thing("Книга по Python", 100))
# bag.add_thing(Thing("Котелок", 500))
# bag.add_thing(Thing("Спички", 20))
# bag.add_thing(Thing("Бумага", 100))
# w = bag.get_total_weight()
# for t in bag.things:
#     print(f"{t.name}: {t.weight}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.


class Bag:

    def __init__(self, max_weight):
        self.max_weight = max_weight
        self.weight_now = 0
        self.__things = []

    @property
    def things(self):
        return self.__things

    def add_thing(self, thing):
        if self.weight_now + thing.weight <= self.max_weight:
            self.__things.append(thing)
            self.weight_now += thing.weight

    def remove_thing(self, indx):
        self.weight_now -= self.__things[indx]
        del self.__things[indx]

    def get_total_weight(self):
        return self.weight_now


class Thing:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/45q8BT03c_U
#
# Подвиг 10 (на повторение). Необходимо написать программу для представления и управления расписанием телевизионного
# вещания. Для этого нужно объявить класс TVProgram, объекты которого создаются командой:
#
# pr = TVProgram(название канала)
# где название канала - это строка с названием телеканала.
#
# В каждом объекте класса TVProgram должен формироваться локальный атрибут:
#
# items - список из телепередач (изначально список пуст).
#
# В самом классе TVProgram должны быть реализованы следующие методы:
#
# add_telecast(self, tl) - добавление новой телепередачи в список items;
# remove_telecast(self, indx) - удаление телепередачи по ее порядковому номеру (атрибуту __id, см. далее).
#
# Каждая телепередача должна описываться классом Telecast, объекты которого создаются командой:
#
# tl = Telecast(порядковый номер, название, длительность)
# где порядковый номер - номер телепередачи в сетке вещания (от 1 и далее); название - наименование телепередачи;
# длительность - время телепередачи (в секундах - целое число).
#
# Соответственно, в каждом объекте класса Telecast должны формироваться локальные приватные атрибуты:
#
# __id - порядковый номер (целое число);
# __name - наименование телепередачи (строка);
# __duration - длительность телепередачи в секундах (целое число).
#
# Для работы с этими приватными атрибутами в классе Telecast должны быть объявлены соответствующие
# объекты-свойства (property):
#
# uid - для записи и считывания из локального атрибута __id;
# name - для записи и считывания из локального атрибута __name;
# duration - для записи и считывания из локального атрибута __duration.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# pr = TVProgram("Первый канал")
# pr.add_telecast(Telecast(1, "Доброе утро", 10000))
# pr.add_telecast(Telecast(2, "Новости", 2000))
# pr.add_telecast(Telecast(3, "Интервью с Балакиревым", 20))
# for t in pr.items:
#     print(f"{t.name}: {t.duration}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.

class TVProgram:

    def __init__(self, name_channel):
        self.name_channel = name_channel
        self.items = []

    def add_telecast(self, tl):
        self.items.append(tl)

    def remove_telecast(self, indx):
        for i in self.items:
            if i.uid == indx:
                self.items.remove(i)
                return


class Telecast:

    def __init__(self, number, name, time):
        self.__id = number
        self.__name = name
        self.__duration = time

    @property
    def uid(self):
        return self.__id

    @uid.setter
    def uid(self, id):
        self.__id = id

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name

    @property
    def duration(self):
        return self.__duration

    @duration.setter
    def duration(self, dur):
        self.__duration = dur


# Второй вариант
class Value:
    def __set_name__(self, owner, name):
        self.name = f'__{name}'

    def __set__(self, instance, value):
        setattr(instance, self.name, value)

    def __get__(self, instance, owner):
        return property() if instance is None else getattr(instance, self.name)


class Telecast:
    uid = Value()
    name = Value()
    duration = Value()

    def __init__(self, uid: int, name: str, duration: int):
        self.uid, self.name, self.duration = uid, name, duration


class TVProgram:
    def __init__(self, name):
        self.name = name
        self.__items = {}

    @property
    def items(self):
        return [val for _, val in sorted(self.__items.items())]

    def add_telecast(self, tl: Telecast):
        self.__items[tl.uid] = tl

    def remove_telecast(self, ind):
        del self.__items[ind]


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 3. Магические методы классов
# ======================================================================================================================

# ======================================================================================================================
# 3.1. Магические методы __setattr__, __getattribute__, __getattr__ и __delattr__
# ----------------------------------------------------------------------------------------------------------------------

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что в языке Python называют магическими (dunder) методами?
#  - методы с двумя нижними подчеркиваниями до и после имени метода, которые автоматически вызываются в определенных
#  для них ситуациях

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Установите соответствия между магическими методами и их описаниями.

# - __setattr__() - автоматически вызывается при изменении атрибута класса или объекта
# - __getattribute__() - автоматически вызывается при обращении к атрибуту класса или объекта
# - __getattr__() - автоматически вызывается при обращении к несуществующему атрибуту класса или объекта
# - __delattr__() - автоматически вызывается при удалении атрибута класса или объекта


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/lI99OdJt71w
#
# Подвиг 3. Объявите класс Book для представления информации о книге. Объекты этого класса должны создаваться
# командами:
#
# book = Book()
# book = Book(название, автор, число страниц, год издания)
# В каждом объекте класса Book автоматически должны формироваться следующие локальные свойства:
#
# title - заголовок книги (строка, по умолчанию пустая строка);
# author - автор книги (строка, по умолчанию пустая строка);
# pages - число страниц (целое число, по умолчанию 0);
# year - год издания (целое число, по умолчанию 0).
#
# Объявите в классе Book магический метод __setattr__ для проверки типов присваиваемых данных локальным свойствам
# title, author, pages и year. Если типы не соответствуют локальному атрибуту (например, title должна ссылаться на
# строку, а pages - на целое число), то генерировать исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# Создайте в программе объект book класса Book для книги:
#
# автор: Сергей Балакирев
# заголовок: Python ООП
# pages: 123
# year: 2022
#
# P.S. На экран ничего выводить не нужно.

class Book:

    def __init__(self, title='', author='', pages=0, year=0):
        self.title = title
        self.author = author
        self.pages = pages
        self.year = year

    def __setattr__(self, key, value):
        if key in ('title', 'author') and type(value) != str or key in ('pages', 'year') and type(value) != int:
            raise TypeError("Неверный тип присваиваемых данных.")
        object.__setattr__(self, key, value)

book = Book(title = 'Python ООП', author = 'Сергей Балакирев', pages=123, year=2022)


# ----------------------------------------------------------------------------------------------------------------------
class Shop:

    def __init__(self, name):
        self.name = name
        self.goods = []

    def add_product(self, product):
        self.goods.append(product)

    def remove_product(self, product):
        if product in self.goods:
            self.goods.remove(product)

class Product:
    id = 1
    attrs = {'name': (str, ), 'weight': (int, float), 'price': (int, float)}

    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price
        self.id = Product.id
        Product.id += 1

    def __setattr__(self, key, value):
        if key in self.attrs and type(value) in self.attrs[key]:
            if (key == 'price' or key == 'weight') and value <= 0:
                raise TypeError('Неверный тип присваиваемых данных.')
        elif key in self.attrs:
            raise TypeError('Неверный тип присваиваемых данных.')

        object.__setattr__(self, key, value)

    def __delattr__(self, item):
        if item == 'id':
            raise AttributeError("Атрибут id удалять запрещено.")
        object.__delattr__(self, item)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/7b8d5zqiiAM
#
# Подвиг 5. Необходимо создать программу для обучающего курса. Для этого объявляются три класса:
#
# Course - класс, отвечающий за управление курсом в целом;
# Module - класс, описывающий один модуль (раздел) курса;
# LessonItem - класс одного занятия (урока).
#
# Структура курса на уровне этих классов, приведена на рисунке ниже:

# Объекты класса LessonItem должны создаваться командой:
#
# lesson = LessonItem(название урока, число практических занятий, общая длительность урока)
# Соответственно, в каждом объекте класса LessonItem должны создаваться локальные атрибуты:
#
# title - название урока (строка);
# practices - число практических занятий (целое положительное число);
# duration - общая длительность урока (целое положительное число).
#
# Необходимо с помощью магических методов реализовать следующую логику взаимодействия с объектами класса LessonItem:
#
# 1. Проверять тип присваиваемых данных локальным атрибутам. Если типы не соответствуют требованиям, то генерировать
# исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# 2. При обращении к несуществующим атрибутам объектов класса LessonItem возвращать значение False.
# 3. Запретить удаление атрибутов title, practices и duration в объектах класса LessonItem.
#
# Объекты класса Module должны создаваться командой:
#
# module = Module(название модуля)
# Каждый объект класса Module должен содержать локальные атрибуты:
#
# name - название модуля;
# lessons - список из уроков (объектов класса LessonItem), входящих в модуль (изначально список пуст).
#
# Также в классе Module должны быть реализованы методы:
#
# add_lesson(self, lesson) - добавление в модуль (в конец списка lessons) нового урока (объекта класса LessonItem);
# remove_lesson(self, indx) - удаление урока по индексу в списке lessons.
#
# Наконец, объекты класса Course создаются командой:
#
# course = Course(название курса)
# И содержат следующие локальные атрибуты:
#
# name - название курса (строка);
# modules - список модулей в курсе (изначально список пуст).
#
# Также в классе Course должны присутствовать следующие методы:
#
# add_module(self, module) - добавление нового модуля в конце списка modules;
# remove_module(self, indx) - удаление модуля из списка modules по индексу в этом списке.
#
# Пример использования классов (в программе эти строчки не писать):
#
# course = Course("Python ООП")
# module_1 = Module("Часть первая")
# module_1.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_1.add_lesson(LessonItem("Урок 2", 10, 1200))
# module_1.add_lesson(LessonItem("Урок 3", 5, 800))
# course.add_module(module_1)
# module_2 = Module("Часть вторая")
# module_2.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_2.add_lesson(LessonItem("Урок 2", 10, 1200))
# course.add_module(module_2)
# P.S. На экран ничего выводить не нужно.


class LessonItem:

    def __init__(self, title, practices, duration):
        self.title = title
        self.practices = practices
        self.duration = duration

    def __setattr__(self, key, value):
        if key == 'title' and type(value) != str or key in ('practices', 'duration') and type(value) != int and value <= 0:
            raise TypeError("Неверный тип присваиваемых данных.")
        object.__setattr__(self, key, value)

    def __getattr__(self, item):
        return False

    def __delattr__(self, item):
        if item in ('title', 'practices', 'duration'):
            raise AttributeError(f"Атрибут {item} удалять запрещено.")
        object.__delattr__(self, item)


class Module:

    def __init__(self, name):
        self.name = name
        self.lessons = []

    def add_lesson(self, lesson):
        self.lessons.append(lesson)

    def remove_lesson(self, indx):
        del self.lessons[indx]


class Course:

    def __init__(self, name):
        self.name = name
        self.modules = []

    def add_module(self, module):
        self.modules.append(module)

    def remove_module(self, indx):
        del self.modules[indx]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/oyeub94DCKw
#
# Подвиг 6. Вам необходимо написать программу описания музеев. Для этого нужно объявить класс Museum, объекты которого
# формируются командой:
#
# mus = Museum(название музея)
# В объектах этого класса должны формироваться следующие локальные атрибуты:
#
# name - название музея (строка);
# exhibits - список экспонатов (изначально пустой список).
#
# Сам класс Museum должен иметь методы:
#
# add_exhibit(self, obj) - добавление нового экспоната в музей (в конец списка exhibits);
# remove_exhibit(self, obj) - удаление экспоната из музея (из списка exhibits по ссылке obj - на экспонат)
# get_info_exhibit(self, indx) - получение информации об экспонате (строка) по индексу списка (нумерация с нуля).
#
# Экспонаты представляются объектами своих классов. Для примера объявите в программе следующие классы экспонатов:
#
# Picture - для картин;
# Mummies - для мумий;
# Papyri - для папирусов.
#
# Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):
#
# p = Picture(название, художник, описание)            # локальные атрибуты: name - название; author - художник;
# descr - описание

# m = Mummies(имя мумии, место находки, описание)      # локальные атрибуты: name - имя мумии;
# location - место находки; descr - описание

# pr = Papyri(название папируса, датировка, описание)  # локальные атрибуты: name - название папируса;
# date - датировка (строка); descr - описание
# Метод get_info_exhibit() класса Museum должен возвращать значение атрибута descr указанного экспоната в формате:
#
# "Описание экспоната {name}: {descr}"
#
# Например:
#
# "Описание экспоната Девятый вал: Айвазовский написал супер картину."
#
# Пример использования классов (в программе эти строчки писать не нужно - только для примера):
#
# mus = Museum("Эрмитаж")
# mus.add_exhibit(Picture("Балакирев с подписчиками пишет письмо иноземному султану", "Неизвестный автор",
# "Вдохновляющая, устрашающая, волнующая картина"))

# mus.add_exhibit(Mummies("Балакирев", "Древняя Россия", "Просветитель XXI века, удостоенный мумификации"))

# p = Papyri("Ученья для, не злата ради", "Древняя Россия", "Самое древнее найденное рукописное свидетельство
# о языках программирования")

# mus.add_exhibit(p)
# for x in mus.exhibits:
#     print(x.descr)

# P.S. На экран ничего выводить не нужно.


class Museum:

    def __init__(self, name):
        self.name = name
        self.exhibits = []

    def add_exhibit(self, obj):
        self.exhibits.append(obj)

    def remove_exhibit(self, obj):
        self.exhibits.remove(obj)

    def get_info_exhibit(self, indx):
        return f'Описание экспоната {self.exhibits[indx].name}: {self.exhibits[indx].descr}'


class Picture:

    def __init__(self, name, author, descr):
        self.name = name
        self.author = author
        self.descr = descr


class Mummies:

    def __init__(self, name, location, descr):
        self.name = name
        self.location = location
        self.descr = descr


class Papyri:

    def __init__(self, name, date, descr):
        self.name = name
        self.date = date
        self.descr = descr


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Xq19kCDRaag
#
# Подвиг 7 (на повторение). Объявите класс SmartPhone, объекты которого предполагается создавать командой:
#
# sm = SmartPhone(марка смартфона)
# Каждый объект должен содержать локальные атрибуты:
#
# model - марка смартфона (строка);
# apps - список из установленных приложений (изначально пустой).
#
# Также в классе SmartPhone должны быть объявлены следующие методы:
#
# add_app(self, app) - добавление нового приложения на смартфон (в конец списка apps);
# remove_app(self, app) - удаление приложения по ссылке на объект app.
#
# При добавлении нового приложения проверять, что оно отсутствует в списке apps (отсутствует объект соответствующего
# класса).
#
# Каждое приложение должно определяться своим классом. Для примера объявите следующие классы:
#
# AppVK - класс приложения ВКонтаке;
# AppYouTube - класс приложения YouTube;
# AppPhone - класс приложения телефона.
#
# Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):
#
# app_1 = AppVK() # name = "ВКонтакте"
# app_2 = AppYouTube(1024) # name = "YouTube", memory_max = 1024
# app_3 = AppPhone({"Балакирев": 1234567890, "Сергей": 98450647365, "Работа": 112}) # name = "Phone",
# phone_list = словарь с контактами

# Пример использования классов (в программе эти строчки не писать):
#
# sm = SmartPhone("Honor 1.0")
# sm.add_app(AppVK())
# sm.add_app(AppVK())  # второй раз добавляться не должно
# sm.add_app(AppYouTube(2048))
# for a in sm.apps:
#     print(a.name)
# P.S. На экран ничего выводить не нужно.


class SmartPhone:

    def __init__(self, model):
        self.model = model
        self.apps = []

    def add_app(self, app):
        if len(tuple(filter(lambda x: type(x) == type(app), self.apps))) == 0:
            self.apps.append(app)

    def remove_app(self, app):
        self.apps.remove(app)


class AppVK:

    def __init__(self):
        self.name = 'Вконтакте'


class AppYouTube:

    def __init__(self, memory_max):
        self.name = 'YouTube'
        self.memory_max = memory_max


class AppPhone:

    def __init__(self, phone_list):
        self.name = 'Phone'
        self.phone_list = phone_list


# Второе решение___________________________________________________

class SmartPhone:
    def __init__(self, model):
        self.model, self.apps = model, []
    def add_app(self, app):
        if app.__class__ not in (i.__class__ for i in self.apps):
            self.apps.append(app)
    def remove_app(self, app):
        self.apps.remove(app) if app in self.apps else ...

class AppVK:
    def __init__(self, name = "ВКонтакте"):
        self.name = name
class AppYouTube:
    def __init__(self, memory_max, name = "YouTube"):
        self.name, self.memory_max = name, memory_max
class AppPhone:
    def __init__(self, phone_list: dict, name = "Phone"):
        self.name, self.phone_list = name, phone_list


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/vOh4gzHnMWg
#
# Подвиг 8. Объявите класс Circle (окружность), объекты которого должны создаваться командой:
#
# circle = Circle(x, y, radius)   # x, y - координаты центра окружности; radius - радиус окружности
# В каждом объекте класса Circle должны формироваться локальные приватные атрибуты:
#
# __x, __y - координаты центра окружности (вещественные или целые числа);
# __radius - радиус окружности (вещественное или целое положительное число).
#
# Для доступа к этим приватным атрибутам в классе Circle следует объявить объекты-свойства (property):
#
# x, y - для изменения и доступа к значениям __x, __y, соответственно;
# radius - для изменения и доступа к значению __radius.
#
# При изменении значений приватных атрибутов через объекты-свойства нужно проверять, что присваиваемые
# значения - числа (целые или вещественные). Дополнительно у радиуса проверять, что число должно быть
# положительным (строго больше нуля). Сделать все эти проверки нужно через магические методы.
# При некорректных переданных числовых значениях, прежние значения меняться не должны (исключений
# никаких генерировать при этом не нужно).
#
# Если присваиваемое значение не числовое, то генерировать исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# При обращении к несуществующему атрибуту объектов класса Circle выдавать булево значение False.
#
# Пример использования класса (эти строчки в программе писать не нужно):
#
# circle = Circle(10.5, 7, 22)
# circle.radius = -10 # прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
# x, y = circle.x, circle.y
# res = circle.name # False, т.к. атрибут name не существует
# P.S. На экран ничего выводить не нужно.


class Circle:
    attrs = {'x': (int, float), 'y': (int, float), 'radius': (int, float)}

    def __init__(self, x, y, radius):
        self.__x = self.__y = self.__radius = None
        self.x = x
        self.y = y
        self.radius = radius

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        self.__x = x

    @property
    def y(self):
        return self.__y

    @y.setter
    def y(self, y):
        self.__y = y

    @property
    def radius(self):
        return self.__radius

    @radius.setter
    def radius(self, radius):
        self.__radius = radius

    def __getattr__(self, item):
        return False

    def __setattr__(self, key, value):
        if key in self.attrs and type(value) not in self.attrs[key]:
            raise TypeError("Неверный тип присваиваемых данных.")
        if key == 'radius' and value < 0:
            return
        super().__setattr__(key, value)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/2iS8qnEK9to
#
# Подвиг 9. Объявите в программе класс Dimensions (габариты) с атрибутами:
#
# MIN_DIMENSION = 10
# MAX_DIMENSION = 1000
#
# Каждый объект класса Dimensions должен создаваться командой:
#
# d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
# и содержать локальные атрибуты:
#
# __a, __b, __c - габаритные размеры (целые или вещественные числа).
#
# Для работы с этими локальными атрибутами в классе Dimensions следует прописать следующие объекты-свойства:
#
# a, b, c - для изменения и считывания соответствующих локальных атрибутов __a, __b, __c.
#
# При изменении значений __a, __b, __c следует проверять, что присваиваемое значение число в диапазоне [MIN_DIMENSION; MAX_DIMENSION]. Если это не так, то новое значение не присваивается (игнорируется).
#
# С помощью магических методов данного занятия запретить создание локальных атрибутов MIN_DIMENSION и MAX_DIMENSION в объектах класса Dimensions. При попытке это сделать генерировать исключение:
#
# raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
# Пример использования класса  (эти строчки в программе писать не нужно):
#
# d = Dimensions(10.5, 20.1, 30)
# d.a = 8
# d.b = 15
# a, b, c = d.a, d.b, d.c  # a=10.5, b=15, c=30
# d.MAX_DIMENSION = 10  # исключение AttributeError
# P.S. В программе нужно объявить только класс Dimensions. На экран ничего выводить не нужно.


class Dimensions:
    MIN_DIMENSION = 10
    MAX_DIMENSION = 1000

    def __init__(self, a, b, c):
        self.__a = self.__b = self.__c = None
        self.a = a
        self.b = b
        self.c = c

    @property
    def a(self):
        return self.__a

    @a.setter
    def a(self, value):
        if self.__verify_value(value):
            self.__a = value

    @property
    def b(self):
        return self.__b

    @b.setter
    def b(self, value):
        if self.__verify_value(value):
            self.__b = value

    @property
    def c(self):
        return self.__c

    @c.setter
    def c(self, value):
        if self.__verify_value(value):
            self.__c = value

    @classmethod
    def __verify_value(cls, value):
        return type(value) in (int, float) and cls.MIN_DIMENSION <= value <= cls.MAX_DIMENSION


    def __setattr__(self, key, value):
        if key in ('MIN_DIMENSION', 'MAX_DIMENSION'):
            raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
        super().__setattr__(key, value)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/FaHqn8Yr45o
#
# Подвиг 10. Объявите класс GeyserClassic - фильтр для очистки воды. В этом классе должно быть три слота для фильтров.
# Каждый слот строго для своего класса фильтра:
#
# Mechanical - для очистки от крупных механических частиц;
# Aragon - для последующей очистки воды;
# Calcium - для обработки воды на третьем этапе.
#
#
#
# Объекты классов фильтров должны создаваться командами:
#
# filter_1 = Mechanical(дата установки)
# filter_2 = Aragon(дата установки)
# filter_3 = Calcium(дата установки)
# Во всех объектах этих классов должен формироваться локальный атрибут:
#
# date - дата установки фильтров (для простоты - положительное вещественное число).
#
# Также нужно запретить изменение этого атрибута после создания объектов этих классов (только чтение). В случае
# присвоения нового значения, прежнее значение не менять. Ошибок никаких не генерировать.
#
# Объекты класса GeyserClassic должны создаваться командой:
#
# g = GeyserClassic()
# А сам класс иметь атрибут:
#
# MAX_DATE_FILTER = 100 - максимальное время работы фильтра (любого)
#
# и следующие методы:
#
# add_filter(self, slot_num, filter) - добавление фильтра filter в указанный слот slot_num (номер слота: 1, 2 и 3),
# если он (слот) пустой (без фильтра). Также здесь следует проверять, что в первый слот можно установить только
# объекты класса Mechanical, во второй - объекты класса Aragon и в третий - объекты класса Calcium. Иначе слот
# должен оставаться пустым.
#
# remove_filter(self, slot_num) - извлечение фильтра из указанного слота (slot_num: 1, 2, и 3);
#
# get_filters(self) - возвращает кортеж из набора трех фильтров в порядке их установки (по возрастанию номеров слотов);
#
# water_on(self) - включение воды: возвращает True, если вода течет и False - в противном случае.
#
# Метод water_on() должен возвращать значение True при выполнении следующих условий:
#
# - все три фильтра установлены в слотах;
# - все фильтры работают в пределах срока службы (значение (time.time() - date) должно быть
# в пределах [0; MAX_DATE_FILTER])
#
# Пример использования классов  (эти строчки в программе писать не нужно):
#
# my_water = GeyserClassic()
# my_water.add_filter(1, Mechanical(time.time()))
# my_water.add_filter(2, Aragon(time.time()))
# w = my_water.water_on() # False
# my_water.add_filter(3, Calcium(time.time()))
# w = my_water.water_on() # True
# f1, f2, f3 = my_water.get_filters()  # f1, f2, f3 - ссылки на соответствующие объекты классов фильтров
# my_water.add_filter(3, Calcium(time.time())) # повторное добавление в занятый слот невозможно
# my_water.add_filter(2, Calcium(time.time())) # добавление в "чужой" слот также невозможно
# P.S. На экран ничего выводить не нужно.
import time

class GeyserClassic:
    MAX_DATE_FILTER = 100

    def __init__(self):
        self.filter_class = ('Mechanical', 'Aragon', 'Calcium')
        # self.filters = {(1, self.filter_class[0]): None, (2, self.filter_class[1]): None,
        #                 (3, self.filter_class[2]): None}
        self.filters = {(key + 1, self.filter_class[key]): None for key in range(3)}

    def add_filter(self, slot_num, filter):
        key = (slot_num, filter.__class__.__name__)
        if key in self.filters and not self.filters[key]:
            self.filters[key] = filter

    def remove_filter(self, slot_num):
        if type(slot_num) == int and 1 <= slot_num <= 3:
            key = (slot_num, self.filter_class[slot_num - 1])
            if key in self.filters:
                self.filters[key] = None

    def get_filters(self):
        return tuple(self.filters.values())

    def water_on(self):
        end = time.time()
        for f in self.filters.values():
            if f is None:
                return False
            start = f.date
            if end - start > self.MAX_DATE_FILTER:
                return False
        return True



class Mechanical:

    def __init__(self, date):
        self.date = date

    def __setattr__(self, key, value):
        if key == 'date' and key in self.__dict__:
            return
        super().__setattr__(key, value)


class Aragon:

    def __init__(self, date):
        self.date = date

    def __setattr__(self, key, value):
        if key == 'date' and key in self.__dict__:
            return
        super().__setattr__(key, value)


class Calcium:

    def __init__(self, date):
        self.date = date

    def __setattr__(self, key, value):
        if key == 'date' and key in self.__dict__:
            return
        super().__setattr__(key, value)


# Второе решение _____________________________________________
import time


class Filter:
    def __init__(self, date) -> None:
        self.date = date

    def __setattr__(self, key, value) -> None:
        if key == 'date' and hasattr(self, key):
            pass
        else:
            object.__setattr__(self, key, value)


class Mechanical(Filter):
    pass


class Aragon(Filter):
    pass


class Calcium(Filter):
    pass


class GeyserClassic:
    MAX_DATE_FILTER = 100
    d = {1: Mechanical, 2: Aragon, 3: Calcium}

    def __init__(self) -> None:
        self.slots = [None] * 3

    def add_filter(self, slot_num, filter):
        if self.d[slot_num] == type(filter):
            self.slots[slot_num - 1] = filter

    def remove_filter(self, slot_num):
        self.slots[slot_num - 1] = None

    def get_filters(self):
        return tuple(self.slots)

    def water_on(self):
        return all([i != None and 0 <= time.time() - i.date <= self.MAX_DATE_FILTER for i in self.slots])


# ======================================================================================================================
# 3.2 Метод __call__. Функторы и классы-декораторы
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что делает магический метод __call__()?
# - позволяет вызывать объекты класса подобно функциям, в котором определен метод __call__()


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/fiYiJWXv-5I
#
# Подвиг 2. Объявите класс RandomPassword для генерации случайных паролей. Объекты этого класса должны создаваться
# командой:
#
# rnd = RandomPassword(psw_chars, min_length, max_length)
# где psw_chars - строка из разрешенных в пароле символов; min_length, max_length - минимальная и максимальная длина
# генерируемых паролей.
#
# Непосредственная генерация одного пароля должна выполняться командой:
#
# psw = rnd()
# где psw - ссылка на строку длиной в диапазоне [min_length; max_length] из случайно выбранных символов
# строки psw_chars.
#
# С помощью генератора списка (list comprehension) создайте список lst_pass из трех сгенерированных паролей объектом rnd
# класса RandomPassword, созданного с параметрами:
#
# min_length = 5
# max_length = 20
# psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"
# P.S. Выводить на экран ничего не нужно, только создать список из паролей.
#
# P.P.S. Дополнительное домашнее задание: попробуйте реализовать этот же функционал с использованием замыканий функций.


from random import randint, choice # функция для генерации целых случайных значений в диапазоне [a; b]

# здесь объявляйте класс RandomPassword
class RandomPassword:

    def __init__(self, psw_chars, min_length, max_length):
        self.psw_chars = psw_chars
        self.min_length = min_length
        self.max_length = max_length

    def __call__(self, *args, **kwargs):
        psw = ''
        len_psw = randint(self.min_length, self.max_length)
        while len(psw) != len_psw:
            psw += choice(self.psw_chars)
        return psw


min_length = 5
max_length = 20
psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"

rnd = RandomPassword(psw_chars, min_length, max_length)

lst_pass = [rnd() for _ in range(3)]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/JIQhCEqb4rU
#
# Подвиг 3. Для последовательной обработки файлов из некоторого списка, например:
#
# filenames = ["boat.jpg", "web.png", "text.txt", "python.doc", "ava.8.jpg", "forest.jpeg", "eq_1.png",
# "eq_2.png", "my.html", "data.shtml"]

# Необходимо объявить класс ImageFileAcceptor, который бы выделял только файлы с указанными расширениями.
#
# Для этого предполагается создавать объекты класса командой:
#
# acceptor = ImageFileAcceptor(extensions)
# где extensions - кортеж с допустимыми расширениями файлов, например: extensions = ('jpg', 'bmp', 'jpeg').
#
# А, затем, использовать объект acceptor в стандартной функции filter языка Python следующим образом:
#
# image_filenames = filter(acceptor, filenames)
# Пример использования класса (эти строчки в программе писать не нужно):
#
# filenames = ["boat.jpg", "web.png", "text.txt", "python.doc", "ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.png"]
# acceptor = ImageFileAcceptor(('jpg', 'bmp', 'jpeg'))
# image_filenames = filter(acceptor, filenames)
# print(list(image_filenames))  # ["boat.jpg", "ava.jpg", "forest.jpeg"]
# P.S. Ваша задача только объявить класс ImageFileAcceptor. На экран ничего выводить не нужно.

class ImageFileAcceptor:

    def __init__(self, extensions):
        self.extensions = extensions

    def __call__(self, name, *args, **kwargs):
        start = name.rfind('.')
        ext = '' if start == -1 else name[start + 1:]
        return ext in self.extensions


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/e1U6SoX1ChI
#
# Подвиг 4. Предположим, мы разрабатываем класс для обработки формы авторизации на стороне сервера. Для этого был создан
# следующий класс с именем LoginForm:

# class LoginForm:
#     def __init__(self, name, validators=None):
#         self.name = name
#         self.validators = validators
#         self.login = ""
#         self.password = ""
#
#     def post(self, request):
#         self.login = request.get('login', "")
#         self.password = request.get('password', "")
#
#     def is_validate(self):
#         if not self.validators:
#             return True
#
#         for v in self.validators:
#             if not v(self.login) or not v(self.password):
#                 return False
#
#         return True

# Здесь name - это заголовок формы (строка); validators - список из валидаторов для проверки корректности поля. В методе
# post параметр request - это словарь с ключами 'login' и 'password' и значениями (строками) для логина и пароля
# соответственно.
#
# Пример использования класса LoginForm (в программе не писать):

# from string import ascii_lowercase, digits
#
# lg = LoginForm("Вход на сайт", validators=[LengthValidator(3, 50), CharsValidator(ascii_lowercase + digits)])
# lg.post({"login": "root", "password": "panda"})
# if lg.is_validate():
#     print("Дальнейшая обработка данных формы")

# Вам необходимо в программе объявить классы валидаторов:
#
# LengthValidator - для проверки длины данных в диапазоне [min_length; max_length];
# CharsValidator - для проверки допустимых символов в строке.
#
# Объекты этих классов должны создаваться командами:
#
# lv = LengthValidator(min_length, max_length) # min_length - минимально допустимая длина; max_length - максимально
# допустимая длина
# cv = CharsValidator(chars) # chars - строка из допустимых символов
# Для проверки корректности данных каждый валидатор должен вызываться как функция:
#
# res = lv(string)
# res = cv(string)
# и возвращать True, если string удовлетворяет условиям валидатора и False - в противном случае.
#
# P.S. В программе следует только объявить два класса валидаторов, на экран выводить ничего не нужно.


class LoginForm:
    def __init__(self, name, validators=None):
        self.name = name
        self.validators = validators
        self.login = ""
        self.password = ""

    def post(self, request):
        self.login = request.get('login', "")
        self.password = request.get('password', "")

    def is_validate(self):
        if not self.validators:
            return True

        for v in self.validators:
            if not v(self.login) or not v(self.password):
                return False

        return True


class LengthValidator:

    def __init__(self, min_length, max_length):
        self.min_length = min_length
        self.max_length = max_length

    def __call__(self, value, *args, **kwargs):
        return self.min_length <= len(value) <= self.max_length

class CharsValidator:

    def __init__(self, chars):
        self.chars = chars

    def __call__(self, value, *args, **kwargs):
        for i in value:
            if i not in self.chars:
                return False
        return True


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YYUPa-0IeQU
#
# Подвиг 5. Объявите класс DigitRetrieve для преобразования данных из строки в числа. Объекты этого класса создаются
# командой:
#
# dg = DigitRetrieve()
# Затем, их предполагается использовать, например следующим образом:
#
# d1 = dg("123")   # 123 (целое число)
# d2 = dg("45.54")   # None (не целое число)
# d3 = dg("-56")   # -56 (целое число)
# d4 = dg("12fg")  # None (не целое число)
# d5 = dg("abc")   # None (не целое число)
# То есть, целые числа в строке следует приводить к целочисленному типу данных, а все остальные - к значению None.
#
# С помощью объектов класса DigitRetrieve должно выполняться преобразование чисел из списка строк следующим образом:
#
# st = ["123", "abc", "-56.4", "0", "-5"]
# digits = list(map(dg, st))  # [123, None, None, 0, -5]
# P.S. На экран ничего выводить не нужно.

class DigitRetrieve:

    def __call__(self, value, *args, **kwargs):
        try:
            return int(value)
        except ValueError:
            return None


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/wp4CyhdXcbY
#
# Подвиг 6. Предположим, вам необходимо создать программу по преобразованию списка строк, например:
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# в следующий фрагмент HTML-разметки (многострочной строки, кавычки выводить не нужно):
#
# '''<ul>
# <li>Пункт меню 1</li>
# <li>Пункт меню 2</li>
# <li>Пункт меню 3</li>
# </ul>'''
#
# Для этого необходимо объявить класс RenderList, объекты которого создаются командой:
#
# render = RenderList(type_list)
# где type_list - тип списка (принимает значения: "ul" - для списка с тегом <ul> и "ol" - для списка с тегом <ol>).
# Если значение параметра type_list другое (не "ul" и не "ol"), то формируется список с тегом <ul>.
#
# Затем, предполагается использовать объект render следующим образом:
#
# html = render(lst) # возвращается многострочная строка с соответствующей HTML-разметкой
# Пример использования класса (эти строчки в программе писать не нужно):
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# render = RenderList("ol")
# html = render(lst)
# P.S. На экран ничего выводить не нужно.


class RenderList:

    def __init__(self, type_list = 'ul'):
        self.type_list = type_list


    def __call__(self, lst, *args, **kwargs):
        res = f'<{self.type_list}>\n'
        for i in lst:
            res += f'<li>{i}</li>\n'
        res += f'</{self.type_list}>'
        return res


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Ac0s64-XEdE
#
# Подвиг 7. Необходимо объявить класс-декоратор с именем HandlerGET, который будет имитировать обработку GET-запросов
# на стороне сервера. Для этого сам класс HandlerGET нужно оформить так, чтобы его можно было применять к любой функции
# как декоратор. Например:
#
# @HandlerGET
# def contact(request):
#     return "Сергей Балакирев"
# Здесь request - это произвольный словарь с данными текущего запроса, например,
# такой: {"method": "GET", "url": "contact.html"}. А функция должна возвращать строку.
#
# Затем, при вызове декорированной функции:
#
# res = contact({"method": "GET", "url": "contact.html"})
# должна возвращаться строка в формате:
#
# "GET: <данные из функции>"
#
# В нашем примере - это будет:
#
# "GET: Сергей Балакирев"
#
# Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если же ключ method
# принимает другое значение, например, "POST", то декорированная функция contact должна возвращать значение None.
#
# Для реализации имитации GET-запроса в классе HandlerGET следует объявить вспомогательный метод со следующей сигнатурой:
#
# def get(self, func, request, *args, **kwargs): ...
# Здесь func - ссылка на декорируемую функцию; request - словарь с переданными данными при вызове декорированной
# функции. Именно в этом методе следует формировать возвращаемую строку в указанном формате:
#
# "GET: Сергей Балакирев"
#
# P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.


class HandlerGET:

    def __init__(self, func):
        self.func = func

    def __call__(self, request, *args, **kwargs):
        m = request.get('method', 'GET')
        if m == 'GET':
            return self.get(self.func, request)
        return None

    def get(self, func, request, *args, **kwargs):
        return f'GET:{func(request)}'


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/FyL9RyFGGCo
#
# Подвиг 8 (развитие подвига 7). Необходимо объявить класс-декоратор с именем Handler, который можно было бы применять
# к функциям следующим образом:
#
# @Handler(methods=('GET', 'POST')) # по умолчанию methods = ('GET',)
# def contact(request):
#     return "Сергей Балакирев"
# Здесь аргумент methods декоратора Handler содержит список разрешенных запросов для обработки. Сама декорированная
# функция вызывается по аналогии с предыдущим подвигом:
#
# res = contact({"method": "POST", "url": "contact.html"})
# В результате функция contact должна возвращать строку в формате:
#
# "<метод>: <данные из функции>"
#
# В нашем примере - это будет:
#
# "POST: Сергей Балакирев"
#
# Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если ключ method
# принимает значение отсутствующее в списке methods декоратора Handler, например, "PUT", то декорированная функция
# contact должна возвращать значение None.
#
# Для имитации GET и POST-запросов в классе Handler необходимо объявить два вспомогательных метода с сигнатурами:
#
# def get(self, func, request, *args, **kwargs) - для имитации обработки GET-запроса
# def post(self, func, request, *args, **kwargs) - для имитации обработки POST-запроса
#
# В зависимости от типа запроса должен вызываться соответствующий метод (его выбор в классе можно реализовать
# методом __getattribute__()). На выходе эти методы должны формировать строки в заданном формате.
#
# P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.
#
# Небольшая справка
# Для реализации декоратора с параметрами на уровне класса в инициализаторе __init__(self, methods) прописываем
# параметр для декоратора, а магический метод __call__() объявляем как полноценный декоратор на уровне функции,
# например:
#
# class Handler:
#     def __init__(self, methods):
#         # здесь нужные строчки
#
#     def __call__(self, func):
#         def wrapper(request, *args, **kwargs):
#             # здесь нужные строчки
#         return wrapper


class Handler:

    def __init__(self, methods = ('GET',)):
        self.__methods = methods

    def __call__(self, func, *args, **kwargs):
        def wrapper(request):
            m = request.get('method', 'GET')
            if m in self.__methods:
                method = m.lower()
                return self.__getattribute__(method)(func, request)
        return wrapper


    def get(self, func, request, *args, **kwargs):
        return f'GET: {func(request)}'

    def post(self, func, request, *args, **kwargs):
        return f'POST: {func(request)}'


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/EEzEodYvoXc
#
# Подвиг 9. Объявите класс-декоратор InputDigits для декорирования стандартной функции input так, чтобы при вводе
# строки из целых чисел, записанных через пробел, например:
#
# "12 -5 10 83"
#
# на выходе возвращался список из целых чисел:
#
# [12, -5, 10, 83]
#
# Назовите декорированную функцию input_dg и вызовите ее командой:
#
# res = input_dg()
# P.S. На экран ничего выводить не нужно.

class InputDigits:

    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return list(map(int, self.func.split()))

input_dg = InputDigits(input())
res = input_dg()


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/H4cJ0fBVHpc
#
# Подвиг 10 (развитие подвига 9). Объявите класс-декоратор InputValues с параметром render - функция или объект для
# преобразования данных из строк в другой тип данных. Чтобы реализовать такой декоратор в инициализаторе __init__() следует указать параметр render, а магический метод __call__() определяется как функция-декоратор:
#
# class InputValues:
#     def __init__(self, render):     # render - ссылка на функцию или объект для преобразования
#         # здесь строчки программы
#
#     def __call__(self, func):     # func - ссылка на декорируемую функцию
#         def wrapper(*args, **kwargs):
#             # здесь строчки программы
#         return wrapper
# В качестве рендера объявите класс с именем RenderDigit, который бы преобразовывал строковые данные в целые числа.
# Объекты этого класса создаются командой:
#
# render = RenderDigit()
# и применяются следующим образом:
#
# d1 = render("123")   # 123 (целое число)
# d2 = render("45.54")   # None (не целое число)
# d3 = render("-56")   # -56 (целое число)
# d4 = render("12fg")  # None (не целое число)
# d5 = render("abc")   # None (не целое число)
# Декорируйте стандартную функцию input декоратором InputValues и объектом рендера класса RenderDigit так, чтобы на
# выходе при вводе целых чисел через пробел возвращался список из введенных значений. А на месте не целочисленных
# данных - значение None.
#
# Например, при вводе строки:
#
# "1 -5.3 0.34 abc 45f -5"
#
# должен возвращаться список:
#
# [1, None, None, None, None, -5]
#
# Назовите декорированную функцию input_dg и вызовите ее командой:
#
# res = input_dg()
# Выведите результат res на экран.


class InputValues:

    def __init__(self, render):
        self.render = render

    def __call__(self, func, *args, **kwargs):
        def wrapper(*args, **kwargs):
            res = [self.render()(i) for i in func().split()]
            return res

        return wrapper


class RenderDigit:

    def __call__(self, value, *args, **kwargs):
        try:
            if '.' in value:
                return None
            return int(value)
        except:
            return None


input_dg = InputValues(RenderDigit)(input)
res = input_dg()
print(res)


# Второй вариант ______________________________________________________
class InputValues:
    def __init__(self, render):
        self.render = render

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            return list(map(self.render, func().split()))
        return wrapper


class RenderDigit:
    def __call__(self, string):
        if string[0] == '-' and string[1:].isdigit() or string.isdigit():
            return int(string)


@InputValues(RenderDigit())
def input_dg():
    return input()


print(input_dg())


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.3 Магические методы __str__, __repr__, __len__, __abs__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Каково назначение магических методов __str__ и __repr__?

# - метод __str__ вызывается (если он определен в классе) для вывода информации об объекте класса в консоль с помощью
# функций print() и str()

# - метод __repr__ возвращает строковую информацию об объекте класса для служебного пользования
# (например, в командную строку), а также может использоваться, если не определен метод __str__


# ----------------------------------------------------------------------------------------------------------------------

# Подвиг 2. Объявите класс с именем Book (книга), объекты которого создаются командой:
#
# book = Book(title, author, pages)
# где title - название книги (строка); author - автор книги (строка); pages - число страниц в книге (целое число).
#
# Также при выводе информации об объекте на экран командой:
#
# print(book)
# должна отображаться строчка в формате:
#
# "Книга: {title}; {author}; {pages}"
#
# Например:
#
# "Книга: Муму; Тургенев; 123"
#
# Прочитайте из входного потока строки с информацией по книге командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# (строки идут в порядке: title, author, pages). Создайте объект класса Book и выведите его строковое представление
# в консоль.
#
# Sample Input:
#
# Python ООП
# Балакирев С.М.
# 1024
# Sample Output:
#
# Книга: Python ООП; Балакирев С.М.; 1024
import sys


class Book:

    def __init__(self, *args):
        self.title = args[0]
        self.author = args[1]
        self.pages = args[2]

    def __str__(self):
        return f'Книга: {self.title}; {self.author}; {self.pages}'


lst_in = list(map(str.strip, sys.stdin.readlines()))

book = Book(*lst_in)
print(book)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Объявите класс с именем Model, объекты которого создаются командой:
#
# model = Model()
# Объявите в этом классе метод query() для формирования записи базы данных. Использоваться этот метод должен следующим
# образом:
#
# model.query(field_1=value_1, field_2=value_2, ..., field_N=value_N)
#
# Например:
#
# model.query(id=1, fio='Sergey', old=33)
# Все эти переданные данные должны сохраняться внутри объекта model класса Model. Затем, при выполнении команды:
#
# print(model)
# В консоль должна выводиться информация об объекте в формате:
#
# "Model: field_1 = value_1, field_2 = value_2, ..., field_N = value_N"
#
# Например:
#
# "Model: id = 1, fio = Sergey, old = 33"
#
# Если метод query() не вызывался, то в консоль выводится строка:
#
# "Model"
#
# P.S. В программе нужно только объявить класс, выводить в консоль ничего не нужно.


class Model:

    def __init__(self):
        self.d = {}

    def query(self, **kwargs):
        self.d.update(kwargs)

    def __str__(self):
        if self.d:
            res = 'Model: ' + ', '.join([f'{x[0]} = {x[1]}' for x in self.d.items()])
            return res
        return 'Model'


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите класс WordString, объекты которого создаются командами:
#
# w1 = WordString()
# w2 = WordString(string)
# где string - передаваемая строка. Например:
#
# words = WordString("Курс по Python ООП")
# Реализовать следующий функционал для объектов этого класса:
#
# len(words) - должно возвращаться число слов в переданной строке (слова разделяются одним или несколькими пробелами);
# words(indx) - должно возвращаться слово по его индексу (indx - порядковый номер слова в строке, начиная с 0).
#
# Также в классе WordString реализовать объект-свойство (property):
#
# string - для передачи и считывания строки.
#
# Пример пользования классом WordString (эти строчки в программе писать не нужно):
#
# words = WordString()
# words.string = "Курс по Python ООП"
# n = len(words)
# first = "" if n == 0 else words(0)
# print(words.string)
# print(f"Число слов: {n}; первое слово: {first}")
# P.S. В программе нужно только объявить класс, выводить в консоль ничего не нужно.

class WordString:

    def __init__(self, string=''):
        self.__string = string

    def __len__(self):
        return len(self.string.split())

    def __call__(self, indx, *args, **kwargs):
        return self.string.split()[indx]

    @property
    def string(self):
        return self.__string

    @string.setter
    def string(self, value):
        self.__string = value


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/6-xKuQp9b7Y
#
# Теория по двусвязным спискам (при необходимости): https://youtu.be/0sTH9EwXT1I
#
# Подвиг 5. Объявите класс LinkedList (связный список) для работы со следующей структурой данных:

# Здесь создается список из связанных между собой объектов класса ObjList. Объекты этого класса создаются командой:
#
# obj = ObjList(data)
# где data - строка с некоторой информацией. Также в каждом объекте obj класса ObjList должны создаваться следующие
# локальные атрибуты:
#
# __data - ссылка на строку с данными;
# __prev - ссылка на предыдущий объект связного списка (если объекта нет, то __prev = None);
# __next - ссылка на следующий объект связного списка (если объекта нет, то __next = None).
#
# В свою очередь, объекты класса LinkedList должны создаваться командой:
#
# linked_lst = LinkedList()
# и содержать локальные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пуст, то head = None);
# tail - ссылка на последний объект связного списка (если список пуст, то tail = None).
#
# А сам класс содержать следующие методы:
#
# add_obj(obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(indx) - удаление объекта класса ObjList из связного списка по его порядковому номеру (индексу); индекс
# отсчитывается с нуля.
#
# Также с объектами класса LinkedList должны поддерживаться следующие операции:
#
# len(linked_lst) - возвращает число объектов в связном списке;
# linked_lst(indx) - возвращает строку __data, хранящуюся в объекте класса ObjList, расположенного под
# индексом indx (в связном списке).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# linked_lst = LinkedList()
# linked_lst.add_obj(ObjList("Sergey"))
# linked_lst.add_obj(ObjList("Balakirev"))
# linked_lst.add_obj(ObjList("Python"))
# linked_lst.remove_obj(2)
# linked_lst.add_obj(ObjList("Python ООП"))
# n = len(linked_lst)  # n = 3
# s = linked_lst(1) # s = Balakirev
# P.S. На экран в программе ничего выводить не нужно.


# class ObjValue:
#
#     def __set_name__(self, owner, name):
#         self.name = '_' + name
#
#     def __get__(self, instance, owner):
#         return getattr(instance, self.name)
#
#     def __set__(self, instance, value):
#         setattr(instance, self.name, value)


class ObjList:

    def __init__(self, data):
        self.__data = data
        self.__prev = None
        self.__next = None

    # Setters
    def set_data(self, data):
        self.__data = data

    def set_prev(self, obj):
        self.__prev = obj

    def set_next(self, obj):
        self.__next = obj

    # Getters
    def get_data(self):
        return self.__data

    def get_prev(self):
        return self.__prev

    def get_next(self):
        return self.__next


class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if self.head is None:
            self.head = obj
        if self.tail is None:
            self.tail = obj
            self.tail.set_prev(self.head)
            self.head.set_next(obj)
        self.tail.set_next(obj)
        obj.set_prev(self.tail)
        self.tail = obj

    def remove_obj(self, indx):
        if self.head is None:
            return
        if self.tail is None:
            self.head = None
        counter = 0
        ex = self.head
        while counter != indx:
            ex = ex.get_next()
            counter += 1
        if ex == self.tail:
            ex.get_prev().set_next(None)
            self.tail = ex.get_prev()
            return
        ex.get_prev().set_next(ex.get_next())
        ex.get_next().set_prev(ex.get_prev())

    def __len__(self):
        if self.head is None:
            return 0
        res = 1
        ex = self.head
        while ex.get_next() is not None:
            ex = ex.get_next()
            res += 1
        return res

    def __call__(self, indx, *args, **kwargs):
        counter = 0
        ex = self.head
        while counter != indx:
            counter += 1
            ex = ex.get_next()
        return ex.get_data()


# Второй вариант
class ObjList:
    def __init__(self, data):
        self.__data = ''
        self.data = data
        self.__next = self.__prev = None

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, value):
        if type(value) == str:
            self.__data = value

    @property
    def prev(self):
        return self.__prev

    @prev.setter
    def prev(self, obj):
        if type(obj) in (ObjList, type(None)):
            self.__prev = obj

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, obj):
        if type(obj) in (ObjList, type(None)):
            self.__next = obj

class LinkedList:
    def __init__(self):
        self.head = self.tail = None

    def add_obj(self, obj):
        obj.prev = self.tail

        if self.tail:
            self.tail.next = obj
        self.tail = obj

        if not self.head:
            self.head = obj

    def __get_obj_by_index(self, indx):
        h = self.head
        n = 0
        while h and n < indx:
            h = h.next
            n += 1
        return h

    def remove_obj(self, indx):
        obj = self.__get_obj_by_index(indx)
        if obj is None:
            return

        p, n = obj.prev, obj.next
        if p:
            p.next = n
        if n:
            n.prev = p

        if self.head == obj:
            self.head = n
        if self.tail == obj:
            self.tail = p


    def __len__(self):
        n = 0
        h = self.head
        while h:
            n += 1
            h = h.next
        return n

    def __call__(self, indx, *args, **kwargs):
        obj = self.__get_obj_by_index(indx)
        return obj.data if obj else None


# Третий вариант (с дескриптором)
class Desc:
    def __set_name__(self, owner, name):
        self.name = f'_{owner.__name__}__{name}'

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if not self.head:
            self.head = obj
            self.tail = obj
        else:
            self.tail.next = obj
            obj.prev = self.tail
            self.tail = obj

    def remove_obj(self, indx):
        c = 0
        tmp = self.head
        while c != indx:
            c += 1
            tmp = tmp.next

        if tmp.next and tmp.prev:
            tmp.next.prev = tmp.prev
            tmp.prev = tmp.next

        elif tmp == self.head == self.tail:
            self.head = self.tail = None

        elif tmp == self.head:
            tmp.next.prev = None
            self.head = tmp.next

        elif tmp == self.tail:
            tmp.prev.next = None
            self.tail = tmp.prev

    def __len__(self):
        c = 1 if self.head else 0
        tmp = self.head
        while tmp.next:
            c += 1
            tmp = tmp.next
        return c

    def __call__(self, indx):
        c = 0
        tmp = self.head
        while c != indx:
            c += 1
            tmp = tmp.next
        return tmp.data


class ObjList:
    data = Desc()
    prev = Desc()
    next = Desc()

    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/t8KuHjY71-o
#
# Подвиг 6. Объявите класс с именем Complex для представления и работы с комплексными числами. Объекты этого класса
# должны создаваться командой:
#
# cm = Complex(real, img)
# где real - действительная часть комплексного числа (целое или вещественное значение); img - мнимая часть комплексного
# числа (целое или вещественное значение).
#
# Объявите в этом классе следующие объекты-свойства (property):
#
# real - для записи и считывания действительного значения;
# img - для записи и считывания мнимого значения.
#
# При записи новых значений необходимо проверять тип передаваемых данных. Если тип не соответствует целому или
# вещественному числу, то генерировать исключение командой:
#
# raise ValueError("Неверный тип данных.")
# Также с объектами класса Complex должна поддерживаться функция:
#
# res = abs(cm)
# возвращающая модуль комплексного числа (вычисляется по формуле: sqrt(real*real + img*img) - корень квадратный от
# суммы квадратов действительной и мнимой частей комплексного числа).
#
# Создайте объект cmp класса Complex для комплексного числа с real = 7 и img = 8. Затем, через объекты-свойства real и
# img измените эти значения на real = 3 и img = 4. Вычислите модуль полученного комплексного числа (сохраните результат
# в переменной c_abs).
#
# P.S. На экран ничего выводить не нужно.
from math import sqrt

class Complex:
    def __init__(self, real, img):
        self.__real = real
        self.__img = img

    @property
    def real(self):
        return self.__real

    @real.setter
    def real(self, real):
        if type(real) not in (int, float):
            raise ValueError('Неверный тип данных')
        self.__real = real

    @property
    def img(self):
        return self.__img

    @img.setter
    def img(self, img):
        if type(img) not in (int, float):
            raise ValueError('Неверный тип данных')
        self.__img = img

    def __abs__(self):
        return sqrt(self.real ** 2 + self.img ** 2)

cmp = Complex(real=7, img=8)
cmp.real = 3
cmp.img = 4
c_abs = abs(cmp)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/lCYllyv9nVM
#
# Подвиг 7. Объявите класс с именем RadiusVector для описания и работы с n-мерным вектором (у которого n координат).
# Объекты этого класса должны создаваться командами:
#
# # создание 5-мерного радиус-вектора с нулевыми значениями координат (аргумент - целое число больше 1)
# vector = RadiusVector(5)  # координаты: 0, 0, 0, 0, 0
#
# # создание 4-мерного радиус-вектора с координатами: 1, -5, 3.4, 10 (координаты - любые целые или вещественные числа)
# vector = RadiusVector(1, -5, 3.4, 10)
# То есть, при передаче одного значения, оно интерпретируется, как размерность нулевого радиус-вектора. Если же
# передается более одного числового аргумента, то они интерпретируются, как координаты радиус-вектора.
#
# Класс RadiusVector должен содержать методы:
#
# set_coords(coord_1, coord_2, ..., coord_N) - для изменения координат радиус-вектора;
# get_coords() - для получения текущих координат радиус-вектора (в виде кортежа).
#
# Также с объектами класса RadiusVector должны поддерживаться следующие функции:
#
# len(vector) - возвращает число координат радиус-вектора (его размерность);
# abs(vector) - возвращает длину радиус-вектора (вычисляется как:
# sqrt(coord_1*coord_1 + coord_2*coord_2 + ... + coord_N*coord_N) - корень квадратный из суммы квадратов координат).
#
# Пример использования класса RadiusVector (эти строчки в программе писать не нужно):
#
# vector3D = RadiusVector(3)
# vector3D.set_coords(3, -5.6, 8)
# a, b, c = vector3D.get_coords()
# vector3D.set_coords(3, -5.6, 8, 10, 11) # ошибки быть не должно, последние две координаты игнорируются
# vector3D.set_coords(1, 2) # ошибки быть не должно, меняются только первые две координаты
# res_len = len(vector3D) # res_len = 3
# res_abs = abs(vector3D)
# P.S. На экран ничего выводить не нужно, только объявить класс RadiusVector.

from math import sqrt


class RadiusVector:
    def __init__(self, *args):
        if len(args) == 1:
            self.__coords = [0] * args[0]
        else:
            self.__coords = list(args)

    def set_coords(self, *args):
        self.__coords[:len(args)] = args[:]

    def get_coords(self):
        return tuple(self.__coords)

    def __len__(self):
        return len(self.__coords)

    def __abs__(self):
        if self.__len__() == 0:
            return 0
        return sqrt(sum([x ** 2 for x in self.get_coords()]))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/V7SV1pOWyEY
#
# Подвиг 8. Объявите класс DeltaClock для вычисления разницы времен. Объекты этого класса должны создаваться командой:
#
# dt = DeltaClock(clock1, clock2)
# где clock1, clock2 - объекты другого класса Clock для хранения текущего времени. Эти объекты должны создаваться
# командой:
#
# clock = Clock(hours, minutes, seconds)
# где hours, minutes, seconds - часы, минуты, секунды (целые неотрицательные числа).
#
# В классе Clock также должен быть (по крайней мере) один метод (возможны и другие):
#
# get_time() - возвращает текущее время в секундах (то есть, значение hours * 3600 + minutes * 60 + seconds).
#
# После создания объекта dt класса DeltaClock, с ним должны выполняться команды:
#
# str_dt = str(dt)   # возвращает строку разницы времен clock1 - clock2 в формате: часы: минуты: секунды
# len_dt = len(dt)   # разницу времен clock1 - clock2 в секундах (целое число)
# print(dt)   # отображает строку разницы времен clock1 - clock2 в формате: часы: минуты: секунды
# Если разность получается отрицательной, то разницу времен считать нулевой.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# dt = DeltaClock(Clock(2, 45, 0), Clock(1, 15, 0))
# print(dt) # 01: 30: 00
# len_dt = len(dt) # 5400
# Обратите внимание, добавляется незначащий ноль, если число меньше 10.
#
# P.S. На экран ничего выводить не нужно, только объявить классы.


class Clock:

    def __init__(self, hours, minutes, seconds):
        self.hours = hours
        self.minutes = minutes
        self.seconds = seconds

    def get_time(self):
        return self.hours * 3600 + self.minutes * 60 + self.seconds


class DeltaClock:

    def __init__(self, clock1, clock2):
        self.clock1 = clock1
        self.clock2 = clock2

    def diff_time(self):
        res = self.clock1.get_time() - self.clock2.get_time()
        if res <= 0:
            return 0
        return res

    def __str__(self):
        h = self.diff_time() // 3600
        m = (self.diff_time() - h * 3600) // 60
        s = (self.diff_time() - h * 3600 - m * 60)
        return f'{h if h >= 10 else "0" + str(h)}: {m if m >= 10 else "0" + str(m)}: {s if s >= 10 else "0" + str(s)}'

    def __len__(self):
        return self.diff_time()


# Второй вариант
import time


class Clock:
    def __init__(self, hours, minutes, seconds):
        self.__hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def get_time(self):
        return self.__hours * 3600 + self.__minutes * 60 + self.__seconds


class DeltaClock:
    def __init__(self, clock1: Clock, clock2: Clock):
        self.clock1 = clock1
        self.clock2 = clock2

    def __len__(self):
        diff = self.clock1.get_time() - self.clock2.get_time()
        if diff > 0:
            return diff
        return 0

    def __str__(self):
        return time.strftime("%H: %M: %S", time.gmtime(len(self)))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9. Объявите класс Recipe для представления рецептов. Отдельные ингредиенты рецепта должны определяться
# классом Ingredient. Объекты этих классов должны создаваться командами:
#
# ing = Ingredient(name, volume, measure)
# recipe = Recipe()
# recipe = Recipe(ing_1, ing_2,..., ing_N)
# где ing_1, ing_2,..., ing_N - объекты класса Ingredient.
#
# В каждом объекте класса Ingredient должны создаваться локальные атрибуты:
#
# name - название ингредиента (строка);
# volume - объем ингредиента в рецепте (вещественное число);
# measure - единица измерения объема ингредиента (строка), например, литр, чайная ложка, грамм, штук и т.д.;
#
# С объектами класса Ingredient должна работать функция:
#
# str(ing)  # название: объем, ед. изм.
# и возвращать строковое представление объекта в формате:
#
# "название: объем, ед. изм."
#
# Например:
#
# ing = Ingredient("Соль", 1, "столовая ложка")
# s = str(ing) # Соль: 1, столовая ложка
# Класс Recipe должен иметь следующие методы:
#
# add_ingredient(ing) - добавление нового ингредиента ing (объект класса Ingredient) в рецепт (в конец);
# remove_ingredient(ing) - удаление ингредиента по объекту ing (объект класса Ingredient) из рецепта;
# get_ingredients() - получение кортежа из объектов класса Ingredient текущего рецепта.
#
# Также с объектами класса Recipe должна поддерживаться функция:
#
# len(recipe) - возвращает число ингредиентов в рецепте.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# recipe = Recipe()
# recipe.add_ingredient(Ingredient("Соль", 1, "столовая ложка"))
# recipe.add_ingredient(Ingredient("Мука", 1, "кг"))
# recipe.add_ingredient(Ingredient("Мясо баранины", 10, "кг"))
# ings = recipe.get_ingredients()
# n = len(recipe) # n = 3
# P.S. На экран ничего выводить не нужно, только объявить классы.


class Recipe:

    def __init__(self, *args):
        self.ings = []
        if args:
            for i in args:
                self.ings.append(i)

    def add_ingredient(self, ing):
        self.ings.append(ing)

    def remove_ingredient(self, ing):
        self.ings.remove(ing)

    def get_ingredients(self):
        return tuple(self.ings)

    def __len__(self):
        return len(self.ings)


class Ingredient:

    def __init__(self, name, volume, measure):
        self.name = name
        self.volume = volume
        self.measure = measure

    def __str__(self):
        return f"{self.name}: {self.volume}, {self.measure}"


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение). Объявите класс PolyLine (полилиния) для представления линии из последовательности
# прямолинейных сегментов. Объекты этого класса должны создаваться командой:
#
# poly = PolyLine(start_coord, coord_2, coord_3, ..., coord_N)
# Здесь start_coord - координата начала полилинии (кортеж из двух чисел x, y); coord_2, coord_3, ... - последующие
# координаты точек на плоскости (представленные кортежами), соединенных прямыми линиями.
#
# Например:
#
# poly = PolyLine((1, 2), (3, 5), (0, 10), (-1, 8))

# В классе PolyLine должны быть объявлены следующие методы:
#
# add_coord(x, y) - добавление новой координаты (в конец);
# remove_coord(indx) - удаление координаты по индексу (порядковому номеру, начинается с нуля);
# get_coords() - получение списка координат (в виде списка из кортежей).
#
# P.S. На экран ничего выводить не нужно, только объявить класс.


class PolyLine:

    def __init__(self, *args):
        self.coords = list(args)

    def add_coord(self, x, y):
        self.coords.append((x, y))

    def remove_coord(self, indx):
        del self.coords[indx]

    def get_coords(self):
        return self.coords


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.4 Методы __add__, __sub__, __mul__, __truediv__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствие между магическими методами классов и их описаниями.

# - __add__() - для реализации оператора сложения +
# - __sub__() - для реализации оператора вычитания -
# - __mul__() - для реализации оператора умножения *
# - __truediv__() - для реализации оператора деления /
# - __floordiv__() - для реализации оператора целочисленного деления //
# - __mod__() - для реализации оператора вычисления целого остатка от деления %


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе определен следующий класс:
#
# class Way:
#     def __init__(self, length):
#         self.length = length
#
#     def __add__(self, other):
#         return Way(self.length + other.length)
# И создаются два объекта:
#
# w1 = Way(5)
# w2 = Way(10)
# Выберите все верные строчки программы при работе с объектами w1 и w2 (те, что не приводят к ошибкам во время
# выполнения).

# - w = w1 + w2
# - w = w1 + w2 + w1
# - w1 += w2


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен класс Way с магическими методами __add__(), __radd__() и __iadd__() и два его
# объекта:
#
# w1 = Way(5)
# w2 = Way(10)
# Причем магические методы реализованы так, что эти объекты можно складывать и между собой и с числами:
#
# w1 + w2
# w1 + 10

# Выберите верные формулировки, описывающие магические методы __add__(), __radd__() и __iadd__().

# - метод __add__() используется для оператора += (пример: w1 += w2), если отсутствует метод __iadd__()
# - метод __add__() служит для реализации бинарного оператора сложения (пример: w1 + w2)
# - метод __iadd__() используется для оператора += (пример: w1 += w2) и не может быть использован
# для оператора + (пример: w1 + w2)
# - метод __radd__() используется для реализации оператора +, относительно правого
# операнда (объекта класса Way); пример: w = 10 + w1


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/tkjqkiCSnqM
#
# Подвиг 4. Известно, что в Python мы можем соединять два списка между собой с помощью оператора +:
#
# lst = [1, 2, 3] + [4.5, -3.6, 0.78]
# Но нет реализации оператора -, который бы убирал из списка соответствующие значения вычитаемого списка, как это
# показано в примере:
#
# lst = [1, 2, 3, 4, 5, 6] - [5, 6, 7, 8, 1] # [2, 3, 4] (порядок следования оставшихся элементов списка должен
# сохраняться)
# Давайте это поправим и создадим такой функционал. Для этого нужно объявить класс с именем NewList, объекты
# которого создаются командами:
#
# lst = NewList() # пустой список
# lst = NewList([-1, 0, 7.56, True]) # список с начальными значениями
# Реализуйте для этого класса работу с оператором вычитания, чтобы над объектами класса NewList можно было выполнять
# следующие действия:
#
# lst1 = NewList([1, 2, -4, 6, 10, 11, 15, False, True])
# lst2 = NewList([0, 1, 2, 3, True])
# res_1 = lst1 - lst2 # NewList: [-4, 6, 10, 11, 15, False]
# lst1 -= lst2 # NewList: [-4, 6, 10, 11, 15, False]
# res_2 = lst2 - [0, True] # NewList: [1, 2, 3]
# res_3 = [1, 2, 3, 4.5] - res_2 # NewList: [4.5]
# a = NewList([2, 3])
# res_4 = [1, 2, 2, 3] - a # NewList: [1, 2]
# Также в классе NewList необходимо объявить метод:
#
# get_list() - для возвращения результирующего списка объекта класса NewList
#
# Например:
#
# lst = res_2.get_list() # [1, 2, 3]
# P.S. В программе требуется только объявить класс. На экран ничего выводить не нужно.


class NewList:

    def __init__(self, lst=None):
        self._lst = lst[:] if lst and type(lst) == list else []

    def get_list(self):
        return self._lst

    def __sub__(self, other):
        if type(other) not in (list, NewList):
            raise ArithmeticError('Правый операнд должен иметь тип жшые или NewList')
        other_list = other if type(other) == list else other.get_list()
        return NewList(self.__diff_list(self._lst, other_list))

    def __rsub__(self, other):
        if type(other) != list:
            raise ArithmeticError('Правый операнд должен иметь тип List')
        return NewList(self.__diff_list(other, self._lst))

    @staticmethod
    def __diff_list(lst1, lst2):
        if len(lst2) == 0:
            return lst1
        sub = lst2[:]
        return [x for x in lst1 if not NewList.__is_elem(x, sub)]

    @staticmethod
    def __is_elem(x, sub):
        res = any(map(lambda xx: type(x) == type(xx) and x == xx, sub))
        if res:
            sub.remove(x)
        return res


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0Poea079PSs
#
# Подвиг 5. Объявите класс с именем ListMath, объекты которого можно создавать командами:
#
# lst1 = ListMath() # пустой список
# lst2 = ListMath([1, 2, -5, 7.68]) # список с начальными значениями
# В качестве значений элементов списка объекты класса ListMath должны отбирать только целые и вещественные числа,
# остальные игнорировать (если указываются в списке). Например:
#
# lst = ListMath([1, "abc", -5, 7.68, True]) # ListMath: [1, -5, 7.68]
# В каждом объекте класса ListMath должен быть публичный атрибут:
#
# lst_math - ссылка на текущий список объекта (для каждого объекта создается свой список).
#
# Также с объектами класса ListMath должны работать следующие операторы:
#
# lst = lst + 76 # сложение каждого числа списка с определенным числом
# lst = 6.5 + lst # сложение каждого числа списка с определенным числом
# lst += 76.7  # сложение каждого числа списка с определенным числом
# lst = lst - 76 # вычитание из каждого числа списка определенного числа
# lst = 7.0 - lst # вычитание из числа каждого числа списка
# lst -= 76.3
# lst = lst * 5 # умножение каждого числа списка на указанное число (в данном случае на 5)
# lst = 5 * lst # умножение каждого числа списка на указанное число (в данном случае на 5)
# lst *= 5.54
# lst = lst / 13 # деление каждого числа списка на указанное число (в данном случае на 13)
# lst = 3 / lst # деление числа на каждый элемент списка
# lst /= 13.0
# При использовании бинарных операторов +, -, *, / должны формироваться новые объекты класса ListMath с новыми
# списками, прежние списки не меняются.
#
# При использовании операторов +=, -=, *=, /= значения должны меняться внутри списка текущего объекта (новый
# объект не создается).
#
# P.S. В программе достаточно только объявить класс. На экран ничего выводить не нужно.


class ListMath:

    def __init__(self, lst=None):
        self.lst_math = lst if lst and type(lst) == list else []
        self.lst_math = list(filter(lambda x: type(x) in (int, float), self.lst_math))

    @staticmethod
    def __check_type(value):
        if type(value) not in (int, float):
            raise ('Операнд должен быть числом')

    def __add__(self, other):
        self.__check_type(other)
        return ListMath([i + other for i in self.lst_math])

    def __radd__(self, other):
        return self + other

    def __iadd__(self, other):
        self.__check_type(other)
        self.lst_math = [i + other for i in self.lst_math]
        return self

    def __sub__(self, other):
        self.__check_type(other)
        return ListMath([i - other for i in self.lst_math])

    def __rsub__(self, other):
        return ListMath([other - i for i in self.lst_math])

    def __isub__(self, other):
        self.__check_type(other)
        self.lst_math = [i - other for i in self.lst_math]
        return self

    def __mul__(self, other):
        self.__check_type(other)
        return ListMath([i * other for i in self.lst_math])

    def __rmul__(self, other):
        return self * other

    def __imul__(self, other):
        self.__check_type(other)
        self.lst_math = [i * other for i in self.lst_math]
        return self

    def __truediv__(self, other):
        self.__check_type(other)
        return ListMath([i / other for i in self.lst_math])

    def __rtruediv__(self, other):
        return ListMath([other / i for i in self.lst_math])

    def __itruediv__(self, other):
        self.__check_type(other)
        self.lst_math = [i / other for i in self.lst_math]
        return self


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PY-E4OSh1gM
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 6. Ранее, в одном из подвигов мы с вами создавали односвязный список с объектами класса StackObj (когда один
# объект ссылается на следующий и так далее):


# Давайте снова создадим такую структуру данных. Для этого объявим два класса:
#
# Stack - для управления односвязным списком в целом;
# StackObj - для представления отдельных объектов в односвязным списком.
#
# Объекты класса StackObj должны создаваться командой:
#
# obj = StackObj(data)
# где data - строка с некоторыми данными.
#
# Каждый объект класса StackObj должен иметь локальные приватные атрибуты:
#
# __data - ссылка на строку с переданными данными;
# __next - ссылка на следующий объект односвязного списка (если следующего нет, то __next = None).
#
# Объекты класса Stack создаются командой:
#
# st = Stack()
# и каждый из них должен содержать локальный атрибут:
#
# top - ссылка на первый объект односвязного списка (если объектов нет, то top = None).
#
# Также в классе Stack следует объявить следующие методы:
#
# push_back(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
# pop_back(self) - удаление последнего объекта из односвязного списка.
#
# Дополнительно нужно реализовать следующий функционал (в этих операциях копии односвязного списка создавать не нужно):
#
# # добавление нового объекта класса StackObj в конец односвязного списка st
# st = st + obj
# st += obj
#
# # добавление нескольких объектов в конец односвязного списка
# st = st * ['data_1', 'data_2', ..., 'data_N']
# st *= ['data_1', 'data_2', ..., 'data_N']
# В последних двух строчках должны автоматически создаваться N объектов класса StackObj с данными, взятыми из
# списка (каждый элемент списка для очередного добавляемого объекта).
#
# P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.


class StackObj:

    def __init__(self, data):
        self.__data = data
        self.__next = None

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, obj):
        self.__next = obj

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, data):
        self.__data = data


class Stack:

    def __init__(self):
        self.top = None
        self.__last = None

    def push_back(self, obj):
        if self.__last:
            self.__last.next = obj
        self.__last = obj

        if self.top is None:
            self.top = obj

    def pop_back(self):
        ex = self.top
        if ex is None:
            return

        while ex.next and ex.next != self.__last:
            ex = ex.next

        if self.top == self.__last:
            self.top = self.__last = None
        else:
            ex.next = None
            self.__last = ex

    def __add__(self, other):
        self.push_back(other)
        return self

    def __iadd__(self, other):
        return self.__add__(other)

    def __mul__(self, other):
        for i in other:
            self.push_back(StackObj(i))
        return self

    def __imul__(self, other):
        return self.__mul__(other)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. Вам поручается создать программу по учету книг (библиотеку). Для этого необходимо в программе объявить
# два класса:
#
# Lib - для представления библиотеки в целом;
# Book - для описания отдельной книги.
#
# Объекты класса Book должны создаваться командой:
#
# book = Book(title, author, year)
# где title - заголовок книги (строка); author - автор книги (строка); year - год издания (целое число).
#
# Объекты класса Lib создаются командой:
#
# lib = Lib()
# Каждый объект должен содержать локальный публичный атрибут:
#
# book_list - ссылка на список из книг (объектов класса Book). Изначально список пустой.
#
# Также объекты класса Lib должны работать со следующими операторами:
#
# lib = lib + book # добавление новой книги в библиотеку
# lib += book
#
# lib = lib - book # удаление книги book из библиотеки (удаление происходит по ранее созданному
# объекту book класса Book)
# lib -= book
#
# lib = lib - indx # удаление книги по ее порядковому номеру (индексу: отсчет начинается с нуля)
# lib -= indx
# При реализации бинарных операторов + и - создавать копии библиотек (объекты класса Lib) не нужно.
#
# Также с объектами класса Lib должна работать функция:
#
# n = len(lib) # n - число книг
# которая возвращает число книг в библиотеке.
#
# P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.

class Lib:
    def __init__(self):
        self.book_list = []

    def __len__(self):
        return len(self.book_list)

    def __add__(self, other):
        if not isinstance(other, Book):
            raise TypeError('Операнд справа должен быть экземпляром класса Book')
        self.book_list.append(other)
        return self

    def __sub__(self, other):
        if not isinstance(other, (int, Book)):
            raise TypeError('Операнд справа должен быть int или экземпляром класса Book')
        if isinstance(other, Book):
            self.book_list.remove(other)
        else:
            if other < len(self.book_list):
                del self.book_list[other]
        return self

class Book:
    def __init__(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Вам необходимо создать простую программу по учету семейного бюджета. Для этого в программе объявите два
# класса с именами:
#
# Budget - для управления семейным бюджетом;
# Item - пункт расходов бюджета.
#
# Объекты класса Item должны создаваться командой:
#
# it = Item(name, money)
# где name - название статьи расхода; money - сумма расходов (вещественное или целое число).
#
# Соответственно, в каждом объекте класса Item должны формироваться локальные атрибуты name и money с переданными
# значениями. Также с объектами класса Item должны выполняться следующие операторы:
#
# s = it1 + it2 # сумма для двух статей расходов
# и в общем случае:
#
# s = it1 + it2 + ... + itN # сумма N статей расходов
# При суммировании оператор + должен возвращать число - вычисленную сумму по атрибутам money соответствующих объектов
# класса Item.
#
# Объекты класса Budget создаются командой:
#
# my_budget = Budget()
# А сам класс Budget должен иметь следующие методы:
#
# add_item(self, it) - добавление статьи расхода в бюджет (it - объект класса Item);
# remove_item(self, indx) - удаление статьи расхода из бюджета по его порядковому номеру indx (индексу: отсчитывается
# с нуля);
# get_items(self) - возвращает список всех статей расходов (список из объектов класса Item).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# my_budget = Budget()
# my_budget.add_item(Item("Курс по Python ООП", 2000))
# my_budget.add_item(Item("Курс по Django", 5000.01))
# my_budget.add_item(Item("Курс по NumPy", 0))
# my_budget.add_item(Item("Курс по C++", 1500.10))
#
# # вычисление общих расходов
# s = 0
# for x in my_budget.get_items():
#     s = s + x
# P.S. В программе требуется только объявить класс. На экран ничего выводить не нужно.

class Item:
    def __init__(self, name, money):
        self.name = name
        self.money = money

    def __add__(self, it):
        if isinstance(it, Item):
            return self.money + it.money
        if isinstance(it, (float, int)):
            return self.money + it

    def __radd__(self, it):
        return self + it

class Budget:
    def __init__(self):
        self.items = list()

    def add_item(self, it):
        if isinstance(it, Item):
            self.items.append(it)

    def remove_item(self, indx):
        if indx < len(self.items):
            del self.items[indx]

    def get_items(self):
        return self.items

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9. Объявите класс Box3D для представления прямоугольного параллелепипеда (бруска), объекты которого создаются
# командой:
#
# box = Box3D(width, height, depth)
# где width, height, depth - ширина, высота и глубина соответственно (числа: целые или вещественные)
#
# В каждом объекте класса Box3D должны создаваться публичные атрибуты:
#
# width, height, depth - ширина, высота и глубина соответственно.
#
# С объектами класса Box3D должны выполняться следующие операторы:
#
# box1 = Box3D(1, 2, 3)
# box2 = Box3D(2, 4, 6)
#
# box = box1 + box2 # Box3D: width=3, height=6, depth=9 (соответствующие размерности складываются)
# box = box1 * 2    # Box3D: width=2, height=4, depth=6 (каждая размерность умножается на 2)
# box = 3 * box2    # Box3D: width=6, height=12, depth=18
# box = box2 - box1 # Box3D: width=1, height=2, depth=3 (соответствующие размерности вычитаются)
# box = box1 // 2   # Box3D: width=0, height=1, depth=1 (соответствующие размерности целочисленно делятся на 2)
# box = box2 % 3    # Box3D: width=2, height=1, depth=0
# При каждой арифметической операции следует создавать новый объект класса Box3D с соответствующими значениями
# локальных атрибутов.
#
# P.S. В программе достаточно только объявить класс Box3D. На экран ничего выводить не нужно.



class Box3D:

    def __init__(self, width, height, depth):
        self.width = width
        self.height = height
        self.depth = depth

    def __add__(self, other):
        if isinstance(other, Box3D):
            width = self.width + other.width
            height = self.height + other.height
            dept = self.depth + other.depth
            return Box3D(width, height, dept)

    def __mul__(self, other):
        if isinstance(other, int):
            return Box3D(self.width * other, self.height * other, self.depth * other)

    def __rmul__(self, other):
        if isinstance(other, int):
            return Box3D(self.width * other, self.height * other, self.depth * other)

    def __sub__(self, other):
        if isinstance(other, Box3D):
            width = self.width - other.width
            height = self.height - other.height
            dept = self.depth - other.depth
            return Box3D(width, height, dept)

    def __floordiv__(self, other):
        if isinstance(other, int):
            return Box3D(self.width // other, self.height // other, self.depth // other)

    def __mod__(self, other):
        if isinstance(other, int):
            return Box3D(self.width % other, self.height % other, self.depth % other)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение). В нейронных сетях использую операцию под названием Max Pooling. Суть ее состоит в
# сканировании прямоугольной таблицы чисел (матрицы) окном определенного размера (обычно, 2x2 элемента) и выбора
# наибольшего значения в пределах этого окна:

# PHOTO 1

#  Или, если окна выходят за пределы матрицы, то они пропускаются (игнорируются):

# Мы повторим эту процедуру. Для этого в программе нужно объявить класс с именем MaxPooling, объекты которого создаются
# командой:
#
# mp = MaxPooling(step=(2, 2), size=(2,2))
# где step - шаг смещения окна по горизонтали и вертикали; size - размер окна по горизонтали и вертикали.
#
# Параметры step и size по умолчанию должны принимать кортеж со значениями (2, 2).
#
# Для выполнения операции Max Pooling используется команда:
#
# res = mp(matrix)
# где matrix - прямоугольная таблица чисел; res - ссылка на результат обработки таблицы matrix (должна создаваться
# новая таблица чисел.
#
# Прямоугольную таблицу чисел следует описывать вложенными списками. Если при сканировании таблицы часть окна выходит
# за ее пределы, то эти данные отбрасывать (не учитывать все окно).
#
# Если matrix не является прямоугольной таблицей или содержит хотя бы одно не числовое значение, то должно
# генерироваться исключение командой:
#
# raise ValueError("Неверный формат для первого параметра matrix.")
# Пример использования класса (эти строчки в программе писать не нужно):
#
# mp = MaxPooling(step=(2, 2), size=(2,2))
# res = mp([[1, 2, 3, 4], [5, 6, 7, 8], [9, 8, 7, 6], [5, 4, 3, 2]])    # [[6, 8], [9, 7]]
# Результатом будет таблица чисел:
#
# 6 8
# 9 7
#
# P.S. В программе достаточно объявить только класс. Выводить на экран ничего не нужно.

class MaxPooling:

    def __init__(self, step = (2, 2), size = (2, 2)):
        self.__step = step
        self.__size = size

    def __call__(self, matrix):
        rows = len(matrix)
        cols = len(matrix[0]) if rows > 0 else 0

        if rows == 0:
            return [[]]

        if not all(map(lambda x: len(x) == cols, matrix)) or \
                not all(map(lambda row: all(map(lambda x: type(x) in (int, float), row)), matrix)):
            raise ValueError("Неверный формат для параметра matrix")
        h, w = self.__size[0], self.__size[1]
        sh, sw = self.__step[0], self.__step[1]

        rows_range = (rows - h) // sh + 1
        cols_range = (cols - w) // sw + 1

        res = [[0] * cols_range for _ in range(rows_range)]

        for i in range(rows_range):
            for j in range(cols_range):
                s = (x for r in matrix[i * sh : i * sh + h] for x in r[j * sw : j * sw + w])
                res[i][j] = max(s)

        return res



# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.5 Сравнения __eq__, __ne__, __lt__, __gt__ и другие
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствия между магическими методами и операторами.

# __eq__() - оператор равенства ==
# __ne__() - оператор неравенства !=
# __lt__() - оператор меньше <
# __le__() - оператор меньше или равно <=
# __gt__() - оператор больше >
# __ge__() - оператор больше или равно >=


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Пусть в программе объявлен следующий класс:
#
# class Vector:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def __eq__(self, other):
#         return self.x == other.x and self.y == other.y
# И создаются его экземпляры:
#
# v1 = Vector(1, 2)
# v2 = Vector(2, 1)
# Для каких операций сравнения будет вызван магический метод __eq__() класса Vector?


# - v1 == v2
# - v1 != v2


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/cHV-yuNFavg
#
# Подвиг 3. Объявите класс Track (маршрут), объекты которого создаются командой:
#
# track = Track(start_x, start_y)
# где start_x, start_y - координаты начала маршрута (целые или вещественные числа).
#
# Каждый линейный сегмент маршрута определяется классом TrackLine, объекты которого создаются командой:
#
# line = TrackLine(to_x, to_y, max_speed)
# где to_x, to_y - координаты следующей точки маршрута (целые или вещественные числа); max_speed - максимальная
# скорость на данном участке (целое число).
#
# Для формирования и работы с маршрутом в классе Track должны быть объявлены следующие методы:
#
# add_track(self, tr) - добавление линейного сегмента маршрута (следующей точки);
# get_tracks(self) - получение кортежа из объектов класса TrackLine.
#
# Также для объектов класса Track должны быть реализованные следующие операции сравнения:
#
# track1 == track2  # маршруты равны, если равны их длины
# track1 != track2  # маршруты не равны, если не равны их длины
# track1 > track2  # True, если длина пути для track1 больше, чем для track2
# track1 < track2  # True, если длина пути для track1 меньше, чем для track2
# И функция:
#
# n = len(track) # возвращает целочисленную длину маршрута (привести к типу int) для объекта track
# Создайте два маршрута track1 и track2 с координатами:
#
# 1-й маршрут: (0; 0), (2; 4), (5; -4) и max_speed = 100
# 2-й маршрут: (0; 1), (3; 2), (10; 8) и max_speed = 90
#
# Сравните их между собой на равенство. Результат сравнения сохраните в переменной res_eq.
#
# P.S. На экран в программе ничего выводить не нужно.


class Track:

    def __init__(self, start_x, start_y):
        self._start_x = start_x
        self._start_y = start_y
        self._tracks = []

    def add_track(self, tr):
        self._tracks.append(tr)

    def get_tracks(self):
        return tuple(self._tracks)

    def __get_length(self, i):
        return ((self._tracks[i - 1].x - self._tracks[i].x) ** 2 + (self._tracks[i - 1].y - self._tracks[i].y) ** 2) ** 0.5


    def __len__(self):
        len_1 = ((self._start_x - self._tracks[0].x) ** 2 + (self._start_y - self._tracks[0].y) ** 2) ** 0.5
        return int(len_1 + sum(self.__get_length(i) for i in range(1, len(self._tracks))))

    def __eq__(self, other):
        return len(self) == len(other)

    def __lt__(self, other):
        return len(self) < len(other)






class TrackLine:

    def __init__(self, to_x, to_y, max_speed):
        self._to_x = to_x
        self._to_y = to_y
        self._max_speed = max_speed

    @property
    def x(self):
        return self._to_x

    @property
    def y(self):
        return self._to_y

    @property
    def max_speed(self):
        return self._max_speed


track1 = Track(0, 0)
track2 = Track(0, 1)

track1.add_track(TrackLine(2, 4, 100))
track1.add_track(TrackLine(5, -4, 100))

track2.add_track(TrackLine(3, 2, 90))
track2.add_track(TrackLine(10, 8, 90))

res_eq = track1 == track2

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите класс Dimensions (габариты) с атрибутами:
#
# MIN_DIMENSION = 10
# MAX_DIMENSION = 10000
# Каждый объект класса Dimensions должен создаваться командой:
#
# d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
# Значения a, b, c должны сохраняться в локальных приватных атрибутах __a, __b, __c объектах этого класса.
#
# Для изменения и доступа к приватным атрибутам в классе Dimensions должны быть объявлены объекты-свойства (property)
# с именами: a, b, c. Причем, в момент присваивания нового значения должна выполняться проверка попадания числа в
# диапазон [MIN_DIMENSION; MAX_DIMENSION]. Если число не попадает, то оно игнорируется и существующее значение не
# меняется.
#
# С объектами класса Dimensions должны выполняться следующие операторы сравнения:
#
# dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
# dim1 > dim2    # True, если объем dim1 больше объема dim2
# dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
# dim1 < dim2    # True, если объем dim1 меньше объема dim2
# Объявите в программе еще один класс с именем ShopItem (товар), объекты которого создаются командой:
#
# item = ShopItem(name, price, dim)
# где name - название товара (строка); price - цена товара (целое или вещественное число); dim - габариты
# товара (объект класса Dimensions).
#
# В каждом объекте класса ShopItem должны создаваться локальные атрибуты:
#
# name - название товара;
# price - цена товара;
# dim - габариты товара (объект класса Dimensions).
#
# Создайте список с именем lst_shop из четырех товаров со следующими данными:
#
# - кеды; 1024; (40, 30, 120)
# - зонт; 500.24; (10, 20, 50)
# - холодильник; 40000; (2000, 600, 500)
# - табуретка; 2000.99; (500, 200, 200)
#
# Сформируйте новый список lst_shop_sorted с упорядоченными по возрастанию объема (габаритов) товаров списка
# lst_shop, используя стандартную функцию sorted() языка Python и ее параметр key для настройки сортировки.
# Прежний список lst_shop должен оставаться без изменений.
#
# P.S. На экран в программе ничего выводить не нужно.


class Dimensions:
    MIN_DIMENSION = 10
    MAX_DIMENSION = 10000

    def __init__(self, params):
        self.__a, self.__b, self.__c = params

    # Getters

    @property
    def a(self):
        return self.__a

    @property
    def b(self):
        return self.__b

    @property
    def c(self):
        return self.__c

    # Setters
    @a.setter
    def a(self, a):
        if self.check_value(a):
            self.__a = a

    @b.setter
    def b(self, b):
        if self.check_value(b):
            self.__b = b

    @c.setter
    def c(self, c):
        if self.check_value(c):
            self.__c = c

    def check_value(self, val):
        return True if self.MIN_DIMENSION <= val <= self.MAX_DIMENSION else False

    def give_volume(self):
        return self.a * self.b * self.c

    def __ge__(self, other):
        return self.give_volume() >= other.give_volume()

    def __le__(self, other):
        return self.give_volume() <= other.give_volume()

    def __gt__(self, other):
        return self.give_volume() > other.give_volume()

    def __lt__(self, other):
        return self.give_volume() < other.give_volume()


class ShopItem:

    def __init__(self, name, price, dim):
        self.name = name
        self.price = price
        self.dim = Dimensions(dim)

lst_shop = [ShopItem('кеды', 1024, (40, 30, 120)), ShopItem('зонт', 500.24, (10, 20, 50)),
            ShopItem('холодильник', 40000, (2000, 600, 500)), ShopItem('табуретка', 2000.99, (500, 200, 200))]

lst_shop_sorted = sorted(lst_shop, key=lambda x: x.dim.give_volume())
print({x.name: x.dim.give_volume() for x in lst_shop_sorted})


# Второй вариант
class DimensionsDescriptors:

    def __set_name__(self, owner, name):
        self.name = '_' + owner.__name__ + '__' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if self.__validate(instance, value):
            setattr(instance, self.name, value)

    @staticmethod
    def __validate(instance, value):
        return instance.MIN_DIMENSION <= value <= instance.MAX_DIMENSION


class Dimensions:
    MIN_DIMENSION = 10
    MAX_DIMENSION = 10000
    a = DimensionsDescriptors()
    b = DimensionsDescriptors()
    c = DimensionsDescriptors()

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @property
    def volume(self):
        return self.a * self.b * self.c

    def __gt__(self, other):
        return self.volume > other.volume

    def __ge__(self, other):
        return self.volume >= other.volume

    def __repr__(self):
        return f"{self.volume}"


class ShopItem:

    def __init__(self, name: str, price: (int, float), dim: Dimensions):
        self.name = name
        self.price = price
        self.dim = dim
        self.dim_volume = self.dim.volume

    def __repr__(self):
        fields = [f'{f}={v}' for f, v in self.__dict__.items()]
        return f"{type(self).__name__}" + str(tuple(fields)).replace("\'", '')


lst_shop = [ShopItem('кеды', 1024, Dimensions(40, 30, 120)),
            ShopItem('зонт', 500.24, Dimensions(10, 20, 50)),
            ShopItem('холодильник', 40000, Dimensions(2000, 600, 500)),
            ShopItem('табуретка', 2000.99, Dimensions(500, 200, 200))]

lst_shop_sorted = sorted(lst_shop, key=lambda x: x.dim_volume)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/k7PSxUf0w6g
#
# Подвиг 5. Имеется стихотворение, представленное следующим списком строк:
#
# stich = ["Я к вам пишу – чего же боле?",
#         "Что я могу еще сказать?",
#         "Теперь, я знаю, в вашей воле",
#         "Меня презреньем наказать.",
#         "Но вы, к моей несчастной доле",
#         "Хоть каплю жалости храня,",
#         "Вы не оставите меня."]
# Необходимо в каждой строчке этого стиха убрать символы "–?!,.;" в начале и в конце каждого слова и разбить строку
# по словам (слова разделяются одним или несколькими пробелами). На основе полученного списка слов, создать объект
# класса StringText командой:
#
# st = StringText(lst_words)
# где lst_words - список из слов одной строчки стихотворения.
#
# С объектами класса StringText должны быть реализованы операторы сравнения:
#
# st1 > st2   # True, если число слов в st1 больше, чем в st2
# st1 >= st2  # True, если число слов в st1 больше или равно st2
# st1 < st2   # True, если число слов в st1 меньше, чем в st2
# st1 <= st2  # True, если число слов в st1 меньше или равно st2
# Все объекты класса StringText (для каждой строчки стихотворения) сохранить в списке lst_text. Затем, сформировать
# новый список lst_text_sorted из отсортированных объектов класса StringText по убыванию числа слов. Для сортировки
# использовать стандартную функцию sorted() языка Python. После этого преобразовать данный список (lst_text_sorted)
# в список из строк (объекты заменяются на соответствующие строки, между словами ставится пробел).
#
# P.S. На экран в программе ничего выводить не нужно.

# эти строчки не менять
stich = ["Я к вам пишу – чего же боле?",
        "Что я могу еще сказать?",
        "Теперь, я знаю, в вашей воле",
        "Меня презреньем наказать.",
        "Но вы, к моей несчастной доле",
        "Хоть каплю жалости храня,",
        "Вы не оставите меня."]


# здесь продолжайте программу

class RemoveChars:

    def __init__(self, chars):
        self.chars = chars

    def __call__(self, arg, *args, **kwargs):
        if isinstance(arg, str):
            for char in self.chars:
                arg = arg.replace(char, '')

            return arg.split()


class StringText:

    def __init__(self, lst):
        self.lst = lst

    def __eq__(self, other):
        if isinstance(other, StringText):
            return len(self) == len(other)
        raise AttributeError

    def __gt__(self, other):
        if isinstance(other, StringText):
            return len(self) > len(other)
        raise AttributeError

    def __ge__(self, other):
        if isinstance(other, StringText):
            return len(self) >= len(other)
        raise AttributeError

    def __len__(self):
        return len(self.lst)


parce = RemoveChars("-?!,.;")
lst_text = [StringText(parce(sentence)) for sentence in stich]
lst_text_sorted = sorted(lst_text, reverse=True)
lst_text_sorted = [' '.join(i.lst) for i in lst_text_sorted]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PJsJOIxZOdM
#
# Подвиг 6. Ваша задача написать программу поиска слова в строке. Задача усложняется тем, что слово должно определяться
# в разных его формах. Например, слово:
#
# программирование
#
# может иметь следующие формы:
#
# программирование, программированию, программированием, программировании, программирования, программированиям,
# программированиями, программированиях
#
# Для решения этой задачи необходимо объявить класс Morph (морфология), объекты которого создаются командой:
#
# mw = Morph(word1, word2, ..., wordN)
# где word1, word2, ..., wordN - возможные формы слова.
#
# В классе Morph реализовать методы:
#
# add_word(self, word) - добавление нового слова (если его нет в списке слов объекта класса Morph);
# get_words(self) - получение кортежа форм слов.
#
# Также с объектами класса Morph должны выполняться следующие операторы сравнения:
#
# mw1 == "word"  # True, если объект mv1 содержит слово "word" (без учета регистра)
# mw1 != "word"  # True, если объект mv1 не содержит слово "word" (без учета регистра)
# И аналогичная пара сравнений:
#
# "word" == mw1
# "word" != mw1
# После создания класса Morph, формируется список dict_words из объектов этого класса, для следующих слов с их
# словоформами:
#
# - связь, связи, связью, связей, связям, связями, связях
# - формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
# - вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
# - эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
# - день, дня, дню, днем, дне, дни, дням, днями, днях
#
# Затем, прочитайте строку из входного потока командой:
#
# text = input()
# Найдите все вхождения слов из списка dict_words (используя операторы сравнения) в строке text (без учета
# регистра, знаков пунктуаций и их словоформы). Выведите на экран полученное число.
#
# Sample Input:
#
# Мы будем устанавливать связь завтра днем.
# Sample Output:
#
# 2


class Morph:

    def __init__(self, *args):
        self.words = []
        if args:
            self.words = [word.lower() for word in args]

    def add_word(self, word):
        if word not in self.words:
            self.words.append(word.lower())
        return

    def get_words(self):
        return tuple(self.words)

    def __eq__(self, other):
        if isinstance(other, str):
            return other.lower() in self.get_words()

    def __ne__(self, other):
        if isinstance(other, str):
            return other.lower() not in self.get_words()


s = """- связь, связи, связью, связи, связей, связям, связями, связях
- формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
- вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
- эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
- день, дня, дню, днем, дне, дни, дням, днями, днях
"""

dict_words = [Morph(*line.lstrip('- ').split(', ')) for line in s.splitlines()]

text = input()

res = 0
for i in text.split():
    if i.lower().replace('.', '') in dict_words:
        res += 1

print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7 (на повторение). Перед вами стоит задача выделения файлов с определенными расширениями из списка файлов,
# например:
#
# filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.xls"]
# Для этого необходимо объявить класс FileAcceptor, объекты которого создаются командой:
#
# acceptor = FileAcceptor(ext1, ..., extN)
# где ext1, ..., extN - строки с допустимыми расширениями файлов, например: 'jpg', 'bmp', 'jpeg'.
#
# После этого предполагается использовать объект acceptor в стандартной функции filter языка Python следующим образом:
#
# filenames = list(filter(acceptor, filenames))
# То есть, объект acceptor должен вызываться как функция:
#
# acceptor(filename)
# и возвращать True, если файл с именем filename содержит расширения, указанные при создании acceptor, и False - в
# противном случае. Кроме того, с объектами класса FileAcceptor должен выполняться оператор:
#
# acceptor12 = acceptor1 + acceptor2
# Здесь формируется новый объект acceptor12 с уникальными расширениями первого и второго объектов. Например:
#
# acceptor1 = FileAcceptor("jpg", "jpeg", "png")
# acceptor2 = FileAcceptor("png", "bmp")
# acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
# Пример использования класса (эти строчки в программе писать не нужно):
#
# acceptor_images = FileAcceptor("jpg", "jpeg", "png")
# acceptor_docs = FileAcceptor("txt", "doc", "xls")
# filenames = list(filter(acceptor_images + acceptor_docs, filenames))
# P.S. На экран в программе ничего выводить не нужно.


class FileAcceptor:

    def __init__(self, *args):
        self.exts = []
        if args:
            self.exts = list(args)

    def __call__(self, filename, *args, **kwargs):
        return filename[filename.rfind('.') + 1:] in self.exts

    def __add__(self, other):
        if isinstance(other, FileAcceptor):
            return FileAcceptor(*set(self.exts + other.exts))


# acceptor1 = FileAcceptor("jpg", "jpeg", "png")
# acceptor2 = FileAcceptor("png", "bmp")
# acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
#
# filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg",
# "forest.jpeg", "eq_1.png", "eq_2.xls"]
#
# acceptor_images = FileAcceptor("jpg", "jpeg", "png")
# acceptor_docs = FileAcceptor("txt", "doc", "xls")
# res = acceptor_images + acceptor_docs
# print(res.exts)
# filenames = list(filter(acceptor_images + acceptor_docs, filenames))
#
# print(filenames)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/qKTQLo-plpc
#
# Подвиг 8. В программе необходимо объявить классы для работы с кошельками в разных валютах:
#
# MoneyR - для рублевых кошельков
# MoneyD - для долларовых кошельков
# MoneyE - для евро-кошельков

# PHOTO

# Объекты этих классов могут создаваться командами:
#
# rub = MoneyR()   # с нулевым балансом
# dl = MoneyD(1501.25) # с балансом в 1501.25 долларов
# euro = MoneyE(100)  # с балансом в 100 евро
# В каждом объекте этих классов должны формироваться локальные атрибуты:
#
# __cb - ссылка на класс CentralBank (центральный банк, изначально None);
# __volume - объем денежных средств в кошельке (если не указано, то 0).
#
# Также в классах MoneyR, MoneyD и MoneyE должны быть объекты-свойства (property) для работы с локальными атрибутами:
#
# cb - для изменения и считывания данных из переменной __cb;
# volume - для изменения и считывания данных из переменной __volume.
#
# Объекты классов должны поддерживать следующие операторы сравнения:
#
# rub < dl
# dl >= euro
# rub == euro  # значения сравниваются по текущему курсу центрального банка с погрешностью 0.1 (плюс-минус)
# euro > rub
# При реализации операторов сравнения считываются соответствующие значения __volume из сравниваемых объектов и
# приводятся к рублевому эквиваленту в соответствии с курсом валют центрального банка.
#
# Чтобы каждый объект классов MoneyR, MoneyD и MoneyE "знал" текущие котировки, необходимо в программе объявить
# еще один класс CentralBank. Объекты класса CentralBank создаваться не должны (запретить), при выполнении команды:
#
# cb = CentralBank()
#
# должно просто возвращаться значение None. А в самом классе должен присутствовать атрибут:
#
# rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
# Здесь числа (в значениях словаря) - курс валюты по отношению к доллару.
#
# Также в CentralBank должен быть метод уровня класса:
#
# register(cls, money) - для регистрации объектов классов MoneyR, MoneyD и MoneyE.
#
# При регистрации значение __cb объекта money должно ссылаться на класс CentralBank. Через эту переменную объект
# имеет возможность обращаться к атрибуту rates класса CentralBank и брать нужные котировки.
#
# Если кошелек не зарегистрирован, то при операциях сравнения должно генерироваться исключение:
#
# raise ValueError("Неизвестен курс валют.")
# Пример использования классов (эти строчки в программе писать не нужно):
#
# CentralBank.rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
#
# r = MoneyR(45000)
# d = MoneyD(500)
#
# CentralBank.register(r)
# CentralBank.register(d)
#
# if r > d:
#     print("неплохо")
# else:
#     print("нужно поднажать")
# P.S. В программе на экран ничего выводить не нужно, только объявить классы.


class MoneyR:

    def __init__(self, volume=0, cb=None):
        self.name = 'rub'
        self.__volume = volume
        self.__cb = cb

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, cb):
        self.__cb = cb

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, volume):
        self.__volume = volume

    def __lt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] < other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __gt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] > other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __ge__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] >= other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __eq__(self, other):
        if self.cb is not None or other.cb is not None:
            money1 = self.volume / self.cb.rates[self.name]
            money2 = other.volume / other.cb.rates[self.name]
            res = sorted([money1, money2])
            return res[1] - res[0] <= 0.1
        raise ValueError("Неизвестен курс валют.")


class MoneyD:

    def __init__(self, volume=0, cb=None):
        self.name = 'dollar'
        self.__volume = volume
        self.__cb = cb

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, cb):
        self.__cb = cb

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, volume):
        self.__volume = volume

    def __lt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] < other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __gt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] > other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __ge__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] >= other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __eq__(self, other):
        if self.cb is not None or other.cb is not None:
            money1 = self.volume / self.cb.rates[self.name]
            money2 = other.volume / other.cb.rates[self.name]
            res = sorted([money1, money2])
            return res[1] - res[0] <= 0.1
        raise ValueError("Неизвестен курс валют.")


class MoneyE:

    def __init__(self, volume=0, cb=None):
        self.name = 'euro'
        self.__volume = volume
        self.__cb = cb

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, cb):
        self.__cb = cb

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, volume):
        self.__volume = volume

    def __lt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] < other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __gt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] > other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __ge__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] >= other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __eq__(self, other):
        if self.cb is not None or other.cb is not None:
            money1 = self.volume / self.cb.rates[self.name]
            money2 = other.volume / other.cb.rates[self.name]
            res = sorted([money1, money2])
            return res[1] - res[0] <= 0.1
        raise ValueError("Неизвестен курс валют.")



class CentralBank:

    def __new__(cls, *args, **kwargs):
        return None

    rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

    @classmethod
    def register(cls, money):
        money.cb = cls


# Второй вариант с наследованием!!!!!

class CentralBank:
    rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

    def __new__(cls):
        return None

    @classmethod
    def register(cls, money):
        if isinstance(money, Money):
            money.cb = cls


class Money:
    def __init__(self, volume=0):
        self.__cb = None
        self.__volume = volume

    def __eq__(self, other):
        if isinstance(other, Money):
            return self.valuate() == other.valuate()

    def __lt__(self, other):
        if isinstance(other, Money):
            return self.valuate() < other.valuate()

    def __le__(self, other):
        if isinstance(other, Money):
            return self.valuate() <= other.valuate()

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, value):
        if value is CentralBank:
            self.__cb = value

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, value):
        if type(value) in (int, float):
            self.__volume = value

    def valuate(self):
        if self.cb:
            return round(self.volume / self.cb.rates[self.currency_name], 1)
        raise ValueError("Неизвестен курс валют.")


class MoneyR(Money):
    currency_name = 'rub'


class MoneyD(Money):
    currency_name = 'dollar'


class MoneyE(Money):
    currency_name = 'euro'


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (релакс). Необходимо объявить класс Body (тело), объекты которого создаются командой:
#
# body = Body(name, ro, volume)
# где name - название тела (строка); ro - плотность тела (число: вещественное или целочисленное); volume - объем тела
# (число: вещественное или целочисленное).
#
# Для объектов класса Body должны быть реализованы операторы сравнения:
#
# body1 > body2  # True, если масса тела body1 больше массы тела body2
# body1 == body2 # True, если масса тела body1 равна массе тела body2
# body1 < 10     # True, если масса тела body1 меньше 10
# body2 == 5     # True, если масса тела body2 равна 5
# Масса тела вычисляется по формуле:
#
# m = ro * volume
#
# P.S. В программе только объявить класс, выводить на экран ничего не нужно.

class Body:

    def __init__(self, name, ro, volume):
        self.name = name
        self.ro = ro
        self.volume = volume

    def give_mass(self):
        return self.ro * self.volume

    def __gt__(self, other):
        if isinstance(other, Body):
            return self.give_mass() > other.give_mass()
        if type(other) in (float, int):
            return self.give_mass() > other

    def __eq__(self, other):
        if isinstance(other, Body):
            return self.give_mass() == other.give_mass()
        if type(other) in (float, int):
            return self.give_mass() == other

    def __lt__(self, other):
        if isinstance(other, Body):
            return self.give_mass() < other.give_mass()
        if type(other) in (float, int):
            return self.give_mass() < other


# Второй вариант с замыканием

def mass_arg(func):
    def wrapper(instance, other, *args):
        if isinstance(other, Body):
            return func(instance, other.mass)
        elif isinstance(other, (int, float)):
            return func(instance, other)
        else:
            raise TypeError(f"Not supported type {type(other)} in {func}")

    return wrapper


class Body:
    def __init__(self, name, ro, volume):
        self.name = name
        self.ro = ro
        self.volume = volume

    @property
    def mass(self):
        return (self.ro * self.volume)

    @mass_arg
    def __lt__(self, other):
        return (self.mass < other)

    @mass_arg
    def __le__(self, other):
        return self.mass <= other

    @mass_arg
    def __eq__(self, other):
        return self.mass == other

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10. Объявите в программе класс с именем Box (ящик), объекты которого должны создаваться командой:
#
# box = Box()
# А сам класс иметь следующие методы:
#
# add_thing(self, obj) - добавление предмета obj (объект другого класса Thing) в ящик;
# get_things(self) - получение списка объектов ящика.
#
# Для описания предметов необходимо объявить еще один класс Thing. Объекты этого класса должны создаваться командой:
#
# obj = Thing(name, mass)
# где name - название предмета (строка); mass - масса предмета (число: целое или вещественное).
# Объекты класса Thing должны поддерживать операторы сравнения:
#
# obj1 == obj2
# obj1 != obj2
# Предметы считаются равными, если у них одинаковые названия name (без учета регистра) и массы mass.
#
# Также объекты класса Box должны поддерживать аналогичные операторы сравнения:
#
# box1 == box2
# box1 != box2
# Ящики считаются равными, если одинаковы их содержимое (для каждого объекта класса Thing одного ящика и можно найти
# ровно один равный объект из второго ящика).
#
# Пример использования классов:
#
# b1 = Box()
# b2 = Box()
#
# b1.add_thing(Thing('мел', 100))
# b1.add_thing(Thing('тряпка', 200))
# b1.add_thing(Thing('доска', 2000))
#
# b2.add_thing(Thing('тряпка', 200))
# b2.add_thing(Thing('мел', 100))
# b2.add_thing(Thing('доска', 2000))
#
# res = b1 == b2 # True
# P.S. В программе только объявить классы, выводить на экран ничего не нужно.

class Box:

    def __init__(self):
        self.box = []

    def add_thing(self, obj):
        self.box.append(obj)

    def get_things(self):
        return self.box

    def __eq__(self, other):
        if isinstance(other, Box):
            return all([self.box.count(i) == other.box.count(i) for i in self.box])

    def __ne__(self, other):
        return not self.__eq__(other)



class Thing:

    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Thing):
            if self.name.lower() == other.name.lower() and self.mass == other.mass:
                return True
            else:
                return False
        return

    def __ne__(self, other):
        if isinstance(other, Thing):
            if self.name.lower() != other.name.lower() or self.mass != other.mass:
                return True
            else:
                return False
        return


# b1 = Box()
# b2 = Box()
#
# b1.add_thing(Thing('мел', 100))
# b1.add_thing(Thing('тряпка', 200))
# b1.add_thing(Thing('доска', 2000))
#
# b2.add_thing(Thing('тряпка', 200))
# b2.add_thing(Thing('мел', 100))
# b2.add_thing(Thing('доска', 2000))
#
# res = b1 == b2 # True
# print(res)


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.6 Методы __eq__ и __hash__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Выберите все верные утверждения, связанные с работой функции hash() для двух хешируемых
# объектов a и b языка Python.

# - если объекты a == b, то hash(a) == hash(b)
# - если hash(a) != hash(b), то a != b


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Отметьте команды, которые будут выполняться без ошибок.

# - hash((5, 4, 3.5))
# - hash("Balakirev")
# - hash(1024.56)
# - hash(True)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен следующий класс:
#
# class PathLine:
#     def __init__(self, dist, angle):
#         self.dist = dist
#         self.angle = angle
#
#     def __eq__(self, other):
#         return abs(self.dist) == abs(other.dist)
# И создаются два его объекта:
#
# p1 = PathLine(10, 1.57)
# p2 = PathLine(-10, 0.49)
# Затем, вычисляются хэши этих объектов:
#
# h1, h2 = hash(p1), hash(p2)
# Что произойдет в последней строчке программы?


# - будет ошибка, что объекты p1 и p2 не хешируемые


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите в программе класс с именем Rect (прямоугольник), объекты которого создаются командой:
#
# rect = Rect(x, y, width, height)
# где x, y - координата верхнего левого угла (числа: целые или вещественные); width, height - ширина и высота
# прямоугольника (числа: целые или вещественные).
#
# В этом классе определите магический метод, чтобы хэши объектов класса Rect с равными width, height были равны.
# Например:
#
# r1 = Rect(10, 5, 100, 50)
# r2 = Rect(-10, 4, 100, 50)
#
# h1, h2 = hash(r1), hash(r2)   # h1 == h2
# P.S. На экран ничего выводить не нужно, только объявить класс.


class Rect:

    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def __hash__(self):
        return hash((self.width, self.height))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Пусть в программе определен следующий класс:
#
# class Index:
#     START_INDEX = 0
#
#     def __init__(self):
#         self.id = Index.START_INDEX
#         Index.START_INDEX += 1
#
#     def __hash__(self):
#         return hash(str(self.id))
# И делается попытка создать словарь с ключами из объектов этого класса:
#
# id1 = Index()
# id2 = Index()
# d = {id1: id1, id2: id2}
# Выберите верное утверждение, связанное с этой программой.


# - словарь будет успешно создан и к его значениям можно обращаться, например, командой: d[id1].id


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Объявите класс с именем ShopItem (товар), объекты которого создаются командой:
#
# item = ShopItem(name, weight, price)
# где name - название товара (строка); weight - вес товара (число: целое или вещественное); price - цена товара
# (число: целое или вещественное).
#
# Определите в этом классе магические методы:
#
# __hash__() - чтобы товары с одинаковым названием (без учета регистра), весом и ценой имели бы равные хэши;
# __eq__() - чтобы объекты с одинаковыми хэшами были равны.
#
# Затем, из входного потока прочитайте строки командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Строки имеют следующий формат:
#
# название товара 1: вес_1 цена_1
# ...
# название товара N: вес_N цена_N
#
# Например:
#
# Системный блок: 1500 75890.56
# Монитор Samsung: 2000 34000
# Клавиатура: 200.44 545
# Монитор Samsung: 2000 34000
#
# Как видите, товары в этом списке могут совпадать.
#
# Необходимо для всех этих строчек сформировать соответствующие объекты класса ShopItem и добавить в словарь с именем
# shop_items. Ключами словаря должны выступать сами объекты, а значениями - список в формате:
#
# [item, total]
#
# где item - объект класса ShopItem; total - общее количество одинаковых объектов (с одинаковыми хэшами).
# Подумайте, как эффективно программно наполнять такой словарь, проходя по списку lst_in один раз.
#
# P.S. На экран ничего выводить не нужно, только объявить класс и сформировать словарь.
#
# Sample Input:
#
# Системный блок: 1500 75890.56
# Монитор Samsung: 2000 34000
# Клавиатура: 200.44 545
# Монитор Samsung: 2000 34000
# Sample Output:

import sys

class ShopItem:
    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price

    def __hash__(self):
        return hash((self.name.lower(), self.weight, self.price))

    def __eq__(self, other):
        return hash(self) == hash(other)

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять!
shop_items = dict()

for item in lst_in:
    name, etc = item.split(': ')
    weight, price = map(float, etc.split())
    item = ShopItem(name, weight, price)
    total = shop_items.get(item, [None, 0])[-1] + 1
    shop_items[item] = [item, total]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rqCqhjtl6Lw
#
# Подвиг 7. Объявите класс с именем DataBase (база данных - БД), объекты которого создаются командой:
#
# db = DataBase(path)
# где path - путь к файлу с данными БД (строка).
#
# Также в классе DataBase нужно объявить следующие методы:
#
# write(self, record) - для добавления новой записи в БД, представленной объектом record;
# read(self, pk) - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk (уникальное
# целое положительное число); запись ищется в значениях словаря (см. ниже)
#
# Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:
#
# record = Record(fio, descr, old)
# где fio - ФИО некоторого человека (строка); descr - характеристика человека (строка); old - возраст
# человека (целое число).
#
# В каждом объекте класса Record должны формироваться следующие локальные атрибуты:
#
# pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого
# нового объекта;
# fio - ФИО человека (строка);
# descr - характеристика человека (строка);
# old - возраст человека (целое число).
#
# Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра). Если они
# одинаковы для разных записей, то и хэши должны получаться равными. Также для объектов класса Record  с одинаковыми
# хэшами оператор == должен выдавать значение True, а с разными хэшами - False.
#
# Хранить записи в БД следует в виде словаря dict_db (атрибут объекта db класса DataBase), ключами которого являются
# объекты класса Record, а значениями список из объектов с равными хэшами:
#
# dict_db[rec1] = [rec1, rec2, ..., recN]
#
# где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.
#
# Для наполнения БД прочитайте строки из входного потока с помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# где каждая строка представлена в формате:
#
# "ФИО; характеристика; возраст"
#
# Например:
#
# Балакирев С.М.; программист; 33
# Кузнецов А.В.; разведчик-нелегал; 35
# Суворов А.В.; полководец; 42
# Иванов И.И.; фигурант всех подобных списков; 26
# Балакирев С.М.; преподаватель; 37
#
# Каждая строка должна быть представлена объектом класса Record и записана в БД db (в словарь db.dict_db).
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# Балакирев С.М.; программист; 33
# Кузнецов Н.И.; разведчик-нелегал; 35
# Суворов А.В.; полководец; 42
# Иванов И.И.; фигурант всех подобных списков; 26
# Балакирев С.М.; преподаватель; 33
# Sample Output:


import sys

class DataBase:

    def __init__(self, path):
        self.path = path
        self.dict_db = {}

    def write(self, record):
        self.dict_db.setdefault(record, [])
        self.dict_db[record].append(record)

    def read(self, pk):
        r = (x for row in self.dict_db.values() for x in row)
        obj = tuple(filter(lambda x: x.pk == pk, r))
        return obj[0] if len(obj) > 0 else None


class Record:
    pk = 0

    def __new__(cls, *args, **kwargs):
        cls.pk += 1
        return super().__new__(cls)

    def __init__(self,fio, descr, old):
        self.fio = fio
        self.descr = descr
        self.old = int(old)
        self.pk = Record.pk

    def __hash__(self):
        return hash((self.fio.lower(), self.old))

    def __eq__(self, other):
        return hash(self) == hash(other)


# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in не менять!

# здесь продолжайте программу (используйте список строк lst_in)
db = DataBase('abc')

for i in lst_in:
    sentence = i.split('; ')
    name, descr, old = sentence
    p = Record(name, descr, old)
    db.write(p)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Из входного потока необходимо прочитать список строк командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Каждая строка содержит информацию об учебном пособии в формате:
#
# "Название; автор; год издания"
#
# Например:
#
# Python; Балакирев С.М.; 2020
# Python ООП; Балакирев С.М.; 2021
# Python ООП; Балакирев С.М.; 2022
# Python; Балакирев С.М.; 2021
#
# Необходимо каждую из этих строк представить объектом класса BookStudy, которые создаются командой:
#
# bs = BookStudy(name, author, year)
# где name - название пособия (строка); author - автор пособия (строка); year - год издания (целое число). Такие же
# публичные локальные атрибуты должны быть в объектах класса BookStudy.
#
# Для каждого объекта реализовать вычисление хэша по двум атрибутам: name и author (без учета регистра).
#
# Сформировать список lst_bs из объектов класса BookStudy на основе прочитанных строк (списка lst_in). После этого
# определить число книг с уникальными хэшами. Это число сохранить через переменную unique_books (целое число).
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# Python; Балакирев С.М.; 2020
# Python ООП; Балакирев С.М.; 2021
# Python ООП; Балакирев С.М.; 2022
# Python; Балакирев С.М.; 2021
# Sample Output:


import sys

# здесь объявляйте класс

class BookStudy:

    def __init__(self, name, author, year):
        self.name = name
        self.author = author
        self.year = year

    def __hash__(self):
        return hash((self.name, self.author))

    def __eq__(self, other):
        return hash(self) == hash(other)

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in не менять!

# здесь продолжайте программу (используйте список строк lst_in)

lst_bs = []

for i in lst_in:
    params = tuple((x.strip() for x in i.split(';')))
    lst_bs.append(BookStudy(*params))

unique_books = len(set(lst_bs))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (релакс). Объявите класс с именем Dimensions, объекты которого создаются командой:
#
# d = Dimensions(a, b, c)
# где a, b, c - положительные числа (целые или вещественные), описывающие габариты некоторого тела: высота, ширина и
# глубина.
#
# Каждый объект класса Dimensions должен иметь аналогичные публичные атрибуты a, b, c (с соответствующими числовыми
# значениями). Также для каждого объекта должен вычисляться хэш на основе всех трех габаритов: a, b, c.
#
# С помощью функции input() прочитайте из входного потока строку, записанную в формате:
#
# "a1 b1 c1; a2 b2 c2; ... ;aN bN cN"
#
# Например:
#
# "1 2 3; 4 5 6.78; 1 2 3; 0 1 2.5"
#
# Если какой-либо габарит оказывается отрицательным значением или равен нулю, то при создании объектов должна
# генерироваться ошибка командой:
#
# raise ValueError("габаритные размеры должны быть положительными числами")
# Сформируйте на основе прочитанной строки список lst_dims из объектов класса Dimensions. После этого отсортируйте
# этот список по возрастанию (неубыванию) хэшей этих объектов так, чтобы объекты с равными хэшами стояли друг за другом.
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# 1 2 3; 4 5 6.78; 1 2 3; 3 1 2.5
# Sample Output:


class Dimensions:

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __hash__(self):
        return hash((self.a, self.b, self.c))

    def __setattr__(self, key, value):
        if key in ('a', 'b', 'c'):
            if type(value) not in (float, int) or type(value) in (float, int) and value <= 0:
                raise ValueError("габаритные размеры должны быть положительными числами")
        super().__setattr__(key, value)

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __ne__(self, other):
        return hash(self) != hash(other)

    def __lt__(self, other):
        return hash(self) < hash(other)

    def __gt__(self, other):
        return hash(self) > hash(other)


s_inp = input().strip()

lst = [[float(x) for x in i.strip().split()] for i in s_inp.split(';')]
lst_dims = sorted([Dimensions(*[float(i) for i in x]) for x in lst], key=lambda x: hash(x))


# Второй вариант
class Dimensions:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __setattr__(self, name, value):
        if value <= 0:
            raise ValueError("габаритные размеры должны быть положительными числами")
        object.__setattr__(self, name, value)

    def __hash__(self):
        return hash((self.a, self.b, self.c))


s_inp = input()
lst_dims = sorted([Dimensions(*map(float, elem.split())) for elem in s_inp.split('; ')], key=hash)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0EYz8-qG2iU
#
# Подвиг 10 (на повторение). Объявите класс с именем Triangle, объекты которого создаются командой:
#
# tr = Triangle(a, b, c)
# где a, b, c - длины сторон треугольника (числа: целые или вещественные). В классе Triangle объявите следующие
# дескрипторы данных:
#
# a, b, c - для записи и считывания длин сторон треугольника.
#
# При записи нового значения нужно проверять, что присваивается положительное число (целое или вещественное).
# Иначе, генерируется исключение командой:
#
# raise ValueError("длины сторон треугольника должны быть положительными числами")
# Также нужно проверять, что все три стороны a, b, c могут образовывать стороны треугольника. То есть, должны
# выполняться условия:
#
# a < b+c; b < a+c; c < a+b
#
# Иначе генерируется исключение командой:
#
# raise ValueError("с указанными длинами нельзя образовать треугольник")
# Наконец, с объектами класса Triangle должны выполняться функции:
#
# len(tr) - возвращает периметр треугольника, приведенный к целому значению с помощью функции int();
# tr() - возвращает площадь треугольника (можно вычислить по формуле Герона: s = sqrt(p * (p-a) * (p-b) * (p-c)),
# где p - полупериметр треугольника).
#
# P.S. На экран ничего выводить не нужно, только объявить класс Triangle.


class PositiveValue:
    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name, None)

    def __set__(self, instance, value):
        if type(value) not in (int, float) or value <= 0:
            raise ValueError("длины сторон треугольника должны быть положительными числами")
        setattr(instance, self.name, value)


class Triangle:
    a = PositiveValue()
    b = PositiveValue()
    c = PositiveValue()

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __setattr__(self, key, value):
        if (key == 'a' and not self.__is_triangle(value, self.b, self.c)) or \
            (key == 'b' and not self.__is_triangle(value, self.a, self.c)) or \
            (key == 'c' and not self.__is_triangle(value, self.a, self.b)):
            raise ValueError("с указанными длинами нельзя образовать треугольник")
        super().__setattr__(key, value)

    @staticmethod
    def __is_triangle(a, b, c):
        if a and b and c:
            return a < b + c and b < a + c and c < a + b
        return True

    def __len__(self):
        return self.a + self.b + self.c if self.a and self.b and self.c else None

    def __call__(self, *args, **kwargs):
        a, b, c = self.a, self.b, self.c
        if not(a and b and c):
            return

        p = 0.5 * (a + b + c)
        return (p * (p - a) * (p - b) * (p - c)) ** 0.5


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.7 Метод __bool__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Пусть в программе объявлен следующий класс:
#
# class User:
#     def __init__(self, name, old):
#         self.name = name
#         self.old = old
#
#     def __len__(self):
#         return self.old
# И создаются два его экземпляра:
#
# user1 = User('Sergey', 45)
# user2 = User('Петр', 0)
# Отметьте все верные пункты выполнения функции bool().


# - bool(user1) вернет значение True, так как будет вызван магический метод __len__(), который вернет не нулевое
# значение
# - bool(user2) вернет значение False, так как будет вызван магический метод __len__(), который вернет нулевое значение


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Пусть в программе объявлен следующий класс:
#
# class User:
#     def __init__(self, name, old):
#         self.name = name
#         self.old = old
#
#     def __len__(self):
#         return self.old + 1
#
#     def __bool__(self):
#         return bool(self.old)
# И определены два его объекта:
#
# user1 = User('Sergey', 45)
# user2 = User('Петр', 0)

# Отметьте все верные пункты, связанные с использованием функции bool().


# - bool(user2) вернет значение False, так как будет вызван магический метод __bool__(), который вернет False
# - bool(user1) вернет значение True, так как будет вызван магический метод __bool__(), который вернет True


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен некоторый класс Book, в котором определен магический метод __bool__(). И создан
# объект book класса Book. Выберите все варианты команд, в которых будет происходить вызов
# магического метода __bool__().


# - res = bool(book)
# - if book: ...
# - while book: ...


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите в программе класс Player (игрок), объекты которого создаются командой:
#
# player = Player(name, old, score)
# где name - имя игрока (строка); old - возраст игрока (целое число); score - набранные очки в игре (целое число).
# В каждом объекте класса Player должны создаваться аналогичные локальные атрибуты: name, old, score.
#
# С объектами класса Player должна работать функция:
#
# bool(player)
# которая возвращает True, если число очков больше нуля, и False - в противном случае.
#
# С помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# считываются строки из входного потока в список строк lst_in. Каждая строка записана в формате:
#
# "имя; возраст; очки"
#
# Например:
#
# Балакирев; 34; 2048
# Mediel; 27; 0
# Влад; 18; 9012
# Nina P; 33; 0
#
# Каждую строку списка lst_in необходимо представить в виде объекта класса Player с соответствующими данными. И из
# этих объектов сформировать список players.
#
# Отфильтруйте этот список (создайте новый: players_filtered), оставив всех игроков с числом очков больше нуля.
# Используйте для этого стандартную функцию filter() совместно с функцией bool() языка Python.
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# Балакирев; 34; 2048
# Mediel; 27; 0
# Влад; 18; 9012
# Nina P; 33; 0
# Sample Output:


import sys

class Player:

    def __init__(self, name, old, score):
        self.name = name
        self.old = float(old)
        self.score = float(score)

    def __bool__(self):
        return self.score > 0


lst_in = list(map(str.strip, sys.stdin.readlines()))

lst = [[x.strip() for x in i.split(';')] for i in lst_in]
players = [Player(*values) for values in lst]

players_filtered = list(filter(lambda x: bool(x), players))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Объявите в программе класс MailBox (почтовый ящик), объекты которого создаются командой:
#
# mail = MailBox()
# Каждый объект этого класса должен содержать локальный публичный атрибут:
#
# inbox_list - список из принятых писем.
#
# Также в классе MailBox должен присутствовать метод:
#
# receive(self) - прием новых писем
#
# Этот метод должен читать данные из входного потока командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# В результате формируется список lst_in из строк. Каждая строка записана в формате:
#
# "от кого; заголовок; текст письма"
#
# Например:
#
# sc_lib@list.ru; От Балакирева; Успехов в IT!
# mail@list.ru; Выгодное предложение; Вам одобрен кредит.
# mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
#
# Каждая строчка списка lst_in должна быть представлена объектом класса MailItem, объекты которого создаются командой:
#
# item = MailItem(mail_from, title, content)
# где mail_from - email отправителя (строка); title - заголовок письма (строка), content - содержимое письма (строка).
# В каждом объекте класса MailItem должны формироваться соответствующие локальные
# атрибуты (с именами: mail_from, title, content). И дополнительно атрибут is_read (прочитано ли) с начальным
# значением False.
#
# В классе MailItem должен быть реализован метод:
#
# set_read(self, fl_read) - для отметки, что письмо прочитано (метод должен устанавливать
# атрибут is_read = fl_read, если True, то письмо прочитано, если False, то не прочитано).
#
# С каждым объектом класса MailItem должна работать функция:
#
# bool(item)
# которая возвращает True для прочитанного письма и False для непрочитанного.
#
# Вызовите метод:
#
# mail.receive()
# Отметьте первое и последнее письмо в списке mail.inbox_list, как прочитанное (используйте для этого метод set_read).
# Затем, сформируйте в программе список (глобальный) с именем inbox_list_filtered из прочитанных писем, используя
# стандартную функцию filter() совместно с функцией bool() языка Python.
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# sc_lib@list.ru; От Балакирева; Успехов в IT!
# mail@list.ru; Выгодное предложение; Вам одобрен кредит.
# mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
# Sample Output:


import sys

class MailBox:

    def __init__(self):
        self.inbox_list = []

    def receive(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))
        lst = [[i.strip() for i in x.split(';')] for x in lst_in]
        lst_in = [MailItem(*args) for args in lst]
        self.inbox_list.extend(lst_in)
        return


class MailItem:

    def __init__(self, mail_from, title, content):
        self.mail_from = mail_from
        self.title = title
        self.content = content
        self.is_read = False

    def set_read(self, fl_read):
        self.is_read = fl_read

    def __bool__(self):
        return self.is_read

mail = MailBox()
mail.receive()
mail.inbox_list[0].set_read(True)
mail.inbox_list[-1].set_read(True)
inbox_list_filtered = list(filter(bool, mail.inbox_list))



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6 (релакс). Объявите класс Line, объекты которого создаются командой:
#
# line = Line(x1, y1, x2, y2)
# где x1, y1, x2, y2 - координаты начала линии (x1, y1) и координаты конца линии (x2, y2). Могут быть произвольными
# числами. В объектах класса Line должны создаваться соответствующие локальные атрибуты с именами x1, y1, x2, y2.
#
# В классе Line определить магический метод __len__() так, чтобы функция:
#
# bool(line)
# возвращала False, если длина линии меньше 1.
#
# P.S. На экран ничего выводить не нужно. Только объявить класс.


class Line:

    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2

    def __len__(self):
        return int(((self.x2 - self.x1) ** 2 + (self.y2 - self.y1) ** 2) ** 0.5)

    def __bool__(self):
        return len(self) >= 1


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. Объявите класс Ellipse (эллипс), объекты которого создаются командами:
#
# el1 = Ellipse()  # без создания локальных атрибутов x1, y1, x2, y2
# el2 = Ellipse(x1, y1, x2, y2)
# где x1, y1 - координаты (числа) левого верхнего угла; x2, y2 - координаты (числа) нижнего правого угла. Первая
# команда создает объект класса Ellipse без локальных атрибутов x1, y1, x2, y2. Вторая команда создает объект с локальными атрибутами x1, y1, x2, y2 и соответствующими переданными значениями.
#
# В классе Ellipse объявите магический метод __bool__(), который бы возвращал True, если все локальные
# атрибуты x1, y1, x2, y2 существуют и False - в противном случае.
#
# Также в классе Ellipse нужно реализовать метод:
#
# get_coords() - для получения кортежа текущих координат объекта.
#
# Если координаты отсутствуют (нет локальных атрибутов x1, y1, x2, y2), то метод get_coords() должен генерировать
# исключение командой:
#
# raise AttributeError('нет координат для извлечения')
# Сформируйте в программе список с именем lst_geom, содержащий четыре объекта класса Ellipse. Два объекта должны быть
# созданы командой
#
# Ellipse()
# и еще два - командой:
#
# Ellipse(x1, y1, x2, y2)
# Переберите список в цикле и вызовите метод get_coords() только для объектов, имеющих координаты x1, y1, x2, y2.
# (Помните, что для этого был определен магический метод __bool__()).
#
# P.S. На экран ничего выводить не нужно.


class Ellipse:

    def __init__(self, *args):
        self.args = args
        if len(args) != 0:
            self.x1, self.y1, self.x2, self.y2 = args

    def __bool__(self):
        if self.args:
            return True
        return False

    def get_coords(self):
        if not bool(self):
            raise AttributeError('нет координат для извлечения')
        return (self.x1, self.y1, self.x2, self.y2)


lst_geom = [Ellipse(), Ellipse(), Ellipse(1, 2, 3, 4), Ellipse(4, 3, 2, 1)]

for i in lst_geom:
    if i:
        i.get_coords()


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/2lnbu3n7Y_w

# Большой подвиг 8. Вы начинаете разрабатывать игру "Сапер". Для этого вам нужно уметь представлять и управлять игровым
# полем. Будем полагать, что оно имеет размеры N x M клеток. Каждая клетка будет представлена объектом класса Cell и
# содержать либо число мин вокруг этой клетки, либо саму мину.

# Для начала в программе объявите класс GamePole, который будет создавать и управлять игровым полем. Объект этого
# класса должен формироваться командой:
#
# pole = GamePole(N, M, total_mines)
# И, так как поле в игре одно, то нужно контролировать создание только одного объекта класса
# GamePole (используйте паттерн Singleton, о котором мы с вами говорили, когда рассматривали
# магический метод __new__()).
#
# Объект pole должен иметь локальный приватный атрибут:
#
# __pole_cells - двумерный (вложенный) кортеж, размерами N x M элементов (N строк и M столбцов), состоящий из объектов
# класса Cell.
#
# Для доступа к этой коллекции объявите в классе GamePole объект-свойство (property):
#
# pole - только для чтения (получения) ссылки на коллекцию __pole_cells.
#
# Далее, в самом классе GamePole объявите следующие методы:
#
# init_pole() - для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми);
# open_cell(i, j) - открывает ячейку с индексами (i, j); нумерация индексов начинается с нуля; метод меняет значение
# атрибута __is_open объекта Cell в ячейке (i, j) на True;
# show_pole() - отображает игровое поле в консоли (как именно сделать - на ваше усмотрение, этот метод - домашнее
# задание).
#
# Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией randint
# модуля random). После расстановки всех total_mines мин, вычислите их количество вокруг остальных
# клеток (где нет мин). Область охвата - соседние (прилегающие) клетки (8 штук).
#
# В методе open_cell() необходимо проверять корректность индексов (i, j). Если индексы указаны некорректно, то
# генерируется исключение командой:
#
# raise IndexError('некорректные индексы i, j клетки игрового поля')
# Следующий класс Cell описывает состояние одной ячейки игрового поля. Объекты этого класса создаются командой:
#
# cell = Cell()
# При этом в самом объекте создаются следующие локальные приватные свойства:
#
# __is_mine - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
# __number - число мин вокруг клетки (целое число от 0 до 8);
# __is_open - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.
#
# Для работы с этими приватными атрибутами объявите в классе Cell следующие объекты-свойства с именами:
#
# is_mine - для записи и чтения информации из атрибута __is_mine;
# number - для записи и чтения информации из атрибута __number;
# is_open - для записи и чтения информации из атрибута __is_open.
#
# В этих свойствах необходимо выполнять проверку на корректность переданных значений (либо булево значение True/False,
# либо целое число от 0 до 8). Если передаваемое значение некорректно, то генерировать исключение командой:
#
# raise ValueError("недопустимое значение атрибута")
# С объектами класса Cell должна работать функция:
#
# bool(cell)
# которая возвращает True, если клетка закрыта и False - если открыта.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# pole = GamePole(10, 20, 10)  # создается поле размерами 10x20 с общим числом мин 10
# pole.init_pole()
# if pole.pole[0][1]:
#     pole.open_cell(0, 1)
# if pole.pole[3][5]:
#     pole.open_cell(3, 5)
# pole.open_cell(30, 100)  # генерируется исключение IndexError
# pole.show_pole()
# P.S. В программе на экран выводить ничего не нужно, только объявить классы.


from random import randint
class Cell:
    def __init__(self):
        self.__is_mine = False
        self.__number = 0
        self.__is_open = False

    def __check_value(self, val):
        if type(val) == bool:
            return val
        elif 0 <= val <= 8:
            return val
        else:
            raise ValueError("недопустимое значение атрибута")

    @property
    def is_mine(self):
        return self.__is_mine

    @is_mine.setter
    def is_mine(self, val):
        self.__check_value(val)
        self.__is_mine = val

    @property
    def number(self):
        return self.__number

    @number.setter
    def number(self, val):
        self.__check_value(val)
        self.__number = val

    @property
    def is_open(self):
        return self.__is_open

    @is_open.setter
    def is_open(self, value):
        self.__check_value(value)
        self.__is_open = value

    def __bool__(self):
        return False if self.is_open else True



class GamePole:
    __instance = None

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)
        return cls.__instance

    def __init__(self, N, M, total_mines):
        self.n = N
        self.m = M
        self.total_mines = total_mines
        self.__pole_cells = [[Cell() for n in range(self.m)] for n in range(self.n)]

    @property
    def pole(self):
        return self.__pole_cells

    def init_pole(self):
        m = 0
        while m < self.total_mines:
            i = randint(0, 8)
            j = randint(0, 8)
            if self.pole[i][j].is_mine:
                continue
            self.pole[i][j].is_mine = True
            m += 1

        indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
        for x in range(self.n):
            for y in range(self.n):
                if not self.pole[x][y].is_mine:
                    mines = sum((self.pole[x+i][y+j].is_mine for i, j in indx if 0 <= x+i < self.n and 0 <= y+j < self.n))
                    self.pole[x][y].number = mines


    def show_pole(self):
        for row in self.pole:
            print(*map(lambda x: "#" if not x.is_open else x.number if not x.is_mine else "*", row))

    def open_cell(self, i: int, j):
        try:
            self.pole[i][j].is_open = True
        except:
            raise IndexError('некорректные индексы i, j клетки игрового поля')


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (на повторение). Объявите в программе класс Vector, объекты которого создаются командой:
#
# v = Vector(x1, x2, x3,..., xN)
# где x1, x2, x3,..., xN - координаты вектора (числа: целые или вещественные).
#
# С каждым объектом класса Vector должны выполняться операторы:
#
# v1 + v2 # суммирование соответствующих координат векторов
# v1 - v2 # вычитание соответствующих координат векторов
# v1 * v2 # умножение соответствующих координат векторов
#
# v1 += 10 # прибавление ко всем координатам вектора числа 10
# v1 -= 10 # вычитание из всех координат вектора числа 10
# v1 += v2
# v2 -= v1
#
# v1 == v2 # True, если соответствующие координаты векторов равны
# v1 != v2 # True, если хотя бы одна пара координат векторов не совпадает
# При реализации бинарных операторов +, -, * следует создавать новые объекты класса Vector с новыми (вычисленными)
# координатами. При реализации операторов +=, -= координаты меняются в текущем объекте, не создавая новый.
#
# Если число координат (размерность) векторов v1 и v2 не совпадает, то при операторах +, -, * должно генерироваться
# исключение командой:
#
# raise ArithmeticError('размерности векторов не совпадают')
# P.S. В программе на экран выводить ничего не нужно, только объявить класс.


import operator as op


class Vector:
    def __init__(self, *args):
        self.coords = args

    def __len__(self):
        return len(self.coords)

    def __do(self, other, f_name, new_object=True):
        if isinstance(other, self.__class__) and len(other) == len(self):
            new_coords = (f_name(a, b) for a, b in zip(self.coords, other.coords))
        elif isinstance(other, (int, float)):
            new_coords = (f_name(b, other) for b in self.coords)
        else:
            raise ArithmeticError('размерности векторов не совпадают')
        if new_object:
            return self.__class__(*new_coords, )
        else:
            self.coords = (*new_coords,)
            return self

    def __add__(self, other):
        return self.__do(other, op.add)

    def __sub__(self, other):
        return self.__do(other, op.sub)

    def __mul__(self, other):
        return self.__do(other, op.mul)

    def __iadd__(self, other):
        return self.__do(other, op.add, False)

    def __isub__(self, other):
        return self.__do(other, op.sub, False)

    def __imul__(self, other):
        return self.__do(other, op.mul, False)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.coords == other.coords
        raise TypeError('Сравнение векторов не возможно!')


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.8 Методы __getitem__, __setitem__ и __delitem__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствия между магическими методами и их описаниями.

# - __getitem__() - получение значения по ключу item
# - __setitem__() - запись значения value по ключу key
# - __delitem__() - удаление элемента по ключу key
# - __setattr__() - вызывается при изменении атрибута класса или объекта
# - __getattribute__() - вызывается при обращении к атрибуту класса или объекта
# - __delattr__() - вызывается при удалении атрибута класса или объекта


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/FWp5trS42e4
#
# Подвиг 2. Объявите класс Record (запись), который описывает одну произвольную запись из БД. Объекты этого класса
# создаются командой:
#
# r = Record(field_name1=value1,... , field_nameN=valueN)
# где field_nameX - наименование поля БД; valueX - значение поля из БД.
#
# В каждом объекте класса Record должны автоматически создаваться локальные публичные атрибуты по именам
# полей (field_name1,... , field_nameN) с соответствующими значениями. Например:
#
# r = Record(pk=1, title='Python ООП', author='Балакирев')
# В объекте r появляются атрибуты:
#
# r.pk # 1
# r.title # Python ООП
# r.author # Балакирев
# Также необходимо обеспечить доступ к этим полям (чтение/запись) через индексы следующим образом:
#
# r[0] = 2 # доступ к полю pk
# r[1] = 'Супер курс по ООП' # доступ к полю title
# r[2] = 'Балакирев С.М.' # доступ к полю author
# print(r[1]) # Супер курс по ООП
# r[3] # генерируется исключение IndexError
# Если указывается неверный индекс (не целое число или некорректное целое число), то должно генерироваться исключение
# командой:
#
# raise IndexError('неверный индекс поля')

# P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.
#
# P.P.S. Для создания локальных атрибутов используйте коллекцию __dict__ объекта класса Record.


class Record:

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
        self.__total_attrs = len(kwargs)
        self.__attrs = tuple(self.__dict__.keys())

    def __check_index(self, index):
        if type(index) != int or not(-self.__total_attrs <= index < self.__total_attrs):
            raise IndexError('неверный индекс поля')

    def __getitem__(self, item):
        self.__check_index(item)
        return getattr(self, self.__attrs[item])

    def __setitem__(self, key, value):
        self.__check_index(key)
        setattr(self, self.__attrs[key], value)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Вам необходимо для навигатора реализовать определение маршрутов. Для этого в программе нужно объявить класс
# Track, объекты которого создаются командой:
#
# tr = Track(start_x, start_y)
# где start_x, start_y - координата начала пути.
#
# В этом классе должен быть реализован следующий метод:
#
# add_point(x, y, speed) - добавление новой точки маршрута (линейный сегмент), который можно пройти со средней
# скоростью speed.
#
# Также с объектами класса Track должны выполняться команды:
#
# coord, speed = tr[indx] # получение координаты (кортеж с двумя числами) и скорости (число) для линейного сегмента
# маршрута с индексом indx
# tr[indx] = speed # изменение средней скорости линейного участка маршрута по индексу indx
# Если индекс (indx) указан некорректно (должен быть целым числом от 0 до N-1, где N - число линейных сегментов в
# маршруте), то генерируется исключение командой:
#
# raise IndexError('некорректный индекс')
# Пример использования класса (эти строчки в программе не писать):
#
# tr = Track(10, -5.4)
# tr.add_point(20, 0, 100) # первый линейный сегмент: indx = 0
# tr.add_point(50, -20, 80) # второй линейный сегмент: indx = 1
# tr.add_point(63.45, 1.24, 60.34) # третий линейный сегмент: indx = 2
#
# tr[2] = 60
# c, s = tr[2]
# print(c, s)
#
# res = tr[3] # IndexError
# P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.


class Track:

    def __init__(self, start_x, start_y):
        self.start_x = start_x
        self.start_y = start_y
        self.points = []
        self.__atrs = len(self.points)

    def __check_index(self, indx):
        if type(indx) != int or indx not in range(len(self.points)):
            raise IndexError('некорректный индекс')

    def add_point(self, x, y, speed):
        self.points.append([(x, y), speed])
        return self

    def __getitem__(self, item):
        self.__check_index(item)
        return self.points[item]

    def __setitem__(self, key, value):
        self.__check_index(key)
        self.points[key][1] = value



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/tS-tJR8_6to
#
# Подвиг 4. Вам необходимо написать программу по работе с массивом однотипных данных (например, только числа или
# строки и т.п.). Для этого нужно объявить класс с именем Array, объекты которого создаются командой:
#
# ar = Array(max_length, cell)
# где max_length - максимальное количество элементов в массиве; cell - ссылка на класс, описывающий отдельный элемент
# этого массива (см. далее, класс Integer). Начальные значения в ячейках массива (в объектах класса Integer) должны
# быть равны 0.
#
# Для работы с целыми числами объявите в программе еще один класс с именем Integer, объекты которого создаются командой:
#
# cell = Integer(start_value)
# где start_value - начальное значение ячейки (в данном случае - целое число).
#
# В классе Integer должно быть следующее свойство (property):
#
# value - для изменения и считывания значения из ячейки (само значение хранится в локальной приватной переменной;
# имя придумайте сами).
#
# При попытке присвоить не целое число должно генерироваться исключение командой:
#
# raise ValueError('должно быть целое число')
# Для обращения к отдельным элементам массива в классе Array необходимо определить набор магических методов для
# следующих операций:
#
# value = ar[0] # получение значения из первого элемента (ячейки) массива ar
# ar[1] = value # запись нового значения во вторую ячейку массива ar
# Если индекс не целое число или число меньше нуля или больше либо равно max_length, то должно генерироваться
# исключение командой:
#
# raise IndexError('неверный индекс для доступа к элементам массива')
# Пример использования классов (эти строчки в программе не писать):
#
# ar_int = Array(10, cell=Integer)
# print(ar_int[3])
# print(ar_int) # должны отображаться все значения массива в одну строчку через пробел
# ar_int[1] = 10
# ar_int[1] = 10.5 # должно генерироваться исключение ValueError
# ar_int[10] = 1 # должно генерироваться исключение IndexError
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
#
# P.P.S. В качестве дополнительного домашнего задания: объявите еще один класс Float для работы с вещественными
# числами и создайте массив, используя тот же класс Array, с этим новым типом данных.


class Array:
    def __init__(self, max_length, cell):
        self.max_length = max_length
        self.cell = cell
        self.lst = [cell() for _ in range(max_length)]

    def __getitem__(self, item):
        if not isinstance(item, int) or 0 > item >= self.max_length:
            raise IndexError('неверный индекс для доступа к элементам массива')
        return self.lst[item].value

    def __setitem__(self, key, value):
        if not isinstance(key, int) or 0 > key >= self.max_length:
            raise IndexError('неверный индекс для доступа к элементам массива')
        self.lst[key].value = value

    def __str__(self):
        return " ".join([str(obj.value) for obj in self.lst])


class Integer:
    def __init__(self, start_value=0):
        self.__start_value = start_value

    @property
    def value(self):
        return self.__start_value

    @value.setter
    def value(self, x):
        if type(x) != int:
            raise ValueError('должно быть целое число')
        self.__start_value = x


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/K4gQTe7DrHk
#
# Большой подвиг 5. Вам необходимо написать программу для удобного обращения с таблицами однотипных
# данных (чисел, строк, булевых значений и т.п.), то есть, все ячейки таблицы должны представлять какой-то один
# указанный тип.

# Для этого в программе необходимо объявить три класса:
#
# TableValues - для работы с таблицей в целом;
# CellInteger - для операций с целыми числами;
# IntegerValue - дескриптор данных для работы с целыми числами.
#
# Начнем с дескриптора IntegerValue. Это должен быть дескриптор данных (то есть, и для записи и считывания значений).
# Если присваиваемое значение не является целым числом, должно генерироваться исключение командой:
#
# raise ValueError('возможны только целочисленные значения')
# Следующий класс CellInteger описывает одну ячейку таблицы для работы с целыми числами. В этом классе должен быть
# публичный атрибут (атрибут класса):
#
# value - объект дескриптора, класса IntegerValue.
#
# А объекты класса CellInteger должны создаваться командой:
#
# cell = CellInteger(start_value)
# где start_value - начальное значение ячейки (по умолчанию равно 0 и сохраняется в ячейке через дескриптор value).
#
# Наконец, объекты последнего класса TableValues создаются командой:
#
# table = TableValues(rows, cols, cell=CellInteger)
# где rows, cols - число строк и столбцов (целые числа); cell - ссылка на класс, описывающий работу с отдельными
# ячейками таблицы. Если параметр cell не указан, то генерировать исключение командой:
#
# raise ValueError('параметр cell не указан')
# Иначе, в объекте table класса TableValues создается двумерный (вложенный) кортеж с именем cells
# размером rows x cols, состоящий из объектов указанного класса (в данном примере - класса CellInteger).
#
# Также в классе TableValues предусмотреть возможность обращения к отдельной ячейке по ее индексам, например:
#
# value = table[1, 2] # возвращает значение ячейки с индексом (1, 2)
# table[0, 0] = value # записывает новое значение в ячейку (0, 0)
# Обратите внимание, по индексам сразу должно возвращаться значение ячейки, а не объект класса CellInteger. И
# то же самое с присваиванием нового значения.
#
# Пример использования классов (эти строчки в программе не писать):
#
# table = TableValues(2, 3, cell=CellInteger)
# print(table[0, 1])
# table[1, 1] = 10
# table[0, 0] = 1.45 # генерируется исключение ValueError
#
# # вывод таблицы в консоль
# for row in table.cells:
#     for x in row:
#         print(x.value, end=' ')
#     print()
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
#
# P.P.S. В качестве домашнего задания создайте класс CellString для работы со строками и используйте тот же класс
# TableValues для этого нового типа данных.
#
# Последнее: дескрипторы здесь для повторения. В реальной разработке лучше использовать в таких задачах
# объекты-свойства (property).


class IntegerValue:

    def __set_name__(self, owner, name):
        self.name = '__' + name

    def __get__(self, instance, owner):
        return getattr(instance,self.name)

    def __set__(self, instance, value):
        self.__check_value(value)
        setattr(instance, self.name, value)

    def __check_value(self, value):
        if type(value) != int:
            raise ValueError('возможны только целочисленные значения')
        return True


class CellInteger:

    value = IntegerValue()

    def __init__(self, start_value=0):
        self.value = start_value


class TableValues:

    def __new__(cls, *args, **kwargs):
        if not kwargs:
            raise ValueError('параметр cell не указан')
        return super().__new__(cls)

    def __init__(self, rows, cols, cell=CellInteger):
        self.rows = rows
        self.cols = cols
        self.cell = cell
        self.cells = [[cell() for _ in range(self.cols)] for _ in range(self.rows)]

    def __getitem__(self, item):
        i, j = item
        return self.cells[i][j].value

    def __setitem__(self, key, value):
        i, j = key
        self.cells[i][j].value = value


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/jk9AOnvm65k
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 6. Ранее вы уже создавали стек-подобную структуру, когда один объект ссылается на следующий и так по цепочке до последнего:
#
#
#
# Для этого в программе объявлялись два класса:
#
# StackObj - для описания объектов стека;
# Stack - для управления стек-подобной структурой.
#
# И, далее, объекты класса StackObj следовало создавать командой:
#
# obj = StackObj(data)
# где data - это строка с некоторым содержимым объекта (данными). При этом каждый объект класса StackObj должен иметь следующие локальные атрибуты:
#
# data - ссылка на строку с данными, указанными при создании объекта;
# next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).
#
# Класс Stack предполагается использовать следующим образом:
#
# st = Stack() # создание объекта стек-подобной структуры
# В каждом объекте класса Stack должен быть локальный публичный атрибут:
#
# top - ссылка на первый объект стека (если стек пуст, то top = None).
#
# А в самом классе Stack следующие методы:
#
# push(self, obj) - добавление объекта класса StackObj в конец стека;
# pop(self) - извлечение последнего объекта с его удалением из стека;
#
# Дополнительно в классе Stack нужно объявить магические методы для обращения к объекту стека по его индексу, например:
#
# obj_top = st[0] # получение первого объекта
# obj = st[4] # получение 5-го объекта стека
# st[2] = StackObj("obj3") # замена прежнего (3-го) объекта стека на новый
# Если индекс не целое число или число меньше нуля или больше числа объектов в стеке, то должно генерироваться исключение командой:
#
# raise IndexError('неверный индекс')
# Пример использования классов Stack и StackObj (эти строчки в программе не писать):
#
# st = Stack()
# st.push(StackObj("obj1"))
# st.push(StackObj("obj2"))
# st.push(StackObj("obj3"))
# st[1] = StackObj("new obj2")
# print(st[2].data) # obj3
# print(st[1].data) # new obj2
# res = st[3] # исключение IndexError
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class StackObj:

    def __init__(self, data):
        self.data = data
        self.next = None


class Stack:

    def __init__(self):
        self.top = None

    def push(self, obj):
        if self.top is None:
            self.top = obj
            return

        ex = self.top
        while ex.next is not None:
            ex = ex.next
        ex.next = obj
        return

    def pop(self):
        res = self[len(self) - 1]
        self[len(self) - 2].next = None
        return res

    def __len__(self):
        res = 0
        if self.top is None:
            return res

        res += 1
        node = self.top
        while node.next is not None:
            res += 1
            node = node.next
        return res

    def check_indx(self, indx):
        if type(indx) != int or not (0 <= indx < len(self)):
            raise IndexError('неверный индекс')
        return True

    def __getitem__(self, item):
        self.check_indx(item)
        count = 0
        node = self.top
        while count != item:
            node = node.next
            count += 1
        return node

    def __setitem__(self, key, value):
        self.check_indx(key)
        count = 0
        node = self.top
        while count + 1 != key:
            node = node.next
            count += 1
        ex = node.next.next
        node.next = value
        value.next = ex


    def show(self):
        res = []
        node = self.top
        while node.next is not None:
            res.append(node.data)
            node = node.next
        res.append(node.data)
        print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/QtOqF78VlHM
#
# Подвиг 7 (познание срезов). Объявите в программе класс с именем RadiusVector (радиус-вектор), объекты которого
# создаются командой:
#
# v = RadiusVector(x1, x2,..., xN)
# где x1, x2,..., xN - координаты радиус-вектора (числа: целые или вещественные).
#
# В каждом объекте класса RadiusVector должен быть локальный атрибут:
#
# coords - список из координат радиус-вектора.
#
# Для доступа к отдельным координатам, реализовать следующий функционал:
#
# coord = v[i] # получение значения i-й координаты (целое число, отсчет с нуля)
# coords_1 = v[start:stop] # получение среза (набора) координат в виде кортежа
# coords_2 = v[start:stop:step] # получение среза (набора) координат в виде кортежа
# v[i] = value # изменение i-й координаты
# v[start:stop] = [val_1, val_2, ...] # изменение сразу нескольких координат
# v[start:stop:step] = [val_1, val_2, ...] # изменение сразу нескольких координат
# Пример использования класса (эти строчки в программе не писать):
#
# v = RadiusVector(1, 1, 1, 1)
# print(v[1]) # 1
# v[:] = 1, 2, 3, 4
# print(v[2]) # 3
# print(v[1:]) # (2, 3, 4)
# v[0] = 10.5
# P.S. При передаче среза в магических методах __setitem__() и __getitem__() параметр индекса становится объектом
# класса slice. Его можно указывать непосредственно в квадратных скобках упорядоченных
# коллекций (списков, кортежей и т.п.).


class RadiusVector:

    def __init__(self, *args):
        self.coords = list(args)

    def __getitem__(self, item):
        return tuple(self.coords[item]) if type(item) == slice else self.coords[item]

    def __setitem__(self, key, value):
        self.coords[key] = value


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Uk-cA4xC9fc
#
# Подвиг 8. Вам нужно реализовать в программе игровое поле для игры "Крестики-нолики". Для этого требуется объявить
# класс TicTacToe (крестики-нолики), объекты которого создаются командой:
#
# game = TicTacToe()
# Каждый объект game должен иметь публичный атрибут:
#
# pole - игровое поле: кортеж размером 3х3 с объектами класса Cell.
#
# Каждая клетка игрового поля представляется объектом класса Cell и создается командой:
#
# cell = Cell()
# Объекты класса Cell должны иметь следующие публичные локальные атрибуты:
#
# is_free - True, если клетка свободна; False в противном случае;
# value - значение поля: 1 - крестик; 2 - нолик (по умолчанию 0).
#
# Также с каждым объектом класса Cell должна работать функция:
#
# bool(cell)
# которая возвращает True, если клетка свободна (cell.is_free=True) и False в противном случае.
#
# Класс TicTacToe должен иметь следующий метод:
#
# clear() - очистка игрового поля (все клетки заполняются нулями и переводятся в закрытое состояние);
#
# А объекты этого класса должны иметь следующую функциональность (обращение по индексам):
#
# game[0, 0] = 1 # установка нового значения, если поле закрыто
# res = game[1, 1] # получение значения центральной ячейки поля (возвращается число)
# Если указываются некорректные индексы, то должно генерироваться исключение командой:
#
# raise IndexError('неверный индекс клетки')
# Если идет попытка присвоить новое значение в открытую клетку поля, то генерировать исключение:
#
# raise ValueError('клетка уже занята')
# Также должны быть реализованы следующие полные срезы при обращении к клеткам игрового поля:
#
# slice_1 = game[:, indx] # выбираются все элементы (кортеж) столбца с индексом indx
# slice_2 = game[indx, :] # выбираются все элементы (кортеж) строки с индексом indx
# Пример использования классов (эти строчки в программе не писать):
#
# game = TicTacToe()
# game.clear()
# game[0, 0] = 1
# game[1, 0] = 2
# # формируется поле:
# # 1 0 0
# # 2 0 0
# # 0 0 0
# game[3, 2] = 2 # генерируется исключение IndexError
# if game[0, 0] == 0:
#     game[0, 0] = 2
# v1 = game[0, :]  # 1, 0, 0
# v2 = game[:, 0]  # 1, 2, 0
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
#
# P.P.S. При передаче среза в магических методах __setitem__() и __getitem__() параметр индекса становится объектом
# класса slice. Его можно указывать непосредственно в квадратных скобках упорядоченных
# коллекций (списков, кортежей и т.п.).


class Cell:
    def __init__(self):
        self.is_free = True
        self.value = 0

    def __bool__(self):
        return self.is_free


class TicTacToe:
    def __init__(self):
        self.pole = None
        self.clear()

    def clear(self):
        self.pole = [[Cell() for _ in '...'] for _ in '...']

    def show(self):
        for row in self.pole:
            for cell in row:
                print(cell.value, end=' ')
            print()

    def __check(self, coords):
        if any(x not in range(3) for x in coords if not isinstance(x, slice)):
            raise IndexError('неверный индекс клетки')

    def __setitem__(self, key, value):
        self.__check(key)
        r, c = key
        if self.pole[r][c]:
            self.pole[r][c].value = value
            self.pole[r][c].is_free = False
        else:
            raise ValueError('клетка уже занята')

    def __getitem__(self, item):
        self.__check(item)
        r, c = item
        if isinstance(r, slice):
            return tuple(self.pole[x][c].value for x in range(3))
        if isinstance(c, slice):
            return tuple(self.pole[r][x].value for x in range(3))
        return self.pole[r][c].value


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/dFdXOJwMc0E
#
# Подвиг 9 (релакс). Объявите в программе класс Bag (сумка), объекты которого создаются командой:
#
# bag = Bag(max_weight)
# где max_weight - максимальный суммарный вес предметов, который можно положить в сумку.
#
# Каждый предмет описывается классом Thing и создается командой:
#
# t = Thing(name, weight)
# где name - название предмета (строка); weight - вес предмета (вещественное или целочисленное значение). В объектах
# класса Thing должны автоматически формироваться локальные свойства с теми же именами: name и weight.
#
# В классе Bag должен быть реализован метод:
#
# add_thing(thing) - добавление нового объекта thing класса Thing в сумку.
#
# Добавление выполняется только если суммарный вес вещей не превышает параметра max_weight. Иначе, генерируется
# исключение:
#
# raise ValueError('превышен суммарный вес предметов')
# Также с объектами класса Bag должны выполняться следующие команды:
#
# t = bag[indx] # получение объекта класса Thing по индексу indx (в порядке добавления вещей, начиная с 0)
# bag[indx] = t # замена прежней вещи на новую t, расположенной по индексу indx
# del bag[indx] # удаление вещи из сумки, расположенной по индексу indx
# Если индекс в этих командах указывается неверно, то должно генерироваться исключение:
#
# raise IndexError('неверный индекс')
# Пример использования классов (эти строчки в программе не писать):
#
# bag = Bag(1000)
# bag.add_thing(Thing('книга', 100))
# bag.add_thing(Thing('носки', 200))
# bag.add_thing(Thing('рубашка', 500))
# bag.add_thing(Thing('ножницы', 300)) # генерируется исключение ValueError
# print(bag[2].name) # рубашка
# bag[1] = Thing('платок', 100)
# print(bag[1].name) # платок
# del bag[0]
# print(bag[0].name) # платок
# t = bag[4] # генерируется исключение IndexError
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Bag:

    def __init__(self, max_weight):
        self.max_weight = max_weight
        self.things = []

    def actual_weight(self):
        actual_weight = sum(map(lambda x: x.weight, self.things))
        return actual_weight

    def add_thing(self, thing):
        if not self.actual_weight() + thing.weight <= self.max_weight:
            raise ValueError('превышен суммарный вес предметов')
        self.things.append(thing)

    def check_indx(self, indx):
        if 0 > indx > len(self.things) - 1:
            raise IndexError('неверный индекс')

    def __getitem__(self, item):
        self.check_indx(item)
        return self.things[item]

    def __setitem__(self, key, value):
        self.check_indx(key)
        if not self.actual_weight() - self.things[key].weight + value.weight <= self.max_weight:
            raise ValueError('превышен суммарный вес предметов')
        self.things[key] = value

    def __delitem__(self, key):
        self.check_indx(key)
        del self.things[key]


class Thing:

    def __init__(self, name, weight):
        self.name = name
        self.weight = weight


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/oKBKLVb21nY
#
# Подвиг 10. Вам необходимо описывать в программе очень большие и разреженные таблицы данных (с большим числом
# пропусков). Для этого предлагается объявить класс SparseTable, объекты которого создаются командой:
#
# st = SparseTable()
# В каждом объекте этого класса должны создаваться локальные публичные атрибуты:
#
# rows - общее число строк таблицы (начальное значение 0);
# cols - общее число столбцов таблицы (начальное значение 0).
#
# В самом классе SparseTable должны быть объявлены методы:
#
# add_data(row, col, data) - добавление данных data (объект класса Cell) в таблицу по индексам row, col (целые
# неотрицательные числа);
# remove_data(row, col) - удаление ячейки (объект класса Cell) с индексами (row, col).
#
# При удалении/добавлении новой ячейки должны автоматически пересчитываться атрибуты rows, cols объекта класса
# SparseTable. Если происходит попытка удалить несуществующую ячейку, то должно генерироваться исключение:
#
# raise IndexError('ячейка с указанными индексами не существует')
# Ячейки таблицы представляют собой объекты класса Cell, которые создаются командой:
#
# data = Cell(value)
# где value - данные ячейки (любой тип).
#
# Хранить ячейки следует в словаре, ключами которого являются индексы (кортеж) i, j, а значениями - объекты класса Cell.
#
# Также с объектами класса SparseTable должны выполняться команды:
#
# res = st[i, j] # получение данных из таблицы по индексам (i, j)
# st[i, j] = value # запись новых данных по индексам (i, j)
# Чтение данных возможно только для существующих ячеек. Если ячейки с указанными индексами нет, то генерировать
# исключение командой:
#
# raise ValueError('данные по указанным индексам отсутствуют')
# При записи новых значений их следует менять в существующей ячейке или добавлять новую, если ячейка с индексами
# (i, j) отсутствует в таблице. (Не забывайте при этом пересчитывать атрибуты rows и cols).
#
# Пример использования классов (эти строчки в программе не писать):
#
# st = SparseTable()
# st.add_data(2, 5, Cell("cell_25"))
# st.add_data(0, 0, Cell("cell_00"))
# st[2, 5] = 25 # изменение значения существующей ячейки
# st[11, 7] = 'cell_117' # создание новой ячейки
# print(st[0, 0]) # cell_00
# st.remove_data(2, 5)
# print(st.rows, st.cols) # 12, 8 - общее число строк и столбцов в таблице
# val = st[2, 5] # ValueError
# st.remove_data(12, 3) # IndexError
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class SparseTable:

    def __init__(self):
        self.table = {}

    @property
    def rows(self):
        return max(i[0] for i in self.table) + 1 if self.table else 0

    @property
    def cols(self):
        return max(i[1] for i in self.table) + 1 if self.table else 0

    def add_data(self, row, col, data):
        self.table[row, col] = data

    def remove_data(self, row, col):
        if not(row, col) in self.table:
            raise IndexError('ячейка с указанными индексами не существует')
        del self.table[row, col]

    def __getitem__(self, item):
        if not item in self.table:
            raise ValueError('данные по указанным индексам отсутствуют')
        return self.table[item].value

    def __setitem__(self, key, value):
        self.table.setdefault(key, Cell(0)).value = value


class Cell:

    def __init__(self, value):
        self.value = value


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 3.9 Методы __iter__ и __next__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Отметьте все формулировки справедливые для итератора.

# - это объект, который контролирует перебор элементов некоторой коллекции в заданном порядке
# - в общем случае, для каждого типа коллекции создается свой итератор, но взаимодействие с ним (итератором) происходит
# по единому алгоритму
# - для полноценной работы с объектом-итератором в нем должны быть определены магические методы __iter__() и __next__()
# - это объект, который обеспечивает стандартный интерфейс для перебора элементов коллекции в заданном порядке


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Выберите верное объяснение разницы в работе двух следующих фрагментов программ:
#
# 1-й вариант:
#
# r = range(1, 3000)
# res1 = 2022 in r   # res1 = True
# res2 = 2022 in r   # res2 = True
# 2-й вариант:
#
# r = iter(range(1, 3000))
# res1 = 2022 in r   # res1 = True
# res2 = 2022 in r   # res1 = False


# В первом варианте объект range в операторе in каждый раз возвращает новый итератор и перебор последовательности
# начинается с начала. Во втором варианте явно указывается итератор, который в строчке res2 = 2022 in r продолжает
# перебор последовательности с числа 2023.


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен класс для реализации геометрической прогрессии:
#
# class GeomRange:
#     def __init__(self, start, step, stop):
#         self.start = start
#         self.step = step
#         self.stop = stop
#         self.__value = self.start
#
#     def __next__(self):
#         if self.__value < self.stop:
#             ret_value = self.__value
#             self.__value *= self.step
#             return ret_value
#         else:
#             raise StopIteration
# И создается объект этого класса командой:
#
# g = GeomRange(1, 1.2, 2)
# Отметьте все строчки, которые будут выполнены без ошибок.


# - res = next(g)
# - res = next(g); res = next(g)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Добавим в класс реализации геометрической прогрессии еще один магический метод __iter__():
#
# class GeomRange:
#     def __init__(self, start, step, stop):
#         self.start = start
#         self.step = step
#         self.stop = stop
#         self.__value = self.start
#
#     def __next__(self):
#         if self.__value < self.stop:
#             ret_value = self.__value
#             self.__value *= self.step
#             return ret_value
#         else:
#             raise StopIteration
#
#     def __iter__(self):
#         self.__value = self.start
#         return self
# Далее, создается объект этого класса командой:
#
# g = GeomRange(1, 1.2, 2)
# Отметьте все строчки, которые будут выполнены без ошибок для такого измененного объекта.


# - for x in g: print(x)
# - res = next(g)
# - for x in g: print(x); for x in g: print(x)
# - it = iter(g); res = next(g)
# - res = next(g); res = next(g)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/-ZvYUtWMUFw
#
# Подвиг 5. Объявите в программе класс Person, объекты которого создаются командой:
#
# p = Person(fio, job, old, salary, year_job)
# где fio - ФИО сотрудника (строка); job - наименование должности (строка); old - возраст (целое число);
# salary - зарплата (число: целое или вещественное); year_job - непрерывный стаж на указанном месте
# работы (целое число).
#
# В каждом объекте класса Person автоматически должны создаваться локальные атрибуты с такими же
# именами: fio, job, old, salary, year_job и соответствующими значениями.
#
# Также с объектами класса Person должны поддерживаться следующие команды:
#
# data = p[indx] # получение данных по порядковому номеру (indx) атрибута (порядок: fio, job, old, salary,
# year_job и начинается с нуля)
# p[indx] = value # запись в поле с указанным индексом (indx) нового значения value
# for v in p: # перебор всех атрибутов объекта в порядке: fio, job, old, salary, year_job
#     print(v)
# При работе с индексами, проверить корректность значения indx. Оно должно быть целым числом в
# диапазоне [0; 4]. Иначе, генерировать исключение командой:
#
# raise IndexError('неверный индекс')
# Пример использования класса (эти строчки в программе не писать):
#
# pers = Person('Гейтс Б.', 'бизнесмен', 61, 1000000, 46)
# pers[0] = 'Балакирев С.М.'
# for v in pers:
#     print(v)
# pers[5] = 123 # IndexError
# P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.


class Person:

    def __init__(self, fio, job, old, salary, year_job):
        self.fio = fio
        self.job = job
        self.old = old
        self.salary = salary
        self.year_job = year_job
        self.data = {0: self.fio, 1: self.job, 2: self.old, 3: self.salary, 4: self.year_job}

    def check_indx(self, indx):
        if indx not in range(0, 5):
            raise IndexError('неверный индекс')
        return True

    def __getitem__(self, item):
        self.check_indx(item)
        return self.data[item]

    def __setitem__(self, key, value):
        self.check_indx(key)
        self.data[key] = value


# Второй вариант ----------------
class Person:
    def __init__(self, fio, job, old, salary, year_job):
        self.fio = fio
        self.job = job
        self.old = old
        self.salary = salary
        self.year_job = year_job

    def index_checker(self, indx):
        if not 0 <= indx <= 4:
            raise IndexError('неверный индекс')

    def __getitem__(self, indx):
        self.index_checker(indx)
        return self.__dict__[tuple(self.__dict__)[indx]]

    def __setitem__(self, key, value):
        self.index_checker(key)
        self.__dict__[tuple(self.__dict__)[key]] = value

    def __iter__(self):
        return iter(self.__dict__.values())


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/wfy7UyTSN_Y
#
# Подвиг 6. Вам дают задание разработать итератор для последовательного перебора элементов вложенных (двумерных)
# списков следующей структуры:
#
# lst = [[x00],
#        [x10, x11],
#        [x20, x21, x22],
#        [x30, x31, x32, x33],
#        ...
#       ]
# Для этого необходимо в программе объявить класс с именем TriangleListIterator, объекты которого создаются командой:
#
# it = TriangleListIterator(lst)
# где lst - ссылка на перебираемый список.
#
# Затем, с объектами класса TriangleListIterator должны быть доступны следующие операции:
#
# for x in it:  # последовательный перебор всех элементов списка: x00, x10, x11, x20, ...
#     print(x)
#
# it_iter = iter(it)
# x = next(it_iter)
# Итератор должен перебирать элементы списка по указанной треугольной форме. Даже если итератору на вход будет передан
# прямоугольная таблица (вложенный список), то ее перебор все равно должен осуществляться по треугольнику. Если же это
# невозможно (из-за структуры списка), то естественным образом должна возникать ошибка IndexError: index out of
# range (выход индекса за допустимый диапазон).
#
# P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.


class TriangleListIterator:
    def __init__(self, lst):
        self.lst = lst

    def __iter__(self):
        for i in range(len(self.lst)):
            for j in range(i + 1):
                yield self.lst[i][j]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/kxCAnaAqdOk
#
# Подвиг 7. Теперь, вам необходимо разработать итератор, который бы перебирал указанные столбцы двумерного списка.
# Список представляет собой двумерную таблицу из данных:
#
# lst = [[x11, x12, ..., x1N],
#        [x21, x22, ..., x2N],
#        ...
#        [xM1, xM2, ..., xMN]
#       ]
# Для этого в программе необходимо объявить класс с именем IterColumn, объекты которого создаются командой:
#
# it = IterColumn(lst, column)
# где lst - ссылка на двумерный список; column - индекс перебираемого столбца (отсчитывается от 0).
#
# Затем, с объектами класса IterColumn должны быть доступны следующие операции:
#
# it = IterColumn(lst, 1)
# for x in it:  # последовательный перебор всех элементов столбца списка: x12, x22, ..., xM2
#     print(x)
#
# it_iter = iter(it)
# x = next(it_iter)
# P.S. В программе нужно объявить только класс итератора. Выводить на экран ничего не нужно.


class IterColumn:

    def __init__(self, lst, column):
        self.lst = lst
        self.column = column

    def __iter__(self):
        for i in range(len(self.lst)):
            yield self.lst[i][self.column]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/WrZ1TMwuvis
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 8. Вы несколько раз уже делали стек-подобную структуру, когда объекты последовательно связаны между собой:


# Доведем ее функционал до конца. Для этого, по прежнему, нужно объявить классы:
#
# Stack - для представления стека в целом;
# StackObj - для представления отдельных объектов стека.
#
# В классе Stack должны быть методы:
#
# push_back(obj) - для добавления нового объекта obj в конец стека;
# push_front(obj) - для добавления нового объекта obj в начало стека.
#
# В каждом объекте класса Stack должен быть публичный атрибут:
#
# top - ссылка на первый объект стека (при пустом стеке top = None).
#
# Объекты класса StackObj создаются командой:
#
# obj = StackObj(data)
# где data - данные, хранящиеся в объекте стека (строка).
#
# Также в каждом объекте класса StackObj должны быть публичные атрибуты:
#
# data - ссылка на данные объекта;
# next - ссылка на следующий объект стека (если его нет, то next = None).
#
# Наконец, с объектами класса Stack должны выполняться следующие команды:
#
# st = Stack()
#
# st[indx] = value # замена прежних данных на новые по порядковому индексу (indx); отсчет начинается с нуля
# data = st[indx]  # получение данных из объекта стека по индексу
# n = len(st) # получение общего числа объектов стека
#
# for obj in st: # перебор объектов стека (с начала и до конца)
#     print(obj.data)  # отображение данных в консоль
# При работе с индексами (indx), нужно проверять их корректность. Должно быть целое число от 0 до N-1, где N - число
# объектов в стеке. Иначе, генерировать исключение командой:
#
# raise IndexError('неверный индекс')
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class StackObj:

    def __init__(self, data):
        self.data = data
        self.next = None


class Stack:

    def __init__(self):
        self.top = None

    def push_back(self, obj):
        if self.top is None:
            self.top = obj
            return

        ex = self.top
        while ex.next is not None:
            ex = ex.next
        ex.next = obj
        return

    def push_front(self, obj):
        if self.top is None:
            self.top = obj
            return

        ex = self.top
        obj.next = ex
        self.top = obj
        return

    def __len__(self):
        res = 0
        if self.top is None:
            return res

        ex = self.top
        while ex:
            res += 1
            ex = ex.next
        return res

    def __iter__(self):
        if self.top is None:
            return None

        ex = self.top
        while ex:
            res = ex
            ex = ex.next
            yield res

    def check_indx(self, indx):
        if indx > len(self) - 1:
            raise IndexError('неверный индекс')
        return True

    def __getitem__(self, item):
        self.check_indx(item)
        count = 0
        for i in iter(self):
            if count == item:
                return i.data
            count += 1

    def __setitem__(self, key, value):
        self.check_indx(key)
        res = 0
        for i in iter(self):
            if res == key:
                i.data = value
                return
            res += 1


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/kmmvxZWxaAY
#
# Подвиг 9. В программе необходимо реализовать таблицу TableValues по следующей схеме:


# Каждая ячейка таблицы должна быть представлена классом Cell. Объекты этого класса создаются командой:
#
# cell = Cell(data)
# где data - данные в ячейке. В каждом объекте класса Cell должен формироваться локальный приватный атрибут __data с
# соответствующим значением. Для работы с ним в классе Cell должно быть объект-свойство (property):
#
# data - для записи и считывания информации из атрибута __data.
#
# Сам класс TableValues представляет таблицу в целом, объекты которого создаются командой:
#
# table = TableValues(rows, cols, type_data)
# где rows, cols - число строк и столбцов таблицы; type_data - тип данных ячейки (int - по умолчанию, float, list,
# str и т.п.). Начальные значения в ячейках таблицы равны 0 (целое число).
#
# С объектами класса TableValues должны выполняться следующие команды:
#
# table[row, col] = value# запись нового значения в ячейку с индексами row, col (индексы отсчитываются с нуля)
# value = table[row, col] # считывание значения из ячейки с индексами row, col
#
# for row in table:  # перебор по строкам
#     for value in row: # перебор по столбцам
#         print(value, end=' ')  # вывод значений ячеек в консоль
#     print()
# При попытке записать по индексам table[row, col] данные другого типа (не совпадающего с атрибутом type_data объекта
# класса TableValues), должно генерироваться исключение командой:
#
# raise TypeError('неверный тип присваиваемых данных')
# При работе с индексами row, col, необходимо проверять их корректность. Если индексы не целое число или они выходят
# за диапазон размера таблицы, то генерировать исключение командой:
#
# raise IndexError('неверный индекс')
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Cell:

    def __init__(self, data=0):
        self.__data = data

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, data):
        self.__data = data


class TableValues:

    def __init__(self, rows, cols, type_data=int):
        self.rows = rows
        self.cols = cols
        self.type_data = type_data
        self.table = [[Cell() for _ in range(self.cols)] for _ in range(self.rows)]

    def check_type(self, value):
        if type(value) != self.type_data:
            raise TypeError('неверный тип присваиваемых данных')

    def check_indx(self, row, col):
        if row > self.rows - 1 or col > len(self.table[row]) - 1:
            raise IndexError('неверный индекс')
        return True

    def __getitem__(self, item):
        r, c = item
        self.check_indx(r, c)
        return self.table[r][c].data

    def __setitem__(self, key, value):
        r, c = key
        self.check_indx(r, c)
        self.check_type(value)
        self.table[r][c].data = value

    def __iter__(self):
        for row in self.table:
            yield (x.data for x in row)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/yX9qxE8X1OA
#
# Подвиг 10 (на повторение). Объявите класс Matrix (матрица) для операций с матрицами. Объекты этого класса должны
# создаваться командой:
#
# m1 = Matrix(rows, cols, fill_value)
# где rows, cols - число строк и столбцов матрицы; fill_value - заполняемое начальное значение элементов матрицы
# (должно быть число: целое или вещественное). Если в качестве аргументов передаются не числа, то генерировать
# исключение:
#
# raise TypeError('аргументы rows, cols - целые числа; fill_value - произвольное число')
# Также объекты можно создавать командой:
#
# m2 = Matrix(list2D)
# где list2D - двумерный список (прямоугольный), состоящий из чисел (целых или вещественных). Если список list2D не
# прямоугольный, или хотя бы один из его элементов не число, то генерировать исключение командой:
#
# raise TypeError('список должен быть прямоугольным, состоящим из чисел')
# Для объектов класса Matrix должны выполняться следующие команды:
#
# matrix = Matrix(4, 5, 0)
# res = matrix[0, 0] # возвращается первый элемент матрицы
# matrix[indx1, indx2] = value # элементу матрицы с индексами (indx1, indx2) присваивается новое значение
# Если в результате присвоения тип данных не соответствует числу, то генерировать исключение командой:
#
# raise TypeError('значения матрицы должны быть числами')
# Если указываются недопустимые индексы матрицы (должны быть целыми числами от 0 и до размеров матрицы), то
# генерировать исключение:
#
# raise IndexError('недопустимые значения индексов')
# Также с объектами класса Matrix должны выполняться операторы:
#
# matrix = m1 + m2 # сложение соответствующих значений элементов матриц m1 и m2
# matrix = m1 + 10 # прибавление числа ко всем элементам матрицы m1
# matrix = m1 - m2 # вычитание соответствующих значений элементов матриц m1 и m2
# matrix = m1 - 10 # вычитание числа из всех элементов матрицы m1
# Во всех этих операция должна формироваться новая матрица с соответствующими значениями. Если размеры матриц не
# совпадают (разные хотя бы по одной оси), то генерировать исключение командой:
#
# raise ValueError('операции возможны только с матрицами равных размеров')
# Пример для понимания использования индексов (эти строчки в программе писать не нужно):
#
# mt = Matrix([[1, 2], [3, 4]])
# res = mt[0, 0] # 1
# res = mt[0, 1] # 2
# res = mt[1, 0] # 3
# res = mt[1, 1] # 4
# P.S. В программе нужно объявить только класс. Выводить на экран ничего не нужно.


# рабочий вариант
from operator import add, sub

class Matrix:
    def __init__(self, *args):
        if len(args) == 3:
            if not all(map(isinstance, args, [int, int, (int, float)])):
                raise TypeError('аргументы rows, cols - целые числа; fill_value - произвольное число')
            self.rows, self.cols, fill_value = args
            self.table = [[fill_value] * self.cols for _ in range(self.rows)]
        elif len(args) == 1:
            lst, = args
            self.rows = len(lst)
            self.cols = len(lst[0])
            check_length = lambda x: len(x) == self.cols
            if all(map(check_length, lst)) and all(isinstance(x, (int, float)) for row in lst for x in row):
                self.table = lst
            else:
                raise TypeError('список должен быть прямоугольным, состоящим из чисел')

    def check_indx(self, i, j):
        if not (0 <= i < self.rows and 0 <= j < self.cols):
            raise IndexError('недопустимые значения индексов')

    def check_equal(self, other):
        if not (self.rows == other.rows and self.cols == other.cols):
            raise ValueError('операции возможны только с матрицами равных размеров')

    def __getitem__(self, item):
        i, j = item
        self.check_indx(i, j)
        return self.table[i][j]

    def __setitem__(self, key, value):
        if not isinstance(value, (int, float)):
            raise TypeError('значения матрицы должны быть числами')
        i, j = key
        self.check_indx(i, j)
        self.table[i][j] = value

    def __iter__(self):
        return (col for row in self.table for col in row)

    def calculate(self, op, it2):
        temp = Matrix(self.rows, self.cols, 0)
        it1 = iter(self)
        for i in range(self.rows):
            for j in range(self.cols):
                temp.table[i][j] = op(next(it1), next(it2))
        return temp

    def operation(self, op, other):
        if isinstance(other, Matrix):
            self.check_equal(other)
            return self.calculate(op, iter(other))
        elif isinstance(other, (float, int)):
            return self.calculate(op, iter([other] * self.rows * self.cols))

    def __add__(self, other):
        return self.operation(add, other)

    def __sub__(self, other):
        return self.operation(sub, other)


# подумать
class Matrix:

    def __init__(self, *args):
        if len(args) == 1:
            self.check_matrix(args[0])
            self.matrix = args[0]
            return
        self.check_value(args)
        self.rows = args[0]
        self.cols = args[1]
        self.fill_value = args[2]
        self.matrix = [[self.fill_value for _ in range(self.cols)] for _ in range(self.rows)]

    def check_value(self, args):
        rows, cols, fill_value = args
        if type(rows) != int and type(cols) != int or type(fill_value) not in (int, float):
            raise TypeError('аргументы rows, cols - целые числа; fill_value - произвольное число')

    def check_matrix(self, mtx):
        if len(mtx) == len(mtx[0]):
            raise TypeError('список должен быть прямоугольным, состоящим из чисел')
        for i in mtx:
            for val in i:
                if type(val) not in (int, float):
                    raise TypeError('список должен быть прямоугольным, состоящим из чисел')

    def check_indx(self, indx):
        r, c = indx
        if r > len(self.matrix) - 1 or c > len(self.matrix[0]):
            raise IndexError('недопустимые значения индексов')

    def __getitem__(self, item):
        self.check_indx(item)
        r, c = item
        return self.matrix[r][c]

    def __setitem__(self, key, value):
        if type(value) not in (int, float):
            raise TypeError('значения матрицы должны быть числами')
        self.check_indx(key)
        r, c = key
        self.matrix[r][c] = value

    def check_add_matrix(self, mtx1, mtx2):
        res1, res2 = (len(i) for i in mtx1), (len(i) for i in mtx2)
        if len(mtx1) != len(mtx2) or res1 != res2:
            raise ValueError('операции возможны только с матрицами равных размеров')

    def __add__(self, other):
        if isinstance(other, Matrix):
            self.check_add_matrix(self.matrix, other.matrix)
            res = self.matrix
            for i in range(len(res)):
                for j in range(len(res[i])):
                    res[i][j] += other.matrix[i][j]
            return res
        res = self.matrix
        for i in range(len(res)):
            for j in range(len(res[i])):
                res[i][j] += other
        return res

    def __sub__(self, other):
        if isinstance(other, Matrix):
            self.check_add_matrix(self.matrix, other.matrix)
            res = self.matrix
            for i in range(len(res)):
                for j in range(len(res[i])):
                    res[i][j] -= other.matrix[i][j]
            return res
        res = self.matrix
        for i in range(len(res)):
            for j in range(len(res[i])):
                res[i][j] -= other
        return res


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 3.10 Испытание магией
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор (решение смотреть только после своей попытки): https://youtu.be/1dSxnEFfDu8
#
# Вы прошли магические методы. Начальство оценило вашу стойкость, рвение и решило дать вам испытание для подтверждения
# уровня полученных навыков. Вам выпала великая честь создать полноценную программу игры в "Крестики-нолики". И вот
# перед вами текст с заданием самого испытания.
#
# Техническое задание
# Необходимо объявить класс с именем TicTacToe (крестики-нолики) для управления игровым процессом. Объекты этого класса
# будут создаваться командой:
#
# game = TicTacToe()
# В каждом объекте этого класса должен быть публичный атрибут:
#
# pole - двумерный кортеж, размером 3x3.
#
# Каждый элемент кортежа pole является объектом класса Cell:
#
# cell = Cell()
# В объектах этого класса должно автоматически формироваться локальное свойство:
#
# value - текущее значение в ячейке: 0 - клетка свободна; 1 - стоит крестик; 2 - стоит нолик.
#
# Также с объектами класса Cell должна выполняться функция:
#
# bool(cell) - возвращает True, если клетка свободна (value = 0) и False - в противном случае.
#
# К каждой клетке игрового поля должен быть доступ через операторы:
#
# res = game[i, j] # получение значения из клетки с индексами i, j
# game[i, j] = value # запись нового значения в клетку с индексами i, j
# Если индексы указаны неверно (не целые числа или числа, выходящие за диапазон [0; 2]), то следует генерировать
# исключение командой:
#
# raise IndexError('некорректно указанные индексы')
# Чтобы в программе не оперировать величинами: 0 - свободная клетка; 1 - крестики и 2 - нолики, в классе TicTacToe
# должны быть три публичных атрибута (атрибуты класса):
#
# FREE_CELL = 0      # свободная клетка
# HUMAN_X = 1        # крестик (игрок - человек)
# COMPUTER_O = 2     # нолик (игрок - компьютер)
# В самом классе TicTacToe должны быть объявлены следующие методы (как минимум):
#
# init() - инициализация игры (очистка игрового поля, возможно, еще какие-либо действия);
# show() - отображение текущего состояния игрового поля (как именно - на свое усмотрение);
# human_go() - реализация хода игрока (запрашивает координаты свободной клетки и ставит туда крестик);
# computer_go() - реализация хода компьютера (ставит случайным образом нолик в свободную клетку).
#
# Также в классе TicTacToe должны быть следующие объекты-свойства (property):
#
# is_human_win - возвращает True, если победил человек, иначе - False;
# is_computer_win - возвращает True, если победил компьютер, иначе - False;
# is_draw - возвращает True, если ничья, иначе - False.
#
# Наконец, с объектами класса TicTacToe должна выполняться функция:
#
# bool(game) - возвращает True, если игра не окончена (никто не победил и есть свободные клетки) и False - в противном
# случае.
#
# Все эти функции и свойства предполагается использовать следующим образом (эти строчки в программе не писать):
#
# game = TicTacToe()
# game.init()
# step_game = 0
# while game:
#     game.show()
#
#     if step_game % 2 == 0:
#         game.human_go()
#     else:
#         game.computer_go()
#
#     step_game += 1
#
#
# game.show()
#
# if game.is_human_win:
#     print("Поздравляем! Вы победили!")
# elif game.is_computer_win:
#     print("Все получится, со временем")
# else:
#     print("Ничья.")
# Вам в программе необходимо объявить только два класса: TicTacToe и Cell так, чтобы с их помощью можно было бы сыграть
# в "Крестики-нолики" между человеком и компьютером.
#
# P.S. Запускать игру и выводить что-либо на экран не нужно. Только объявить классы.
#
# P.S.S. Домашнее задание: завершите создание этой игры и выиграйте у компьютера хотя бы один раз.


from random import randint

class TicTacToe:
    FREE_CELL = 0
    HUMAN_X = 1
    COMPUTER_O = 2

    def __init__(self):
        self._size = 3
        self._win = 0  # 0 - game, 1 - win human, 2 - win comp, 3 - draw
        self.pole = tuple(tuple(Cell() for _ in range(self._size)) for _ in range(self._size))

    @property
    def is_human_win(self):
        return self._win == 1

    @property
    def is_computer_win(self):
        return self._win == 2

    @property
    def is_draw(self):
        return self._win == 3

    def __check_indx(self, indx):
        if type(indx) not in (list, tuple) or len(indx) != 2:
            raise IndexError('некорректно указанные индексы')
        i, j = indx
        if not (0 <= i < self._size) or not (0 <= i < self._size):
            raise IndexError('некорректно указанные индексы')

    def __update_win_status(self):
        for i in self.pole:
            if all(x.value == self.HUMAN_X for x in i):
                self._win = 1
                return
            if all(x.value == self.COMPUTER_O for x in i):
                self._win = 2
                return

        for i in range(self._size):
            if all(x.value == self.HUMAN_X for x in (row[i] for row in self.pole)):
                self._win = 1
                return
            if all(x.value == self.COMPUTER_O for x in (row[i] for row in self.pole)):
                self._win = 2
                return

        if all(self.pole[i][i].value == self.HUMAN_X for i in range(self._size)) or \
            all(self.pole[i][-1 - i].value == self.HUMAN_X for i in range(self._size)):
            self._win = 1
            return
        if all(self.pole[i][i].value == self.COMPUTER_O for i in range(self._size)) or \
            all(self.pole[i][-1 - i].value == self.COMPUTER_O for i in range(self._size)):
            self._win = 2
            return

        if all(x.value != self.FREE_CELL for row in self.pole for x in row):
            self._win = 3
            return

    def __getitem__(self, item):
        self.__check_indx(item)
        i, j = item
        return self.pole[i][j].value

    def __setitem__(self, key, value):
        self.__check_indx(key)
        i, j = key
        self.pole[i][j].value = value
        self.__update_win_status()

    def init(self):
        for i in range(self._size):
            for j in range(self._size):
                self.pole[i][j].value = 0
        self._win = 0

    def show(self):
        for row in self.pole:
            print(*map(lambda x: '#' if x.value == 0 else x.value, row))
        print('---------------------------------------')

    def human_go(self):
        if not self:
            return

        while True:
            i, j = map(int, input('Введите координаты клетки: ').split())
            if not (0 <= i < self._size) or not (0 <= j < self._size):
                continue
            if self[i, j] == self.FREE_CELL:
                self[i, j] = self.HUMAN_X
                break

    def computer_go(self):
        if not self:
            return

        while True:
            i = randint(0, self._size - 1)
            j = randint(0, self._size - 1)
            if self[i, j] != self.FREE_CELL:
                continue
            self[i, j] = self.COMPUTER_O
            break

    def __bool__(self):
        return self._win == 0 and self._win not in (1, 2, 3)


class Cell:

    def __init__(self):
        self.value = 0

    def __bool__(self):
        return self.value == 0


game = TicTacToe()
game.init()
step_game = 0
while game:
    game.show()

    if step_game % 2 == 0:
        game.human_go()
    else:
        game.computer_go()

    step_game += 1


game.show()

if game.is_human_win:
    print("Поздравляем! Вы победили!")
elif game.is_computer_win:
    print("Все получится, со временем")
else:
    print("Ничья.")


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 4. НАСЛЕДОВАНИЕ И ПОЛИМОРФИЗМ
# ======================================================================================================================

# ======================================================================================================================
# 4.1.  Наследование в объектно-ориентированном программировании
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что означает наследование классов?

# - это когда один класс (дочерний) расширяет функциональность другого (базового) класса


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе объявлены два класса следующим образом:
#
# class Table:
#     def __init__(self, model, color):
#         self.model = model
#         self.color = color
#
#
# class RoundTable(Table):
#     def __init__(self, model, color, radius, height):
#         super().__init__(model, color)
#         self.radius = radius
#         self.height = height
# И создается объект класса RoundTable:
#
# rt = RoundTable('PC', 'brown', 500, 750)
# Выберите все верные утверждения, связанные с этим фрагментом программы.


# - в созданном объекте rt формируются четыре локальных свойства: model, color, radius, height
# - при создании объекта rt вызывается сначала инициализатор класса RoundTable, а затем, - класса Table
# - класс RoundTable наследуется от класса Table
# - параметры self в инициализаторе класса RoundTable и в инициализаторе класса Table ссылаются на один и тот же
# объект rt


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Имеется следующий фрагмент программы:
#
# class Table:
#     def __init__(self, model, color):
#         self.set_model_and_color(model, color)
#
#     def set_model_and_color(self, model, color):
#         self.model = model
#         self.color = color
#
#
# class RoundTable(Table):
#     def __init__(self, model, color, radius, height):
#         super().__init__(model, color)
#         self.radius = radius
#         self.height = height
#
#     def set_params(self, model, color, radius, height):
#         self.model = model
#         self.color = color
#         self.radius = radius
#         self.height = height
#
#
# rt = RoundTable('PC', 'brown', 500, 750)
# tb = Table('Home', 'white')
#
# Выберите все пункты, в которых команды будут выполнены без ошибок.


# - rt.set_params('Home', 'red', 700, 1000)
# - m = tb.model
# - color = rt.color
# - rt.set_model_and_color('Home', 'red')


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Наследование часто используют, чтобы вынести общий код дочерних классов в базовый класс. Сделаем такой
# пример. Объявите в программе базовый класс Animal (животное), объекты которого можно создать командой:
#
# an = Animal(name, old)
# где name - название животного (строка); old - возраст животного (целое число). Такие же локальные
# атрибуты (name и old) должны создаваться в объектах класса.
#
# Далее, объявите дочерний класс (от базового Animal) с именем Cat (кошки), объекты которого создаются командой:
#
# cat = Cat(name, old, color, weight)
# где name, old - те же самые параметры, что и в базовом классе; color - цвет кошки (строка); weight - вес
# кошки (любое положительное число).
#
# В объектах класса Cat должны автоматически формироваться локальные атрибуты: name, old, color, weight.
# Формирование атрибутов name, old должен выполнять инициализатор базового класса.
#
# По аналогии объявите еще один дочерний класс Dog (собака), объекты которого создаются командой:
#
# dog = Dog(name, old, breed, size)
# здесь name, old - те же самые параметры, что и в базовом классе; breed - порода собаки (строка); size - кортеж в
# формате (height, length) высота и длина - числа.
#
# В объектах класса Dog по аналогии должны формироваться локальные атрибуты: name, old, breed, size. За формирование
# атрибутов name, old отвечает инициализатор базового класса.
#
# Наконец, в классах Cat и Dog объявите метод:
#
# get_info() - для получения информации о животном.
#
# Этот метод должен возвращать строку в формате:
#
# "name: old, <остальные параметры через запятую>"
#
# Например, для следующего объекта класса Cat:
#
# cat = Cat('кот', 4, 'black', 2.25)
# метод get_info должен вернуть строку:
#
# "кот: 4, black, 2.25"
#
# P.S. В программе достаточно объявить три класса. Выводить на экран ничего не нужно.


class Animal:

    def __init__(self, name, old):
        self.name = name
        self.old = old


class Cat(Animal):

    def __init__(self, name, old, color, weight):
        super().__init__(name, old)
        self.color = color
        self.weight = weight

    def get_info(self):
        return f'{self.name}: {self.old}, {self.color}, {self.weight}'


class Dog(Animal):

    def __init__(self, name, old, breed, size):
        super().__init__(name, old)
        self.breed = breed
        self.size = size

    def get_info(self):
        return f'{self.name}: {self.old}, {self.breed}, {self.size}'


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/K0w2oBTThAc
#
# Подвиг 5. Иногда наследование используют, чтобы наделить объекты дочерних классов определенным набором атрибутов.
# Сделаем такой пример.
#
# Предположим, вы разрабатываете программу для интернет-магазина. В этом магазине могут быть как реальные (физические)
# товары, так и электронные. Для этих двух групп, очевидно, нужен разный набор атрибутов:
#
# - для реальных физических товаров: id, name, price, weight, dims
#
# где id - идентификатор товара (целое число); name - наименование товара (строка); price - цена товара (вещественное
# число); weight - вес товара (вещественное число); dims = (lenght, width, depth) - длина, ширина, глубина - габариты
# товара (вещественные числа);
#
# - для электронных товаров: id, name, price, memory, frm
#
# где id - идентификатор товара (целое число); name - наименование товара (строка); price - цена товара (вещественное
# число); memory - занимаемый размер (в байтах - целое число); frm - формат данных (строка: pdf, docx и т.п.)
#
# Так как все товары могут идти вперемешку, то мы хотим, чтобы в каждом объекте (для товара) присутствовали все
# атрибуты:
#
# id, name, price, weight, dims, memory, frm
#
# с начальными значениями None. А уже, затем, нужным из них будут присвоены конкретные данные.
#
# Для реализации этой логики объявите в программе базовый класс с именем Thing (вещь, предмет), объекты которого могут
# создаваться командой:
#
# th = Thing(name, price)
# А атрибут id должен формироваться автоматически и быть уникальным для каждого товара (например, можно для каждого
# нового объекта увеличивать на единицу).
#
# В объектах класса Thing должен формироваться полный набор локальных
# атрибутов (id, name, price, weight, dims, memory, frm) со значением None, кроме атрибутов: id, name, price.
#
# Далее, нужно объявить два дочерних класса:
#
# Table - для столов;
# ElBook - для электронных книг.
#
# Объекты этих классов должны создаваться командами:
#
# table = Table(name, price, weight, dims)
# book = ElBook(name, price, memory, frm)
# Причем, атрибуты name, price (а также id) следует инициализировать в базовом классе, т.к. они общие для всех
# товаров. Остальные атрибуты должны либо принимать значение None, если не используются, либо инициализироваться
# конкретными значениями уже в дочерних классах.
#
# Наконец, в базовом классе Thing объявите метод:
#
# get_data() - для получения кортежа в формате (id, name, price, weight, dims, memory, frm)
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# table = Table("Круглый", 1024, 812.55, (700, 750, 700))
# book = ElBook("Python ООП", 2000, 2048, 'pdf')
# print(*table.get_data())
# print(*book.get_data())
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Thing:
    id = 1

    def __init__(self, name, price):
        self.name = name
        self.price = price
        self.id = Thing.id
        Thing.id += 1
        self.weight = None
        self.dims = None
        self.memory = None
        self.frm = None

    def get_data(self):
        return (self.id, self.name, self.price, self.weight, self.dims, self.memory, self.frm)

class Table(Thing):

    def __init__(self, name, price, weight, dims):
        super().__init__(name, price)
        self.weight = weight
        self.dims = dims


class ElBook(Thing):

    def __init__(self, name, price, memory, frm):
        super().__init__(name, price)
        self.memory = memory
        self.frm = frm


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/k0xvHbnTnoo
#
# Подвиг 6. Еще один пример, когда в базовом классе прописывается необходимый начальный функционал для дочерних классов.
#
# Известно, что браузер (и не только) может отправлять на сервер различные типы запросов: GET, POST, PUT, DELETE и др.
# Каждый из этих типов запросов обрабатывается в программе на сервере своим отдельным методом. Чтобы каждый раз не
# прописывать все необходимые методы в классах при обработке входящих запросов, они выносятся в базовый класс и
# вызываются из дочерних. Выполним такой пример.
#
# Пусть в программе объявлен следующий базовый класс с именем GenericView:
#
# class GenericView:
#     def __init__(self, methods=('GET',)):
#         self.methods = methods
#
#     def get(self, request):
#         return ""
#
#     def post(self, request):
#         pass
#
#     def put(self, request):
#         pass
#
#     def delete(self, request):
#         pass
# Здесь каждый метод отвечает за обработку своего типа запроса. Параметр methods - это кортеж или список, состоящий
# из набора разрешенных запросов: строк с именами соответствующих методов (как правило, пишут заглавными буквами).
# Вам необходимо объявить дочерний класс с именем DetailView, объекты которого можно создавать командами:
#
# dv = DetailView()  # по умолчанию methods=('GET',)
# dv = DetailView(methods=('PUT', 'POST'))
# Для инициализации атрибута methods следует вызывать инициализатор базового класса GenericView.
#
# Далее, в классе DetailView нужно определить метод:
#
# def render_request(self, request, method): ...
# который бы имитировал выполнение поступившего на сервер запроса. Здесь request - словарь с набором данных запроса;
# method - тип запроса (строка: 'get' или 'post' и т.д.).
#
# Например:
#
# html = dv.render_request({'url': 'https://site.ru/home'}, 'GET')
# должен быть обработан запрос как GET-запрос с параметром url и значением 'https://site.ru/home'. Параметр url
# является обязательным в словаре request для каждого запроса.
#
# В методе render_request() необходимо выполнить проверку: является ли указанный метод (method)
# разрешенным (присутствует в коллекции methods). Если это не так, то генерировать исключение командой:
#
# raise TypeError('данный запрос не может быть выполнен')
# Если проверка проходит, то выполнить соответствующий метод (или get(), или post(), или put() и т.д. с возвращением
# результата их работы).
#
# Подсказка: для получения ссылки на нужный метод можно воспользоваться магическим методом __getattribute__() или
# аналогичной функцией getattr()).
#
# Наконец, в дочернем классе DetailView следует переопределить метод get() для нужной нам обработки GET-запросов.
# В этом методе нужно выполнить проверку, что параметр request является словарем. Если это не так, то генерировать
# исключение:
#
# raise TypeError('request не является словарем')
# Сделать проверку, что в словаре request присутствует ключ url. Если его нет, то генерировать исключение:
#
# raise TypeError('request не содержит обязательного ключа url')
# Если же все проверки проходят, то вернуть строку в формате:
#
# "url: <request['url']>"
#
# Пример (эти строчки в программе писать не нужно):
#
# dv = DetailView()
# html = dv.render_request({'url': 'https://site.ru/home'}, 'GET')   # url: https://site.ru/home
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class GenericView:
    def __init__(self, methods=('GET',)):
        self.methods = methods

    def get(self, request):
        return ""

    def post(self, request):
        pass

    def put(self, request):
        pass

    def delete(self, request):
        pass


class DetailView(GenericView):

    def __init__(self, methods=('GET', )):
        super().__init__(methods)

    def render_request(self, request, method):
        if method.upper() not in self.methods:
            raise TypeError('данный запрос не может быть выполнен')

        f = getattr(self, method.lower(), False)
        if f:
            return f(request)

    def get(self, request):
        if type(request) != dict:
            raise TypeError('request не является словарем')
        if 'url' not in request:
            raise TypeError('request не содержит обязательного ключа url')
        return f'url: {request["url"]}'


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PxOfMkw962E
#
# Подвиг 7. С помощью наследования можно как бы "наполнять" дочерние классы нужными качествами (свойствами). Как
# пример, объявите в программе класс с именем:
#
# Singleton
#
# который бы позволял создавать только один экземпляр (все последующие экземпляры должны ссылаться на первый). Как
# это делать, вы должны уже знать из этого курса.
#
# Затем, объявите еще один класс с именем:
#
# Game
#
# который бы наследовался от класса Singleton. Объекты класса Game должны создаваться командой:
#
# game = Game(name)
# где name - название игры (строка). В каждом объекте класса Game должен создаваться атрибут name с соответствующим
# содержимым.
#
# Убедитесь, что атрибут name принимает значение первого созданного объекта (если это не так, то поправьте
# инициализатор дочернего класса, чтобы это условие выполнялось).
#
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Singleton:

    __INSTANCE = None
    __INSTANCE_BASE = None

    def __new__(cls, *args, **kwargs):
        if cls == Singleton:
            if cls.__INSTANCE_BASE is None:
                cls.__INSTANCE_BASE = object.__new__(cls)
            return cls.__INSTANCE_BASE

        if cls.__INSTANCE is None:
            cls.__INSTANCE = object.__new__(cls)
        return cls.__INSTANCE


class Game(Singleton):

    def __init__(self, name):
        if 'name' not in self.__dict__:
            self.name = name


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Вам необходимо создать множество классов для валидации (проверки) корректности данных. Для этого ваш
# непосредственный начальник (Senior) предлагает вам объявить в программе базовый класс с именем:
#
# Validator
#
# обеспечивающий базовый функционал для проверки корректности данных. В частности, в этом классе нужно объявить
# следующий метод:
#
# def _is_valid(self, data): ...
# По задумке этот метод должен возвращать булево значение True, если данные (data) корректны и False - в противном
# случае.
#
# Так как базовый класс Validator - это общий класс для всех видов проверок, то метод _is_valid() будет просто
# возвращать True.
# Кроме того, объекты класса Validator:
#
# v = Validator()   # инициализатор в классе Validator прописывать не нужно
# должны вызываться подобно функциям:
#
# v(data)
# и если данные (data) некорректны, то генерировать исключение:
#
# raise ValueError('данные не прошли валидацию')
# Проверка корректности выполняется с помощью метода _is_valid(). После этого, в программе нужно объявить два дочерних
# класса:
#
# IntegerValidator - для проверки, что data - целое число в заданном диапазоне;
# FloatValidator - для проверки, что data - вещественное число в заданном диапазоне.
#
# Объекты этих классов предполагается создавать командами:
#
# integer_validator = IntegerValidator(min_value, max_value)
# float_validator = IntegerValidator(min_value, max_value)
# где min_value, max_value - допустимый диапазон чисел [min_value; max_value]
#
# Также в этих классах нужно переопределить метод:
#
# def _is_valid(self, data): ...
# который бы возвращал True, если data является числом верного типа (либо int, либо float в зависимости от валидатора)
# и находится в заданном диапазоне [min_value; max_value]. Иначе, возвращается False.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# integer_validator = IntegerValidator(-10, 10)
# float_validator = FloatValidator(-1, 1)
# res1 = integer_validator(10)  # исключение не генерируется (проверка проходит)
# res2 = float_validator(10)    # исключение ValueError
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Validator:

    def _is_valid(self, data):
        return True

    def __call__(self, *args, **kwargs):
        if not self._is_valid(args[0]):
            raise ValueError('данные не прошли валидацию')


class IntegerValidator(Validator):

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def _is_valid(self, data):
        if type(data) == int and self.min_value <= data <= self.max_value:
            return True
        return False


class FloatValidator(Validator):

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def _is_valid(self, data):
        if type(data) == float and self.min_value <= data <= self.max_value:
            return True
        return False


# Второй вариант
class Validator:        # инициализатор в классе Validator прописывать не нужно
    def _is_valid(self, data):
        return True

    def __call__(self, data):
        if self._is_valid(data):
            return True
        else:
            raise ValueError('данные не прошли валидацию')


class NumericValidator(Validator):
    type = None

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def _is_valid(self, data):
        return type(data) == self.type and self.min_value <= data <= self.max_value


class IntegerValidator(NumericValidator):
    type = int


class FloatValidator(NumericValidator):
    type = float


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/I8upOO_ZjqQ
#
# Большой подвиг 9. Используя механизм наследования, вам поручено разработать функционал по построению моделей
# нейронных сетей. Общая схема модели очень простая:


# Базовый класс Layer имеет локальный атрибут next_layer, который ссылается на следующий объект слоя нейронной сети
# (объект класса Layer или любого объекта дочерних классов). У последнего слоя значение next_layer = None.
#
# Создавать последовательность слоев предполагается командами:
#
# first_layer = Layer()
# next_layer = first_layer(Layer())
# next_layer = next_layer(Layer())
# ...
# То есть, сначала создается объект first_layer класса Layer, а затем он вызывается как функция для образования связки
# со следующим слоем. При этом возвращается ссылка на следующий слой и переменная next_layer ссылается уже на этот
# следующий слой нейронной сети. И так можно создавать столько слоев, сколько необходимо.
#
# В каждом объекте класса Layer также должен формироваться локальный атрибут:
#
# name = 'Layer'
#
# Но сам по себе класс Layer образует только связи между слоями. Никакой другой функциональности он не несет. Чтобы
# это исправить, в программе нужно объявить еще два дочерних класса:
#
# Input - формирование входного слоя нейронной сети;
# Dense - формирование полносвязного слоя нейронной сети.


# Конечно, создавать нейронную сеть мы не будем. Поэтому, в классе Input нужно лишь прописать инициализатор так, чтобы
# его объекты создавались следующим образом:
#
# inp = Input(inputs)
# где inputs - общее число входов (целое число). Также в объектах класса Input должен автоматически формироваться
# атрибут:
#
# name = 'Input'
#
# (Не забывайте при этом, вызывать инициализатор базового класса Layer).
#
# Объекты второго дочернего класса Dense предполагается создавать командой:
#
# dense = Dense(inputs, outputs, activation)
# где inputs - число входов в слой; outputs - число выходов слоя (целые числа); activation - функция
# активации (строка, например: 'linear', 'relu', 'sigmoid'). И в каждом объекте класса Dense также должен
# автоматически формироваться атрибут:
#
# name = 'Dense'
#
# Все эти классы совместно можно использовать следующим образом (эти строчки пример, писать не нужно):
#
# network = Input(128)
# layer = network(Dense(network.inputs, 1024, 'linear'))
# layer = layer(Dense(layer.inputs, 10, 'softmax'))
# Здесь создается три слоя нейронной сети.
#
# Наконец, для перебора всех слоев с помощью цикла for, необходимо объявить отдельный класс NetworkIterator для
# итерирования (перебора) слоев нейронной сети следующим образом:
#
# for x in NetworkIterator(network):
#     print(x.name)
# Здесь создается объект класса NetworkIterator. На вход передается первый объект (слой) нейронной сети. Объект
# этого класса является итератором, который в цикле for последовательно возвращает объекты (слои) нейронной сети.
#
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Layer:

    def __init__(self, name='Layer'):
        self.name = name
        self.next_layer = None

    def __call__(self, layer, *args, **kwargs):
        self.next_layer = layer
        return layer


class Input(Layer):

    def __init__(self, inputs):
        super().__init__(name='Input')
        self.inputs = inputs



class Dense(Layer):

    def __init__(self, inputs, outputs, activation):
        super().__init__(name='Dense')
        self.inputs = inputs
        self.outputs = outputs
        self.activation = activation


class NetworkIterator:

    def __init__(self, network):
        self.network = network

    def __iter__(self):
        layer = self.network
        while layer:
            yield layer
            layer = layer.next_layer


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Q_zIap6F1Lw
#
# Подвиг 10 (на повторение). Объявите в программе класс Vector, объекты которого создаются командой:
#
# v = Vector(x1, x2, ..., xN)
# где x1, x2, ..., xN - координаты радиус-вектора (числа: целые или вещественные).
#
# С объектами этого класса должны выполняться команды:
#
# v1 = Vector(1, 2, 3)
# v2 = Vector(3, 4, 5)
# v = v1 + v2 # формируется новый вектор (объект класса Vector) с соответствующими координатами
# v = v1 - v2 # формируется новый вектор (объект класса Vector) с соответствующими координатами
# Если размерности векторов v1 и v2 не совпадают, то генерировать исключение:
#
# raise TypeError('размерности векторов не совпадают')
# В самом классе Vector объявите метод с именем get_coords, который возвращает кортеж из текущих координат вектора.
#
# На основе класса Vector объявите дочерний класс VectorInt для работы с целочисленными координатами:
#
# v = VectorInt(1, 2, 3, 4)
# v = VectorInt(1, 0.2, 3, 4) # ошибка: генерируется исключение raise ValueError('координаты должны быть целыми числами')
# При операциях сложения и вычитания с объектом класса VectorInt:
#
# v = v1 + v2  # v1 - объект класса VectorInt
# v = v1 - v2  # v1 - объект класса VectorInt
# должен формироваться объект v как объект класса Vector, если хотя бы одна координата является вещественной. Иначе, v
# должен быть объектом класса VectorInt.
#
# P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.


class Vector:
    _allowed_types = (int, float)

    def __init__(self, *coords):
        self.__check_coords(coords)
        self.coords = coords

    def __add__(self, other):
        self.__is_vector(other)
        self.__check_vector_dims(other)
        coords = tuple(a + b for a, b in zip(self.coords, other.get_coords()))
        return self.__make_vector(coords)

    def __sub__(self, other):
        self.__is_vector(other)
        self.__check_vector_dims(other)
        coords = tuple(a - b for a, b in zip(self.coords, other.get_coords()))
        return self.__make_vector(coords)

    def get_coords(self):
        return tuple(self.coords)

    def __check_coords(self, coords):
        if not all(type(x) in self._allowed_types for x in coords):
            raise ValueError('неверный тип координат')

    @staticmethod
    def __is_vector(obj):
        if not isinstance(obj, Vector):
            raise TypeError('операнд должен быть объектом класса Vector или любого дочернего класса')

    def __check_vector_dims(self, other):
        if len(self.coords) != len(other.get_coords()):
            raise TypeError('размерности векторов не совпадают')

    def __make_vector(self, coords):
        try:
            return self.__class__(*coords)
        except ValueError:
            return Vector(*coords)


class VectorInt(Vector):
    _allowed_types = (int, )


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================


# ======================================================================================================================
# 4.2 Функция issubclass(). Наследование от встроенных типов
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Чем являются, следующие встроенные типы данных языка Python: list, tuple, int, str, dict?
#
# Выберите один вариант из списка


# - классами


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе описаны два класса следующим образом:
#
# class SmartPhone:
#     pass
#
#
# class IPhone(SmartPhone):
#     pass
# И создается объект второго класса:
#
# phone = IPhone()

# Выберите все верные утверждения, связанные с этой программой.


# - функция issubclass(SmartPhone, IPhone) вернет False, так как SmartPhone является базовым классом для класса IPhone
# - функция isinstance(phone, SmartPhone) вернет True, так как объект phone связан с базовым классом SmartPhone
# - функция issubclass(IPhone, SmartPhone) вернет True, так как IPhone является подклассом класса SmartPhone
# - функция issubclass(IPhone, object) вернет True, так как все классы в Python 3.x неявно наследуются от класса object


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/pohpzoAbkrQ
#
# Подвиг 3. Создается проект, в котором предполагается использовать списки из целых чисел. Для этого вам ставится
# задача создать класс с именем ListInteger с базовым классом list и переопределить три метода:
#
# __init__()
# __setitem__()
# append()
#
# так, чтобы список ListInteger содержал только целые числа. При попытке присвоить любой другой тип данных, генерировать
# исключение командой:
#
# raise TypeError('можно передавать только целочисленные значения')
# Пример использования класса ListInteger (эти строчки в программе не писать):
#
# s = ListInteger((1, 2, 3))
# s[1] = 10
# s.append(11)
# print(s)
# s[0] = 10.5 # TypeError
# P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.


class ListInteger(list):

    def __init__(self, lst):
        for x in lst:
            self.__check_type(x)
        super().__init__(lst)

    def __setitem__(self, key, value):
        self.__check_type(value)
        super().__setitem__(key, value)


    @staticmethod
    def __check_type(val):
        if type(val) != int:
            raise TypeError('можно передавать только целочисленные значения')

    def append(self, val):
        self.__check_type(val)
        super().append(val)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/aFKqv4b2QZ0
#
# Подвиг 4. Разрабатывается интернет-магазин. Каждый товар предполагается представлять классом Thing, объекты которого
# создаются командой:
#
# thing = Thing(name, price, weight)
# где name - наименование товара (строка); price - цена (вещественное число); weight - вес товара (вещественное число).
# В каждом объекте этого класса создаются аналогичные атрибуты: name, price, weight.
#
# Класс Thing необходимо определить так, чтобы его объекты можно было использовать в качестве ключей словаря, например:
#
# d = {}
# d[thing] = thing
# И для каждого уникального набора данных name, price, weight должны формироваться свои уникальные ключи.
#
# Затем, вам необходимо объявить класс словаря DictShop, унаследованный от базового класса dict. В этом новом словаре
# ключами могут выступать только объекты класса Thing. При попытке указать любой другой тип, генерировать исключение
# командой:
#
# raise TypeError('ключами могут быть только объекты класса Thing')
# Объекты класса DictShop должны создаваться командами:
#
# dict_things = DictShop() # пустой словарь
# dict_things = DictShop(things) # словарь с набором словаря things
# где things - некоторый словарь. В инициализаторе следует проверять, чтобы аргумент things был словарем, если не так,
# то выбрасывать исключение:
#
# raise TypeError('аргумент должен быть словарем')
# И проверять, чтобы все ключи являлись объектами класса Thing. Если это не так, то генерировать исключение:
#
# raise TypeError('ключами могут быть только объекты класса Thing')
# Дополнительно в классе DictShop переопределить метод:
#
# __setitem__()
#
# с проверкой, что создаваемый ключ является объектом класса Thing. Иначе, генерировать исключение:
#
# raise TypeError('ключами могут быть только объекты класса Thing')
# Пример использования классов (эти строчки в программе не писать):
#
# th_1 = Thing('Лыжи', 11000, 1978.55)
# th_2 = Thing('Книга', 1500, 256)
# dict_things = DictShop()
# dict_things[th_1] = th_1
# dict_things[th_2] = th_2
#
# for x in dict_things:
#     print(x.name)
#
# dict_things[1] = th_1 # исключение TypeError
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class Thing:

    def __init__(self, name, price, weight):
        self.name = name
        self.price = price
        self.weight = weight

    def __hash__(self):
        return hash((self.name, self.price, self.weight))


class DictShop(dict):

    def __init__(self, things=None):
        things = {} if things is None else things

        if not isinstance(things, dict):
            raise TypeError('аргумент должен быть словарем')
        if things and not all(isinstance(key, Thing) for key in things):
            raise TypeError('ключами могут быть только объекты класса Thing')
        super().__init__(things)

    def __setitem__(self, key, value):
        if not  isinstance(key, Thing):
            raise TypeError('ключами могут быть только объекты класса Thing')
        super().__setitem__(key, value)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Объявите в программе следующие классы без содержимого (используйте оператор pass):
#
# Protists, Plants, Animals, Mosses, Flowering, Worms, Mammals, Human, Monkeys
#
# и постройте схему наследования в соответствии со следующей иерархией древа жизни:


# Затем, объявите в программе классы:
#
# Monkey - наследуется от Monkeys и служит для описания обезьян;
# Person - наследуется от Human и служит для описания человека;
# Flower - наследуется от Flowering и служит для описания цветка;
# Worm - наследуется от Worms и служит для описания червей.
#
# Объекты этих классов должны создаваться командами:
#
# obj = Monkey(name, weight, old)
# obj = Person(name, weight, old)
# obj = Flower(name, weight, old)
# obj = Worm(name, weight, old)
# где name - наименование (или имя) объекта (строка); weight - вес (вещественное число); old - возраст (целое число). В
# каждом объекте любого из этих классов должны создаваться соответствующие атрибуты: name, weight, old.
#
# Создайте в программе следующие объекты и сохраните их в виде списка lst_objs:
#
# Monkey: "мартышка", 30.4, 7
# Monkey: "шимпанзе", 24.6, 8
# Person: "Балакирев", 88, 34
# Person: "Верховный жрец", 67.5, 45
# Flower: "Тюльпан", 0.2, 1
# Flower: "Роза", 0.1, 2
# Worm: "червь", 0.01, 1
# Worm: "червь 2", 0.02, 1
#
# Затем, используя функции isinstance() и генератор списков (List comprehensions), сформируйте следующие списки из
# указанных объектов:
#
# lst_animals - все объекты, относящиеся к животным (Animals);
# lst_plants - все объекты, относящиеся к растениям (Plants);
# lst_mammals - все объекты, относящиеся к млекопитающим (Mammals).
#
# P.S. В программе на экран выводить ничего не нужно.


class Protists:
    pass


class Plants(Protists):
    pass


class Animals(Protists):
    pass


class Mosses(Plants):
    pass


class Worms(Animals):
    pass


class Flowering(Plants):
    pass


class Mammals(Animals):
    pass


class Human(Mammals):
    pass


class Monkeys(Mammals):
    pass


class Monkey(Monkeys):

    def __init__(self, name, weight, old):
        self.name = name
        self.weight = weight
        self.old = old


class Person(Human):

    def __init__(self, name, weight, old):
        self.name = name
        self.weight = weight
        self.old = old


class Flower(Flowering):

    def __init__(self, name, weight, old):
        self.name = name
        self.weight = weight
        self.old = old


class Worm(Worms):

    def __init__(self, name, weight, old):
        self.name = name
        self.weight = weight
        self.old = old


lst_objs = [Monkey("мартышка", 30.4, 7), Monkey("шимпанзе", 24.6, 8), Person("Балакирев", 88, 34),
            Person("Верховный жрец", 67.5, 45), Flower("Тюльпан", 0.2, 1), Flower("Роза", 0.1, 2),
            Worm("червь", 0.01, 1), Worm("червь 2", 0.02, 1)]


lst_animals = [x for x in lst_objs if isinstance(x, Animals)]
lst_plants = [x for x in lst_objs if isinstance(x, Plants)]
lst_mammals = [x for x in lst_objs if isinstance(x, Mammals)]


# Второй вариант
class Protists:
    def __init__(self, name, weight, old):
        self.name = name
        self.weight = weight
        self.old = old


class Plants(Protists):
    pass


class Animals(Protists):
    pass


class Mosses(Plants):
    pass


class Flowering(Plants):
    pass


class Worms(Animals):
    pass


class Mammals(Animals):
    pass


class Human(Mammals):
    pass


class Monkeys(Mammals):
    pass


class Monkey(Monkeys):
    pass


class Person(Human):
    pass


class Flower(Flowering):
    pass


class Worm(Worms):
    pass


task = '''Monkey: "мартышка", 30.4, 7
Monkey: "шимпанзе", 24.6, 8
Person: "Балакирев", 88, 34
Person: "Верховный жрец", 67.5, 45
Flower: "Тюльпан", 0.2, 1
Flower: "Роза", 0.1, 2
Worm: "червь", 0.01, 1
Worm: "червь 2", 0.02, 1'''.split('\n')

lst_objs = []
for el in task:
    cls_name, pars = el.split(': ')
    name, weight, yo = pars.split(', ')
    weight, yo = float(weight), int(yo)
    lst_objs.append(globals()[cls_name](name, weight, yo))


def form_lst(cls_name):
    return [el for el in lst_objs if isinstance(el, cls_name)]


lst_animals = form_lst(Animals)
lst_plants = form_lst(Plants)
lst_mammals = form_lst(Mammals)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Известно, что с объектами класса tuple можно складывать только такие же объекты (кортежи). Например:
#
# t1 = (1, 2, 3)
# t2 = t1 + (4, 5) # (1, 2, 3, 4, 5)
# Если же мы попытаемся прибавить любой другой итерируемый объект, например, список:
#
# t2 = t1 + [4, 5]
# то возникнет ошибка. Предлагается поправить этот функционал и создать свой собственный класс Tuple, унаследованный
# от базового класса tuple и поддерживающий оператор:
#
# t1 = Tuple(iter_obj)
# t2 = t1 + iter_obj  # создается новый объект класса Tuple с новым (соединенным) набором данных
# где iter_obj - любой итерируемый объект (список, словарь, строка, множество, кортеж и т.п.)
#
# Пример использования класса (эти строчки в программе не писать):
#
# t = Tuple([1, 2, 3])
# t = t + "Python"
# print(t)   # (1, 2, 3, 'P', 'y', 't', 'h', 'o', 'n')
# t = (t + "Python") + "ООП"
# P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.


class Tuple(tuple):

    def __add__(self, other):
        return Tuple(tuple(self) + tuple(other))



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7 (на повторение). Необходимо в программе объявить класс VideoItem для представления одного
# видео (например, в youtube). Объекты этого класса должны создаваться командой:
#
# video = VideoItem(title, descr, path)
# где title - заголовок видео (строка); descr - описание видео (строка); path - путь к видеофайлу. В каждом объекте
# класса VideoItem должны создаваться соответствующие атрибуты: title, descr, path.
#
# Затем, нужно создать класс для формирования оценки видео в баллах от 0 до 5. Для этого нужно объявить еще один класс
# с именем VideoRating, объекты которого создаются командой:
#
# rating = VideoRating()
# В каждом объекте класса VideoRating должен быть локальный приватный атрибут с именем __rating, содержащий целое
# число от 0 до 5 (по умолчанию 0). А для записи и считывания значения из этого приватного атрибута должно быть
# объект-свойство (property) с именем rating.
#
# Так как атрибут __rating - это целое число в диапазоне [0; 5], то в момент присвоения ему какого-либо значения
# необходимо проверять, что присваиваемое значение - целое число в диапазоне [0; 5]. Если это не так, то генерировать
# исключение командой:
#
# raise ValueError('неверное присваиваемое значение')
# Далее, в каждом объекте класса VideoItem должен быть локальный атрибут rating - объект класса VideoRating.
#
# Пример использования классов (эти строчки в программе не писать):
#
# v = VideoItem('Курс по Python ООП', 'Подробный курс по Python ООР', 'D:/videos/python_oop.mp4')
# print(v.rating.rating) # 0
# v.rating.rating = 5
# print(v.rating.rating) # 5
# title = v.title
# descr = v.descr
# v.rating.rating = 6  # ValueError
# P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.


class VideoItem:

    def __init__(self, title, descr, path):
        self.title = title
        self.descr = descr
        self.path = path
        self.rating = VideoRating()


class VideoRating:

    def __init__(self):
        self.__rating = 0

    @staticmethod
    def __check_rate(val):
        if type(val) == int and 0 <= val <= 5:
            return True
        raise ValueError('неверное присваиваемое значение')

    @property
    def rating(self):
        return self.__rating

    @rating.setter
    def rating(self, rate):
        self.__check_rate(rate)
        self.__rating = rate


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Отметьте все верные определения для функций isinstance() и issubclass().

# - функция issubclass(cls1, cls2) возвращает True, если класс cls1 является подклассом класса cls2
# - функция isinstance(obj, cls) возвращает True, если объект obj является объектом класса cls


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0Jy6n9KESPE
#
# Подвиг 9 (на повторение). Объявите в программе базовый класс с именем IteratorAttrs для перебора всех локальных
# атрибутов объектов класса. Напомню, что для этого используются два магических метода:
#
# __iter__() - для получения объекта-итератора (в данном случае - это сам объект self)
# __next__() - для перебора локальных атрибутов объекта self (используйте для этого словарь __dict__)
#
# Метод __next__() на каждой итерации должен возвращать кортеж в формате: (имя атрибута, значение).
#
# Подсказка: здесь можно определить один метод __iter__() как функцию-генератор.
#
# Объявите дочерний класс SmartPhone, объекты которого создаются командой:
#
# phone = SmartPhone(model, size, memory)
# где model - модель смартфона (строка); size - габариты (ширина, длина) в виде кортежа двух чисел; memory - размер
# ОЗУ (памяти), как целое число. В каждом объекте класса SmartPhone должны создаваться соответствующие локальные
# атрибуты: model, size, memory.
#
# Благодаря наследованию от базового класса IteratorAttrs, с объектами класса SmartPhone должен выполняться оператор for:
#
# for attr, value in phone:
#     print(attr, value)
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class IteratorAttrs:

    def __iter__(self):
        for x in self.__dict__.items():
            yield x


class SmartPhone(IteratorAttrs):

    def __init__(self, model, size, memory):
        self.model = model
        self.size = size
        self.memory = memory


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 4.3 Наследование. Функция super() и делегирование
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. В программе записаны следующие классы:
#
# class Phone:
#     def get_info(self):
#         return "Phone"
#
#
# class SmartPhone(Phone):
#     def call(self):
#         pass
#
#     def get_info(self):
#         return "SmartPhone"
# Выберите все верные утверждения, связанные с этой программой.


# - дочерний класс SmartPhone расширяет базовый класс Phone
# - в классе SmartPhone выполняется переопределение метода get_info()
# - класс SmartPhone наследуется от класса Phone


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе записаны следующие классы:
#
# class SmartPhone:
#     def call(self):
#         pass
#
#     def get_info(self):
#         return "SmartPhone"
#
#
# class IPhone(SmartPhone):
#     def __init__(self, model):
#         self.model = model
#
#     def get_info(self):
#         return super().get_info() + ": IPhone " + self.model
#
# Выберите все верные утверждения, связанные с этой программой.


# - в методе get_info() класса IPhone выполняется делегированый вызов метода get_info() класса SmartPhone
# - в классе IPhone выполняется переопределение метода get_info()
# - класс IPhone расширяет класс SmartPhone


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Ранее вы уже использовали делегирование методов, когда вызывали инициализатор базового класса через
# функцию super(). Чаще всего делегирование в Python связано с вызовом магических методов базовых классов (так как их
# имена нельзя менять). Выполним такой пример.
#
# Объявите в программе базовый класс с именем Book, объекты которого создаются командой:
#
# book = Book(title, author, pages, year)
# где title - заголовок книги (строка); author - автор книги (строка); pages - число страниц (целое число); year - год
# издания (целое число). В каждом объекте класса Book должны формироваться соответствующие локальные атрибуты: title,
# author, pages, year.
#
# Объявите дочерний класс DigitBook от класса Book, объекты которого создаются командой:
#
# db = DigitBook(title, author, pages, year, size, frm)
# где дополнительные параметры size - размер книги в байтах (целое число); frm - формат книги (строка: 'pdf', 'doc',
# 'fb2', 'txt'). В каждом объекте класса DigitBook должны формироваться соответствующие локальные атрибуты: title,
# author, pages, year, size, frm.
#
# Инициализация локальных атрибутов title, author, pages, year должна выполняться в базовом классе Book, а параметры
# size, frm инициализируются в дочернем классе DigitBook.
#
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class Book:

    def __init__(self, title, author, pages, year):
        self.title = title
        self.author = author
        self.pages = pages
        self.year = year


class DigitBook(Book):

    def __init__(self, title, author, pages, year, size, frm):
        super().__init__(title, author, pages, year)
        self.size = size
        self.frm = frm


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Создается программа по учету склада. Каждый предмет на складе должен описываться базовым классом Thing.
# Объекты этого класса создаются командой:
#
# th1 = Thing(name, weight)
# где name - наименование предмета (строка); weight - вес предмета (вещественное число).
#
# Для описания каждого конкретного вида предметов, создаются дочерние классы (на основе базового Thing):
#
# ArtObject - для представления арт-объектов;
# Computer - для системных блоков компьютеров;
# Auto - для автомобилей.
#
# Объекты этих классов создаются командами:
#
# obj = ArtObject(name, weight, author, date)  # author - автор (строка); date - дата создания (строка)
# obj = Computer(name, weight, memory, cpu)    # memory - размер памяти (целое число); cpu - тип процессора (строка)
# obj = Auto(name, weight, dims)               # dims - габариты, кортеж (width, length, height) - вещественные или
# целые числа
# На основе класса Auto создаются дочерние классы Mercedes и Toyota, объекты которых определяются командами:
#
# auto = Mercedes(name, weight, dims, model, old) # model - модель (строка); old - время использования, в годах
# (целое число)
# auto = Toyota(name, weight, dims, model, wheel) # model - модель (строка); wheel - тип руля: True - леворульный,
# False - праворульный
# Во всех объектах классов должны создаваться соответствующие локальные атрибуты: name, weight и т.д.
#
# Инициализация атрибутов должна выполняться в соответствующих классах (не должно быть дублирования кода).
#
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class Thing:

    def __init__(self, name, weight):
        self.name = name
        self.weight = weight


class ArtObject(Thing):

    def __init__(self, name, weight, author, date):
        super().__init__(name, weight)
        self.author = author
        self.date = date


class Computer(Thing):

    def __init__(self, name, weight, memory, cpu):
        super().__init__(name, weight)
        self.memory = memory
        self.cpu = cpu


class Auto(Thing):

    def __init__(self, name, weight, dims):
        super().__init__(name, weight)
        self.dims = dims


class Mercedes(Auto):

    def __init__(self, name, weight, dims, model, old):
        super().__init__(name, weight, dims)
        self.old = old
        self.model = model


class Toyota(Auto):

    def __init__(self, name, weight, dims, model, wheel):
        super().__init__(name, weight, dims)
        self.wheel = wheel
        self.model = model


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Вам поручено организовать представление объектов для продажи в риэлтерских агентствах. Для этого в
# программе нужно объявить базовый класс SellItem, объекты которого создаются командой:
#
# item = SellItem(name, price)
# где name - название объекта продажи (строка); price - цена продажи (число: целое или вещественное).
#
# Каждые конкретные типы объектов описываются следующими классами, унаследованные от базового SellItem:
#
# House - дома;
# Flat - квартиры;
# Land - земельные участки.


# Объекты этих классов создаются командами:
#
# house = House(name, price, material, square)
# flat = Flat(name, price, size, rooms)
# land = Land(name, price, square)
# В каждом объекте этих классов должны формироваться соответствующие локальные атрибуты: name, price и т.д.
#
# Формирование атрибутов name и price должно выполняться в инициализаторе базового класса.
#
# Далее, объявить еще один класс с именем Agency, объекты которого создаются командой:
#
# ag = Agency(name)
# где name - название агентства (строка). В классе Agency объявить следующие методы:
#
# add_object(obj) - добавление нового объекта недвижимости для продажи (один из объектов классов: House, Flat, Land);
# remove_object(obj) - удаление объекта obj из списка объектов для продажи;
# get_objects() - возвращает список из всех объектов для продажи.
#
# Пример использования классов (эти строчки в программе не писать):
#
# ag = Agency("Рога и копыта")
# ag.add_object(Flat("квартира, 3к", 10000000, 121.5, 3))
# ag.add_object(Flat("квартира, 2к", 8000000, 74.5, 2))
# ag.add_object(Flat("квартира, 1к", 4000000, 54, 1))
# ag.add_object(House("дом, крипичный", price=35000000, material="кирпич", square=186.5))
# ag.add_object(Land("участок под застройку", 3000000, 6.74))
# for obj in ag.get_objects():
#     print(obj.name)
#
# lst_houses = [x for x in ag.get_objects() if isinstance(x, House)] # выделение списка домов
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class SellItem:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class House(SellItem):

    def __init__(self, name, price, material, square):
        super().__init__(name, price)
        self.material = material
        self.square = square


class Flat(SellItem):

    def __init__(self, name, price, size, rooms):
        super().__init__(name, price)
        self.size = size
        self.rooms = rooms


class Land(SellItem):

    def __init__(self, name, price, square):
        super().__init__(name, price)
        self.square = square


class Agency:

    def __init__(self, name):
        self.name = name
        self.objs = []

    def add_object(self, obj):
        self.objs.append(obj)

    def remove_onject(self, obj):
        self.objs.remove(obj)

    def get_objects(self):
        return self.objs


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/as-ZOz8i4OU
#
# Подвиг 6 (на повторение). Ваша команда создает небольшой фреймворк для веб-сервера. Для этого был объявлен класс:
#
# class Router:
#     app = {}
#
#     @classmethod
#     def get(cls, path):
#         return cls.app.get(path)
#
#     @classmethod
#     def add_callback(cls, path, func):
#         cls.app[path] = func
# И его предполагается использовать следующим образом:
#
# @Callback('/', Router)
# def index():
#     return '<h1>Главная</h1>'
#
#
# route = Router.get('/')
# if route:
#     ret = route()
#     print(ret)
# Здесь Callback - это класс-декоратор с параметрами: path = '/' - маршрут; router_cls = Router - класс роутера.
# Декоратор Callback должен обеспечивать добавление функции (в примере index) в словарь app класса Router. Ключом
# словаря выступает маршрут (path), а значением - ссылка на декорируемую функцию. Для этого следует использовать
# метод add_callback класса Router.
#
# Затем, из роутера (Router) методом get выбирается ранее добавленная функция (в примере index), и если она
# существует, то вызывается с выводом результата в консоль.
#
# Ваша задача реализовать класс-декоратор Callback.
#
# Небольшая справка.
#
# Для реализации декоратора с параметрами на уровне класса в инициализаторе __init__(self, methods) прописываем
# параметр для декоратора, а магический метод __call__() объявляем для декорирования функции:
#
# class Handler:
#     def __init__(self, path, route_cls):
#         # здесь нужные строчки
#
#     def __call__(self, func):
#         # здесь строчки
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class Router:
    app = {}

    @classmethod
    def get(cls, path):
        return cls.app.get(path)

    @classmethod
    def add_callback(cls, path, func):
        cls.app[path] = func

# здесь объявляйте декоратор Callback

class Callback:
    def __init__(self, path, route_cls):
        self.__path = path
        self.__route_cls = route_cls

    def __call__(self, func):
        self.__route_cls.add_callback(self.__path, func)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/pF1ito-hcZI
#
# Подвиг 7. В программе объявлена функция integer_params для класса Vector, которая применяет к каждому методу класса
# декоратор integer_params_decorated:
#
# def integer_params(cls):
#     methods = {k: v for k, v in cls.__dict__.items() if callable(v)}
#     for k, v in methods.items():
#         setattr(cls, k, integer_params_decorated(v))
#
#     return cls
#
#
# @integer_params
# class Vector:
#     def __init__(self, *args):
#         self.__coords = list(args)
#
#     def __getitem__(self, item):
#         return self.__coords[item]
#
#     def __setitem__(self, key, value):
#         self.__coords[key] = value
#
#     def set_coords(self, *coords, reverse=False):
#         c = list(coords)
#         self.__coords = c if not reverse else c[::-1]
# Декоратор integer_params_decorated должен проверять, чтобы все передаваемые аргументы в методы класса (кроме
# первого self) были целыми числами (имели тип int). Если это не так, то должно генерироваться исключение командой:
#
# raise TypeError("аргументы должны быть целыми числами")
# Ваша задача объявить эту функцию-декоратор.
#
# Пример использования класса (эти строчки в программе не писать):
#
# vector = Vector(1, 2)
# print(vector[1])
# vector[1] = 20.4 # TypeError
# P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.


# здесь объявляйте функцию-декоратор
def integer_params_decorated(func):
    def wrapper(self, *args, **kwargs):
        if not all(type(x) == int for x in args):
            raise TypeError("аргументы должны быть целыми числами")
        if not all(type(x) == int for x in  kwargs.values()):
            raise TypeError("аргументы должны быть целыми числами")
        return func(self, *args, **kwargs)
    return wrapper

def integer_params(cls):
    methods = {k: v for k, v in cls.__dict__.items() if callable(v)}
    for k, v in methods.items():
        setattr(cls, k, integer_params_decorated(v))

    return cls


@integer_params
class Vector:
    def __init__(self, *args):
        self.__coords = list(args)

    def __getitem__(self, item):
        return self.__coords[item]

    def __setitem__(self, key, value):
        self.__coords[key] = value

    def set_coords(self, *coords, reverse=False):
        c = list(coords)
        self.__coords = c if not reverse else c[::-1]


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8 (на повторение). Объявите класс SoftList, который наследуется от стандартного класса list. В классе
# SoftList следует объявить необходимые магические методы так, чтобы при обращении к несуществующему элементу (по
# индексу) возвращалось значение False (а не исключение Out of Range). Например:
#
# sl = SoftList("python")
# sl[0] # 'p'
# sl[-1] # 'n'
# sl[6] # False
# sl[-7] # False
# P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.


class SoftList(list):

    def __getitem__(self, item):
        try:
            return super().__getitem__(item)
        except IndexError:
            return False


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (на повторение). Объявите класс StringDigit, который наследуется от стандартного класса str. Объекты
# класса StringDigit должны создаваться командой:
#
# sd = StringDigit(string)
# где string - строка из цифр (например, "12455752345950"). Если в строке string окажется хотя бы один не цифровой
# символ, то генерировать исключение командой:
#
# raise ValueError("в строке должны быть только цифры")
# Также в классе StringDigit нужно переопределить оператор + (конкатенации строк) так, чтобы операции:
#
# sd = sd + "123"
# sd = "123" + sd
# создавали новые объекты класса StringDigit (а не класса str). Если же при соединении строк появляется не цифровой
# символ, то генерировать исключение:
#
# raise ValueError("в строке должны быть только цифры")
# Пример использования класса (эти строчки в программе не писать):
#
# sd = StringDigit("123")
# print(sd)       # 123
# sd = sd + "456" # StringDigit: 123456
# sd = "789" + sd # StringDigit: 789123456
# sd = sd + "12f" # ValueError
# P.S. В программе нужно объявить только класс. На экран выводить ничего не нужно.


class StringDigit(str):

    def __init__(self, string):
        self.__check_text(string)
        self.string = string

    @staticmethod
    def __check_text(text):
        if not all(x.isdigit() for x in text):
            raise ValueError("в строке должны быть только цифры")
        return True

    def __add__(self, other):
        self.__check_text(other)
        return StringDigit(self.string + other)

    def __radd__(self, other):
        self.__check_text(other)
        return StringDigit(other + self.string)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение). Объявите базовый класс с именем ItemAttrs, который бы позволял обращаться к локальным
# атрибутам объектов дочерних классов по индексу. Для этого в классе ItemAttrs нужно переопределить следующие методы:
#
# __getitem__() - для получения значения атрибута по индексу;
# __setitem__() - для изменения значения атрибута по индексу.
#
# Объявите дочерний класс Point для представления координаты точки на плоскости. Объекты этого класса должны
# создаваться командой:
#
# pt = Point(x, y)
# где x, y - целые или вещественные числа.
#
# Пример использования классов (эти строчки в программе не писать):
#
# pt = Point(1, 2.5)
# x = pt[0]   # 1
# y = pt[1]   # 2.5
# pt[0] = 10
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class ItemAttrs:

    def __getitem__(self, item):
        return list(self.__dict__.values())[item]

    def __setitem__(self, key, value):
        self.__dict__[list(self.__dict__.keys())[key]] = value


class Point(ItemAttrs):

    def __init__(self, x, y):
        self.x = x
        self.y = y


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 4.4 Наследование. Атрибуты private и protected
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Отметьте все верные утверждения о приватных (private) и защищенных (protected) атрибутах классов.

# - защищенные атрибуты классов доступны всюду по их исходным именам, также как и публичные (public) атрибуты классов
# - приватные атрибуты, созданные в инициализаторе базового класса, недоступны (по их исходным именам) в дочерних
# классах
# - приватные атрибуты создаются с целью их использования только в текущем классе
# - защищенные атрибуты создаются с целью их использования в текущем классе и во всех дочерних классах


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе объявлены два класса следующим образом:
#
# class Phone:
#     def __init__(self, model):
#         self.__model = model
#
#
# class SmartPhone(Phone):
#     def __init__(self, model, memory):
#         super().__init__(model)
#         self.__memory = memory
#
#     def get_info(self):
#         return self.__model, self.__memory
# И выполняются команды:
#
# phone = SmartPhone('iPhone 123', 1024)
# print(phone.get_info())

# Выберите все верные утверждения о приведенной программе.


# - в момент вызова метода get_info() произойдет ошибка, так как локальный атрибут __model отсутствует в
# классе SmartPhone
# - приватная переменная __model доступна только внутри класса Phone и недоступна в классе SmartPhone


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Имеется следующая программа:
#
# class Auto:
#     __MIN_WEIGHT = 100
#     __MAX_WEIGHT = 1000
#
#     def __init__(self, model):
#         self.__verify_model(model)
#         self.__model = model
#
#     def __verify_model(self, model):
#         if type(model) != str:
#             raise TypeError('модель должна представляться строкой')
#
#
# class BMW(Auto):
#     def __init__(self, model, weight):
#         super().__init__(model)
#         self.__verify_weight(weight)
#         self.__weight = weight
#
#     def __verify_weight(self, weight):
#         if self.__MIN_WEIGHT > weight or weight > self.__MAX_WEIGHT:
#             raise TypeError(f'вес автомобиля BMW должен быть в пределах [{self.__MIN_WEIGHT}; {self.__MAX_WEIGHT}]')
#
#
# bmw_x5 = BMW('BMW X5', 512.5)
# print(bmw_x5._BMW__weight)
# print(bmw_x5._Auto__model)
#
# Выберите все верные утверждения, применительно к данной программе.

# - метод __verify_model() класса Auto недоступен по этому имени в дочернем классе BMW
# - метод __verify_weight() класса BMW недоступен по этому имени в базовом классе Auto
# - атрибуты __MIN_WEIGHT и __MAX_WEIGHT доступны только внутри класса Auto


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Выберите все верные утверждения о приватных методах.

# - если перед именем метода и после него стоят два подчеркивания (например, __abc__()), то такой метод является
# публичным;
# - все магические методы публичны, т.к. после их имен стоят два подчеркивания


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Объявите класс Animal (животное), объекты которого создаются командой:
#
# an = Animal(name, kind, old)
# где name - название животного (строка); kind - вид животного (строка); old - возраст (целое число). В каждом объекте
# этого класса должны создаваться соответствующие приватные атрибуты: __name, __kind, __old.
#
# В классе Animal должны быть объявлены объекты-свойства для изменения и считывания приватных атрибутов:
#
# name - для работы с приватным атрибутом __name;
# kind - для работы с приватным атрибутом __kind;
# old - для работы с приватным атрибутом __old.
#
# Создайте в программе список с именем animals, который содержит три объекта класса Animal со следующими данными:
#
# Васька; дворовый кот; 5
# Рекс; немецкая овчарка; 8
# Кеша; попугай; 3
#
# P.S. В программе нужно объявить только класс и создать список animals. На экран выводить ничего не нужно.


class Animal:

    def __init__(self, name, kind, old):
        self.__name = name
        self.__kind = kind
        self.__old = old

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name

    @property
    def kind(self):
        return self.__kind

    @kind.setter
    def kind(self, kind):
        self.__kind = kind

    @property
    def old(self):
        return self.__old

    @old.setter
    def old(self, old):
        self.__old = old


ex = [x.split('; ') for x in ['Васька; дворовый кот; 5', 'Рекс; немецкая овчарка; 8', 'Кеша; попугай; 3']]

animals = [Animal(*x) for x in ex]


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Объявите класс Furniture (мебель), объекты которого создаются командой:
#
# f = Furniture(name, weight)
# где name - название предмета (строка); weight - вес предмета (целое или вещественное число).
#
# В каждом объекте класса Furniture должны создаваться защищенные локальные атрибуты с именами _name и _weight. В самом
# классе Furniture нужно объявить приватные методы:
#
# __verify_name() - для проверки корректности имени;
# __verify_weight() - для проверки корректности веса.
#
# Метод __verify_name() проверяет, что имя должно быть строкой, если это не так, то генерируется исключение командой:
#
# raise TypeError('название должно быть строкой')
# Метод __verify_weight() проверяет, что вес должен быть положительным числом (строго больше нуля), если это не так, то
# генерируется исключение командой:
#
# raise TypeError('вес должен быть положительным числом')
# Данные методы следует вызывать всякий раз при записи новых значений в атрибуты _name и _weight (а также при их
# создании).
#
# На основе базового класса Furniture объявить следующие дочерние классы:
#
# Closet - для представления шкафов;
# Chair - для представления стульев;
# Table - для представления столов.
#
# Объекты этих классов должны создаваться командами:
#
# obj = Closet(name, weight, tp, doors)   # tp: True - шкаф-купе; False - обычный шкаф; doors - число дверей (целое
# число)
# obj = Chair(name, weight, height)       # height - высота стула (любое положительное число)
# obj = Table(name, weight, height, square) # height - высота стола; square - площадь поверхности (любые положительные
# числа)
# В каждом объекте этих классов должны создаваться соответствующие защищенные атрибуты:
#
# - в объектах класса Closet: _name, _weight, _tp, _doors
# - в объектах класса Chair: _name, _weight, _height
# - в объектах класса Table: _name, _weight, _height, _square
#
# В каждом классе (Closet, Chair, Table) объявить метод:
#
# get_attrs()
# который возвращает кортеж из значений локальных защищенных атрибутов объектов этих классов.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# cl = Closet('шкаф-купе', 342.56, True, 3)
# chair = Chair('стул', 14, 55.6)
# tb = Table('стол', 34.5, 75, 10)
# print(tb.get_attrs())
# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class Furniture:
    def __init__(self, name, weight):
        self._name = name
        self._weight = weight

    def __setattr__(self, key, value):
        verify = {'_name': self.__verify_name, '_weight': self.__verify_weight}
        if key in verify:
            verify[key](value)
        object.__setattr__(self, key, value)

    def get_attrs(self):
        return tuple(self.__dict__.values())

    def __verify_weight(self, weight):
        if type(weight) not in (int, float) or weight <= 0:
            raise TypeError('вес должен быть положительным числом')

    def __verify_name(self, name):
        if not isinstance(name, str):
            raise TypeError('название должно быть строкой')

class Closet(Furniture):
    def __init__(self, name, weight, tp, doors):
        super().__init__(name, weight)
        self._tp = tp
        self._doors = doors

class Chair(Furniture):
    def __init__(self, name, weight, height):
        super().__init__(name, weight)
        self._height = height

class Table(Furniture):
    def __init__(self, name, weight, height, square):
        super().__init__(name, weight)
        self._height = height
        self._square = square


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/d5aNVdHGj44
#
# Подвиг 7 (введение в паттерн слушатель). Своей работой вы немного впечатлили начальство и оно поручило вам доделать
# паттерн слушатель (listener). Идея этого паттерна очень проста и основа реализуется следующим образом:
#
# class Observer:
#     def update(self, data):
#         pass
#
#     def __hash__(self):
#         return hash(id(self))
#
#
# class Subject:
#     def __init__(self):
#         self.__observers = {}
#         self.__data = None
#
#     def add_observer(self, observer):
#         self.__observers[observer] = observer
#
#     def remove_observer(self, observer):
#         if observer in self.__observers:
#             self.__observers.pop(observer)
#
#     def __notify_observer(self):
#         for ob in self.__observers:
#             ob.update(self.__data)
#
#     def change_data(self, data):
#         self.__data = data
#         self.__notify_observer()
# Здесь в объектах класса Subject можно зарегистрировать (добавить) множество объектов класса Observer (наблюдатель,
# слушатель). Это делается с помощью метода add_observer(). Затем, когда данные (self.__data) меняются путем вызова
# метода change_data() класса Subject, то у всех слушателей автоматически вызывается метод update(). В этом методе
# можно прописать самую разную логику работы при изменении данных в каждом конкретном слушателе.
#
# В проекте данный паттерн предполагается использовать для отображения информации о погоде в различных форматах:
#
# - текущая температура;
# - текущее атмосферное давление;
# - текущая влажность воздуха.
#
# Для этого сами данные определяются классом:
#
# class Data:
#     def __init__(self, temp, press, wet):
#         self.temp = temp    # температура
#         self.press = press  # давление
#         self.wet = wet      # влажность
# А вам поручается разработать дочерние классы, унаследованные от класса Observer, с именами:
#
# TemperatureView - слушатель для отображения информации о температуре;
# PressureView - слушатель для отображения информации о давлении;
# WetView - слушатель для отображения информации о влажности.
#
# Каждый из этих классов должен переопределять метод update() базового класса так, чтобы выводилась в консоль
# информация в формате:
#
# TemperatureView: "Текущая температура <число>"
# PressureView: "Текущее давление <число>"
# WetView: "Текущая влажность <число>"
#
# Важно: для вывода информации в консоль используйте функцию print() с одним аргументом в виде F-строки.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# subject = Subject()
# tv = TemperatureView()
# pr = PressureView()
# wet = WetView()
#
# subject.add_observer(tv)
# subject.add_observer(pr)
# subject.add_observer(wet)
#
# subject.change_data(Data(23, 150, 83))
# # выведет строчки:
# # Текущая температура 23
# # Текущее давление 150
# # Текущая влажность 83
# subject.remove_observer(wet)
# subject.change_data(Data(24, 148, 80))
# # выведет строчки:
# # Текущая температура 24
# # Текущее давление 148

# P.S. В программе нужно объявить только классы. На экран выводить ничего не нужно.


class Observer:
    def update(self, data):
        pass

    def __hash__(self):
        return hash(id(self))


class Subject:
    def __init__(self):
        self.__observers = {}
        self.__data = None

    def add_observer(self, observer):
        self.__observers[observer] = observer

    def remove_observer(self, observer):
        if observer in self.__observers:
            self.__observers.pop(observer)

    def __notify_observer(self):
        for ob in self.__observers:
            ob.update(self.__data)

    def change_data(self, data):
        self.__data = data
        self.__notify_observer()


class Data:
    def __init__(self, temp, press, wet):
        self.temp = temp    # температура
        self.press = press  # давление
        self.wet = wet      # влажность


# здесь объявляйте дочерние классы TemperatureView, PressureView и WetView

class TemperatureView(Observer):

    def update(self, data):
        if data:
            print(f'Текущая температура {data.temp}')


class PressureView(Observer):

    def update(self, data):
        if data:
            print(f'Текущее давление {data.press}')


class WetView(Observer):

    def update(self, data):
        if data:
            print(f'Текущая влажность {data.wet}')


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Объявите базовый класс Aircraft (самолет), объекты которого создаются командой:
#
# air = Aircraft(model, mass, speed, top)
# где model - модель самолета (строка); mass - подъемная масса самолета (любое положительное число);
# speed - максимальная скорость (любое положительное число); top - максимальная высота полета (любое положительное
# число).
#
# В каждом объекте класса Aircraft должны создаваться локальные атрибуты с именами: _model, _mass, _speed, _top и
# соответствующими значениями. Если передаваемые аргументы не соответствуют указанным критериям (строка, любое
# положительное число), то генерируется исключение командой:
#
# raise TypeError('неверный тип аргумента')
# Далее, в программе объявите следующие дочерние классы:
#
# PassengerAircraft - пассажирский самолет;
# WarPlane - военный самолет.
#
# Объекты этих классов создаются командами:
#
# pa = PassengerAircraft(model, mass, speed, top, chairs)  # chairs - число пассажирских мест (целое положительное
# число)
# wp = WarPlane(model, mass, speed, top, weapons) # weapons - вооружение (словарь); ключи - название оружия,
# значение - количество
# В каждом объекте классов PassengerAircraft и WarPlane должны формироваться локальные атрибуты с именами _chairs
# и _weapons соответственно. Инициализация остальных атрибутов должна выполняться через инициализатор базового класса.
#
# В инициализаторах классов PassengerAircraft и WarPlane проверять корректность передаваемых аргументов chairs и
# weapons. Если тип данных не совпадает, то генерировать исключение командой:
#
# raise TypeError('неверный тип аргумента')
# Создайте в программе четыре объекта самолетов со следующими данными:
#
# PassengerAircraft: МС-21, 1250, 8000, 12000.5, 140
# PassengerAircraft: SuperJet, 1145, 8640, 11034, 80
# WarPlane: Миг-35, 7034, 25000, 2000, {"ракета": 4, "бомба": 10}
# WarPlane: Су-35, 7034, 34000, 2400, {"ракета": 4, "бомба": 7}
#
# Все эти объекты представить в виде списка planes.
#
# P.S. В программе нужно объявить только классы и сформировать список На экран выводить ничего не нужно.


class Aircraft:

    def __init__(self, model, mass, speed, top):
        self._model = model
        self._mass = mass
        self._speed = speed
        self._top = top

    def __setattr__(self, key, value):
        verify = {'_model': self._verify_str, '_mass': self._verify_num, '_speed': self._verify_num,
                  '_top': self._verify_num}
        if key in verify:
            verify[key](value)
        object.__setattr__(self, key, value)

    def _verify_str(self, val):
        if type(val) != str:
            raise TypeError('неверный тип аргумента')

    def _verify_num(self, val):
        if type(val) not in (int, float):
            raise TypeError('неверный тип аргумента')
        if val < 0:
            raise TypeError('неверный тип аргумента')


class PassengerAircraft(Aircraft):

    def __init__(self, model, mass, speed, top, chairs):
        super().__init__(model, mass, speed, top)
        if type(chairs) != int or chairs < 0:
            raise TypeError('неверный тип аргумента')
        self._chairs = chairs


class WarPlane(Aircraft):

    def __init__(self, model, mass, speed, top, weapons):
        super().__init__(model, mass, speed, top)
        if type(weapons) != dict:
            raise TypeError('неверный тип аргумента')
        self._weapons = weapons

planes = [PassengerAircraft('МС-21', 1250, 8000, 12000.5, 140),
          PassengerAircraft('SuperJet', 1145, 8640, 11034, 80),
          WarPlane('Миг-35', 7034, 25000, 2000, {"ракета": 4, "бомба": 10}),
          WarPlane('Су-35', 7034, 34000, 2400, {"ракета": 4, "бомба": 7})]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ArF90ldgm70
#
# Подвиг 9 (на повторение). Необходимо объявить функцию-декоратор class_log для класса, которая бы создавала
# логирование вызовов методов класса. Например следующие строчки программы:
#
# vector_log = []
#
#
# @class_log(vector_log)
# class Vector:
#     def __init__(self, *args):
#         self.__coords = list(args)
#
#     def __getitem__(self, item):
#         return self.__coords[item]
#
#     def __setitem__(self, key, value):
#         self.__coords[key] = value
# декорируют класс Vector и в список vector_log добавляются имена методов, которые были вызваны при использовании
# этого класса. В частности, после выполнения команд:
#
# v = Vector(1, 2, 3)
# v[0] = 10
# в списке vector_log должны быть два метода:
#
# ['__init__', '__setitem__']
#
# Ваша задача реализовать декоратор с именем class_log.
#
# Напоминание. Ранее вы уже создавали функцию-декоратор для класса следующим образом:
#
# def integer_params(cls):
#     methods = {k: v for k, v in cls.__dict__.items() if callable(v)}
#     for k, v in methods.items():
#         setattr(cls, k, integer_params_decorated(v))
#
#     return cls
# Используйте этот принцип для успешного прохождения подвига.
#
# P.S. В программе нужно объявить только класс и необходимые функции. На экран выводить ничего не нужно.


# здесь объявляйте декоратор и все что с ним связано
def class_log(log_lst):
    def log_methods(cls):
        methods = {k: v for k, v in cls.__dict__.items() if callable(v)}
        for k, v in methods.items():
            setattr(cls, k, log_method_decorator(v))
        return cls

    def log_method_decorator(func):
        def wrapper(*args, **kwargs):
            log_lst.append(func.__name__)
            return func(*args, **kwargs)
        return wrapper

    return log_methods

vector_log = []   # наименование (vector_log) в программе не менять!


@class_log(vector_log)
class Vector:
    def __init__(self, *args):
        self.__coords = list(args)

    def __getitem__(self, item):
        return self.__coords[item]

    def __setitem__(self, key, value):
        self.__coords[key] = value


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение). В программе объявлены два класса и глобальная переменная:
#
# CURRENT_OS = 'windows'   # 'windows', 'linux'
#
#
# class WindowsFileDialog:
#     def __init__(self, title, path, exts):
#         self.__title = title # заголовок диалогового окна
#         self.__path = path  # начальный каталог с файлами
#         self.__exts = exts  # кортеж из отображаемых расширений файлов
#
#
# class LinuxFileDialog:
#     def __init__(self, title, path, exts):
#         self.__title = title # заголовок диалогового окна
#         self.__path = path  # начальный каталог с файлами
#         self.__exts = exts  # кортеж из отображаемых расширений файлов
# Вам необходимо объявить класс с именем FileDialogFactory (фабрика классов), который бы при выполнении команды:
#
# dlg = FileDialogFactory(title, path, exts)
# возвращал объект класса WindowsFileDialog, если CURRENT_OS равна строке 'windows', в противном случае - объект
# класса LinuxFileDialog. Объект самого класса FileDialogFactory создаваться не должен.
#
# Для реализации такой логики, объявите внутри класса FileDialogFactory два статических метода:
#
# def create_windows_filedialog(title, path, exts) - для создания объектов класса WindowsFileDialog;
# def create_linux_filedialog(title, path, exts) - для создания объектов класса LinuxFileDialog.
#
# Эти методы следует вызывать в магическом методе __new__() класса FileDialogFactory. Подумайте, как это правильно
# сделать, чтобы не создавался объект самого класса, а лишь возвращался объект или класса WindowsFileDialog, или
# класса LinuxFileDialog.
#
# Пример использования класса (эту строчку в программе не писать):
#
# dlg = FileDialogFactory('Изображения', 'd:/images/', ('jpg', 'gif', 'bmp', 'png'))

# P.S. В программе нужно дополнительно объявить только класс FileDialogFactory. На экран выводить ничего не нужно.


CURRENT_OS = 'windows'   # 'windows', 'linux'


class WindowsFileDialog:
    def __init__(self, title, path, exts):
        self.__title = title # заголовок диалогового окна
        self.__path = path  # начальный каталог с файлами
        self.__exts = exts  # кортеж из отображаемых расширений файлов


class LinuxFileDialog:
    def __init__(self, title, path, exts):
        self.__title = title # заголовок диалогового окна
        self.__path = path  # начальный каталог с файлами
        self.__exts = exts  # кортеж из отображаемых расширений файлов


# здесь объявляйте класс FileDialogFactory

class FileDialogFactory:

    def __new__(cls, *args, **kwargs):
        if CURRENT_OS == 'windows':
            return cls.create_windows_filedialog(*args)
        else:
            return cls.create_linux_filedialog(*args)

    @staticmethod
    def create_windows_filedialog(title, path, exts):
        return WindowsFileDialog(title, path, exts)

    @staticmethod
    def create_linux_filedialog(title, path, exts):
        return  LinuxFileDialog(title, path, exts)


# Второй вариант
CURRENT_OS = 'windows'  # 'windows', 'linux'


class WindowsFileDialog:
    def __init__(self, title, path, exts):
        self.__title = title  # заголовок диалогового окна
        self.__path = path  # начальный каталог с файлами
        self.__exts = exts  # кортеж из отображаемых расширений файлов


class LinuxFileDialog:
    def __init__(self, title, path, exts):
        self.__title = title  # заголовок диалогового окна
        self.__path = path  # начальный каталог с файлами
        self.__exts = exts  # кортеж из отображаемых расширений файлов


class FileDialogFactory:
    def __new__(cls, *args, **kwargs):
        dlg_cls = {'windows': WindowsFileDialog, 'linux': LinuxFileDialog}
        return dlg_cls[CURRENT_OS](*args, **kwargs)

    def create_windows_filedialog(self, title, path, exts):
        pass

    def create_linux_filedialog(self, title, path, exts):
        pass


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 4.5 Полиморфизм и абстрактные методы
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. В программе объявлен следующий класс:
#
# class Interface:
#     def set_data(self, data):
#         pass
#
#     def update(self):
#         raise NotImplementedError
#
#     def abstract(self):
#         return self
#
# Какой (или какие) методы в Python можно считать абстрактными?

# - только метод update()


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Выберите все корректные утверждения для полиморфизма.

# - полиморфизм - это возможность через единый интерфейс взаимодействовать с объектами разных типов
# - полиморфизм встроен в Python через механизм ссылок (каждая переменная - это ссылка на данные любого существующего
# в программе типа)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. В программе объявлены два класса:
#
# class Student:
#     def __init__(self, fio, group):
#         self._fio = fio  # ФИО студента (строка)
#         self._group = group # группа (строка)
#         self._lect_marks = []  # оценки за лекции
#         self._house_marks = []  # оценки за домашние задания
#
#     def add_lect_marks(self, mark):
#         self._lect_marks.append(mark)
#
#     def add_house_marks(self, mark):
#         self._house_marks.append(mark)
#
#     def __str__(self):
#         return f"Студент {self._fio}: оценки на лекциях: {str(self._lect_marks)}; оценки
#         за д/з: {str(self._house_marks)}"
#
#
# class Mentor:
#     def __init__(self, fio, subject):
#         self._fio = fio
#         self._subject = subject
# Первый класс описывает студентов, а второй - менторов. Вам поручается на основе базового класса Mentor разработать
# еще два дочерних класса:
#
# Lector - для описания лекторов;
# Reviewer - для описания экспертов.
#
# Объекты этих классов должны создаваться командами:
#
# lector = Lector(fio, subject)
# reviewer = Reviewer(fio, subject)
# где fio - ФИО (строка); subject - предмет (строка). Инициализации этих параметров (fio, subject) должна выполняться
# базовым классом Mentor.
#
# В самих классах Lector и Reviewer необходимо объявить метод:
#
# def set_mark(self, student, mark): ...
# для простановки оценки (mark) студенту (student). Причем, в классе Lector оценки добавляются в список _lect_marks
# объекта класса Student, а в классе Reviewer - в список _house_marks. Используйте для этого методы add_lect_marks() и
# add_house_marks() класса Student.
#
# Также в классах Lector и Reviewer должен быть переопределен магический метод:
#
# __str__()
# для формирования следующей информации об объектах:
#
# - для объектов класса Lector: Лектор <ФИО>: предмет <предмет>
# - для объектов класса Reviewer: Эксперт <ФИО>: предмет <предмет>
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# lector = Lector("Балакирев С.М.", "Информатика")
# reviewer = Reviewer("Гейтс Б.", "Информатика")
# students = [Student("Иванов А.Б.", "ЭВМд-11"), Student("Гаврилов С.А.", "ЭВМд-11")]
# persons = [lector, reviewer]
# lector.set_mark(students[0], 4)
# lector.set_mark(students[1], 2)
# reviewer.set_mark(students[0], 5)
# reviewer.set_mark(students[1], 3)
# for p in persons + students:
#     print(p)
# # в консоли будет отображено:
# # Лектор Балакирев С.М.: предмет Информатика
# # Эксперт Гейтс Б.: предмет Информатика
# # Студент Иванов А.Б.: оценки на лекциях: [4]; оценки за д/з: [5]
# # Студент Гаврилов С.А.: оценки на лекциях: [2]; оценки за д/з: [3]

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.
# P.P.S. Подумайте, где в этой программе полиморфизм.


class Student:
    def __init__(self, fio, group):
        self._fio = fio
        self._group = group
        self._lect_marks = []  # оценки за лекции
        self._house_marks = []  # оценки за домашние задания

    def add_lect_marks(self, mark):
        self._lect_marks.append(mark)

    def add_house_marks(self, mark):
        self._house_marks.append(mark)

    def __str__(self):
        return f"Студент {self._fio}: оценки на лекциях: {str(self._lect_marks)}; оценки за д/з: {str(self._house_marks)}"


class Mentor:
    def __init__(self, fio, subject):
        self._fio = fio
        self._subject = subject


# здесь продолжайте программу

class Lector(Mentor):

    def __init__(self, fio, subject):
        super().__init__(fio, subject)

    def set_mark(self, student, mark):
        student.add_lect_marks(mark)

    def __str__(self):
        return f'Лектор {self._fio}: предмет {self._subject}'


class Reviewer(Mentor):

    def __init__(self, fio, subject):
        super().__init__(fio, subject)

    def set_mark(self, student, mark):
        student.add_house_marks(mark)

    def __str__(self):
        return f'Эксперт {self._fio}: предмет {self._subject}'


# Второй пример
class Student:
    def __init__(self, fio, group):
        self._fio = fio
        self._group = group
        self._lect_marks = []  # оценки за лекции
        self._house_marks = []  # оценки за домашние задания

    def add_lect_marks(self, mark):
        self._lect_marks.append(mark)

    def add_house_marks(self, mark):
        self._house_marks.append(mark)

    def __str__(self):
        return f"Студент {self._fio}: оценки на лекциях: {str(self._lect_marks)}; оценки за д/з: {str(self._house_marks)}"


class Mentor:
    def __init__(self, fio, subject):
        self._fio = fio
        self._subject = subject

    def __str__(self):
        return f'{self._fio}: предмет {self._subject}'

    def set_mark(self, student, mark):
        raise NotImplementedError()


class Lector(Mentor):
    __init__ = Mentor.__init__
    __str__ = lambda self: 'Лектор ' + super().__str__()

    def set_mark(self, student, mark):
        student.add_lect_marks(mark)


class Reviewer(Mentor):
    __init__ = Mentor.__init__
    __str__ = lambda self: 'Эксперт ' + super().__str__()

    def set_mark(self, student, mark):
        student.add_house_marks(mark)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Вам необходимо объявить базовый класс ShopInterface с абстрактным методом:
#
# def get_id(self): ...
# В самом методе должно генерироваться исключение командой:
#
# raise NotImplementedError('в классе не переопределен метод get_id')
# Инициализатор в классе ShopInterface прописывать не нужно.
#
# Далее объявите дочерний класс ShopItem (от базового класса ShopInterface), объекты которого создаются командой:
#
# item = ShopItem(name, weight, price)
# где name - название товара (строка); weight - вес товара (любое положительное число); price - цена товара (любое
# положительное число).
#
# В каждом объекте класса ShopItem должны формироваться локальные атрибуты с именами _name, _weight, _price и
# соответствующими значениями. Также в объектах класса ShopItem должен автоматически формироваться локальный приватный
# атрибут __id с уникальным (для каждого товара) целым значением.
#
# В классе ShopItem необходимо переопределить метод get_id() базового класса так, чтобы он (метод) возвращал значение
# атрибута __id.
#
# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


class ShopInterface:

    def get_id(self):
        raise NotImplementedError('в классе не переопределен метод get_id')


class ShopItem(ShopInterface):

    __ID = 0

    def __init__(self, name, weight, price):
        self.__id = ShopItem.__ID
        ShopItem.__ID += 1
        self._name = name
        self._weight = weight
        self._price = price

    def get_id(self):
        return self.__id



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Ранее вы уже создавали классы валидации в виде иерархии базового класса Validator и дочерних:
#
# StringValidator
# IntegerValidator
# FloatValidator
#
# для валидации (проверки) корректности данных. Повторим этот функционал с некоторыми изменениями.
#
# Итак, вначале нужно объявить базовый класс Validator, в котором должен отсутствовать инициализатор (магический
# метод __init__) и объявлен метод со следующей сигнатурой:
#
# def _is_valid(self, data): ...
#
# По идее, этот метод возвращает булево значение True, если данные (data) корректны с точки зрения валидатора, и
# False - в противном случае. Но в базовом классе Validator он должен генерировать исключение командой:
#
# raise NotImplementedError('в классе не переопределен метод _is_valid')
# Затем, нужно объявить дочерний класс FloatValidator для валидации вещественных чисел. Объекты этого класса создаются
# командой:
#
# float_validator = FloatValidator(min_value, max_value)
# где min_value - минимально допустимое значение; max_value - максимально допустимое значение.
#
# Пользоваться объектами класса FloatValidator предполагается следующим образом:
#
# res = float_validator(value)
# где value - проверяемое значение (должно быть вещественным и находиться в диапазоне [min_value; max_value]). Данный
# валидатор должен возвращать True, если значение value проходит проверку, и False - в противном случае.
#
# Пример использования классов (эти строчки писать не нужно):
#
# float_validator = FloatValidator(0, 10.5)
# res_1 = float_validator(1)  # False (целое число, а не вещественное)
# res_2 = float_validator(1.0)  # True
# res_3 = float_validator(-1.0)  # False (выход за диапазон [0; 10.5])

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


class Validator:

    def _is_valid(self, data):
        raise NotImplementedError('в классе не переопределен метод _is_valid')

    def __call__(self, data):
        return self._is_valid(data)


class FloatValidator(Validator):

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def _is_valid(self, data):
        return isinstance(data, float) and self.min_value <= data <= self.max_value



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6 (про модуль abc). В языке Python есть еще один распространенный способ объявления абстрактных методов класса
# через декоратор abstractmethod модуля abc:
#
# from abc import ABC, abstractmethod
# Чтобы корректно работал декоратор abstractmethod сам класс должен наследоваться от базового класса ABC. Например, так:
#
# class Transport(ABC):
#     @abstractmethod
#     def go(self):
#         """Метод для перемещения транспортного средства"""
#
#     @classmethod
#     @abstractmethod
#     def abstract_class_method(cls):
#         """Абстрактный метод класса"""
# Мы здесь имеем два абстрактных метода внутри класса Transport, причем, первый метод go() - это обычный метод, а
# второй abstract_class_method() - это абстрактный метод уровня класса. Обратите внимание на порядок использования
# декораторов classmethod и abstractmethod. Они должны быть записаны именно в такой последовательности.
#
# Теперь, если объявить какой-либо дочерний класс, например:
#
# class Bus(Transport):
#     def __init__(self, model, speed):
#         self._model = model
#         self._speed = speed
#
#     def go(self):
#         print("bus go")
#
#     @classmethod
#     def abstract_class_method(cls):
#         pass
# То в нем обязательно нужно переопределить абстрактные методы go и abstract_class_method класса Transport. Иначе,
# объект класса Bus не будет создан (возникнет исключение TypeError).
#
# Используя эту информацию, объявите базовый класс Model (модель), в котором нужно объявить один абстрактный метод с
# сигнатурой:
#
# def get_pk(self): ...
#
# и один обычный метод:
#
# def get_info(self): ...
#
# который бы возвращал строку "Базовый класс Model".
#
# На основе класса Model объявите дочерний класс ModelForm, объекты которого создаются командой:
#
# form = ModelForm(login, password)
# где login - заголовок перед полем ввода логина (строка); password - заголовок перед полем ввода пароля (строка). В
# каждом объекте класса ModelForm должны формироваться локальные атрибуты с именами _login и _password, а также
# автоматически появляться локальный атрибут _id с уникальным целочисленным значением для каждого объекта класса
# ModelForm.
#
# В классе ModelForm переопределите метод:
#
# def get_pk(self): ...
#
# который должен возвращать значение атрибута _id.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# form = ModelForm("Логин", "Пароль")
# print(form.get_pk())

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


from abc import ABC, abstractmethod

# здесь объявляйте классы

class Model(ABC):

    @abstractmethod
    def get_pk(self):
        pass

    def get_info(self):
        return 'Базовый класс Model'


class ModelForm(Model):
    __ID = 0

    def __init__(self, login, password):
        self._login = login
        self._password = password
        self._id = ModelForm.__ID
        ModelForm.__ID += 1

    def get_pk(self):
        return self._id


# Второй вариант
from itertools import count
from abc import ABC, abstractmethod


class Model(ABC):
    _autoincrement = count()

    @abstractmethod
    def get_pk(self):
        '''Get primary key'''

    def get_info(self):
        return 'Базовый класс Model'


class ModelForm(Model):
    def __init__(self, login, password):
        self._id = next(self._autoincrement)
        self._login = login
        self._password = password

    def get_pk(self):
        return self._id



# ----------------------------------------------------------------------------------------------------------------------
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 7. Используя информацию о модуле abc из предыдущего подвига 6, объявите базовый класс с именем StackInterface
# со следующими абстрактными методами:
#
# def push_back(self, obj) - добавление объекта в конец стека;
# def pop_back(self) - удаление последнего объекта из стека.


# На основе этого класса объявите дочерний класс с именем Stack. Объекты этого класса должны создаваться командой:
#
# st = Stack()
# и в каждом объекте этого класса должен формироваться локальный атрибут:
#
# _top - ссылка на первый объект стека (для пустого стека _top = None).
#
# В самом классе Stack переопределить абстрактные методы базового класса:
#
# def push_back(self, obj) - добавление объекта в конец стека;
# def pop_back(self) - удаление последнего объекта из стека.
#
# Сами объекты стека должны определяться классом StackObj и создаваться командой:
#
# obj = StackObj(data)
# где data - информация, хранящаяся в объекте (строка). В каждом объекте класса StackObj должны автоматически
# формироваться атрибуты:
#
# _data - информация, хранящаяся в объекте (строка);
# _next - ссылка на следующий объект стека (если следующий отсутствует, то _next = None).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# st = Stack()
# st.push_back(StackObj("obj 1"))
# obj = StackObj("obj 2")
# st.push_back(obj)
# del_obj = st.pop_back() # del_obj - ссылка на удаленный объект (если объектов не было, то del_obj = None)

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


from abc import ABC, abstractmethod

# здесь объявляйте классы

class StackInterface(ABC):

    @abstractmethod
    def push_back(self, obj):
        pass

    @abstractmethod
    def pop_back(self):
        pass


class Stack(StackInterface):

    def __init__(self):
        self._top = None

    def push_back(self, obj):
        if self._top is None:
            self._top = obj
            return

        x = self._top
        while x._next is not None:
            x = x._next
        x._next = obj

    def pop_back(self):
        if self._top is None:
            return None

        x = self._top
        if x._next is None:
            res = self._top
            self._top = None
            return res

        y = x._next
        while y._next is not None:
            x = x._next
            y = y._next
        res = x._next
        x._next = None
        return res


class StackObj:

    def __init__(self, data):
        self._data = data
        self._next = None


# Второй вариант
from abc import ABC, abstractmethod


class StackObj:
    def __init__(self, data: str):
        self._data = data
        self._next = None

    @property
    def next(self):
        return self._next

    @next.setter
    def next(self, value):
        self._next = value


class StackInterface(ABC):

    @abstractmethod
    def push_back(self, obj):
        pass

    @abstractmethod
    def pop_back(self):
        pass


class Stack(StackInterface):
    def __init__(self):
        self._top = None

    def __iter__(self):
        h = self._top
        while h:
            yield h
            h = h.next

    def push_back(self, obj: StackObj):
        if not self._top:
            self._top = obj
            return
        *_, last = self
        last.next = obj

    def pop_back(self):
        if not self._top:
            return None
        if not self._top.next:
            obj = self._top
            self._top = None
            return obj
        *_, p_last, last = self
        p_last.next = None
        return last



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. С помощью модуля abc можно определять не только абстрактные методы, но и абстрактные
# объекты-свойства (property). Делается это следующим образом:
#
# from abc import ABC, abstractmethod
#
#
# class Transport(ABC):
#     @abstractmethod
#     def go(self):
#         """Метод для перемещения транспортного средства"""
#
#     @property
#     @abstractmethod
#     def speed(self):
#         """Абстрактный объект-свойство"""
# Используя эту информацию и информацию о модуле abc из подвига 6, объявите базовый класс с именем CountryInterface со
# следующими абстрактными методами и свойствами:
#
# name - абстрактное свойство (property), название страны (строка);
# population - абстрактное свойство (property), численность населения (целое положительное число);
# square - абстрактное свойство (property), площадь страны (положительное число);
#
# get_info() - абстрактный метод для получения сводной информации о стране.
#
# На основе класса CountryInterface объявите дочерний класс Country, объекты которого создаются командой:
#
# country = Country(name, population, square)
# В самом классе Country должны быть переопределены следующие свойства и методы базового класса:
#
# name - свойство (property) для считывания названия страны (строка);
# population - свойство (property) для записи и считывания численности населения (целое положительное число);
# square - свойство (property) для записи и считывания площади страны (положительное число);
#
# get_info() - метод для получения сводной информации о стране в виде строки:
#
# "<название>: <площадь>, <численность населения>"
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# country = Country("Россия", 140000000, 324005489.55)
# name = country.name
# pop = country.population
# country.population = 150000000
# country.square = 354005483.0
# print(country.get_info()) # Россия: 354005483.0, 150000000

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


from abc import ABC, abstractmethod

# здесь объявляйте классы
class CountryInterface(ABC):

    @property
    @abstractmethod
    def name(self):
        '''Get name of country'''

    @property
    @abstractmethod
    def population(self):
        '''Get country population'''

    @population.setter
    @abstractmethod
    def population(self, population):
        '''Set country popultion'''

    @property
    @abstractmethod
    def square(self):
        '''Get land area of the country'''

    @square.setter
    @abstractmethod
    def square(self, square):
        '''Set land area of the country'''

    @abstractmethod
    def get_info(self):
        '''Get country information'''


class Country(CountryInterface):

    def __init__(self, name, population, square):
        self._name = name
        self.population = population
        self.square = square

    @property
    def name(self):
        return self._name

    @property
    def population(self):
        return self._population

    @population.setter
    def population(self, population):
        self._population = population

    @property
    def square(self):
        return self._square

    @square.setter
    def square(self, square):
        self._square = square

    def get_info(self):
        return f'{self.name}: {self.square}, {self.population}'



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (на повторение). Вам поручают разработать класс для представления маршрутов в навигаторе. Для этого
# требуется объявить класс с именем Track, объекты которого могут создаваться командами:
#
# tr = Track(start_x, start_y)
# tr = Track(pt1, pt2, ..., ptN)
# где start_x, start_y - начальная координата маршрута (произвольные числа); pt1, pt2, ..., ptN - набор из
# произвольного числа точек (координат) маршрута (объекты класса PointTrack).
#
# При передаче аргументов (start_x, start_y) координата должна представляться первым объектом класса PointTrack. Наборы
# всех точек (объектов PointTrack) должны сохраняться в локальном приватном атрибуте объекта класса Track:
#
# __points - список из точек (координат) маршрута.
#
# Далее, каждая точка (координата) должна определяться классом PointTrack, объекты которого создаются командой:
#
# pt = PointTrack(x, y)
# где x, y - числа (целые или вещественные). Если передается другой тип данных, то должно генерироваться исключение
# командой:
#
# raise TypeError('координаты должны быть числами')
# В классе PointTrack переопределите магический метод __str__, чтобы информация об объекте класса возвращалась в виде
# строки:
#
# "PointTrack: <x>, <y>"
#
# Например:
#
# pt = PointTrack(1, 2)
# print(pt) # PointTrack: 1, 2
# В самом классе Track должно быть свойство (property) с именем:
#
# points - для получения кортежа из точек маршрута.
#
# Также в классе Track должны быть методы:
#
# def add_back(self, pt) - добавление новой точки в конец маршрута (pt - объект класса PointTrack);
# def add_front(self, pt) - добавление новой точки в начало маршрута (pt - объект класса PointTrack);
# def pop_back(self) - удаление последней точки из маршрута;
# def pop_front(self) - удаление первой точки из маршрута.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# tr = Track(PointTrack(0, 0), PointTrack(1.2, -0.5), PointTrack(2.4, -1.5))
# tr.add_back(PointTrack(1.4, 0))
# tr.pop_front()
# for pt in tr.points:
#     print(pt)

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


class Track:

    def __init__(self, *args):
        self.__points = []
        if len(args) == 2 and not isinstance(args[0], PointTrack) and not isinstance(args[1], PointTrack):
            self.__points.append(PointTrack(args[0], args[1]))
        else:
            self.__points.extend(args)

    @property
    def points(self):
        return tuple(self.__points)

    def add_back(self, pt):
        self.__points.append(pt)
        return

    def add_front(self, pt):
        self.__points.insert(0, pt)
        return

    def pop_back(self):
        del self.__points[-1]
        return

    def pop_front(self):
        del self.__points[0]
        return


class PointTrack:

    def __init__(self, x, y):
        self.is_valid(x)
        self.x = x
        self.is_valid(y)
        self.y = y

    def is_valid(self, x):
        if type(x) not in (int, float):
            raise TypeError('координаты должны быть числами')
        return True

    def __str__(self):
        return f'PointTrack: {self.x}, {self.y}'



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение, релакс). Объявите класс с именем Food (еда), объекты которого создаются командой:
#
# food = Food(name, weight, calories)
# где name - название продукта (строка); weight - вес продукта (любое положительное число); calories - калорийная
# ценность продукта (целое положительное число).
#
# Объявите следующие дочерние классы с именами:
#
# BreadFood - хлеб;
# SoupFood - суп;
# FishFood - рыба.
#
# Объекты этих классов должны создаваться командами:
#
# bf = BreadFood(name, weight, calories, white) # white - True для белого хлеба, False - для остальных
# sf = SoupFood(name, weight, calories, dietary) # dietary - True для диетического супа, False - для других видов
# ff = FishFood(name, weight, calories, fish) # fish - вид рыбы (семга, окунь, сардина и т.д.)
# В каждом объекте этих дочерних классов должны формироваться соответствующие локальные атрибуты с именами:
#
# BreadFood: _name, _weight, _calories, _white
# SoupFood: _name, _weight, _calories, _dietary
# FishFood: _name, _weight, _calories, _fish
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# bf = BreadFood("Бородинский хлеб", 34.5, 512, False)
# sf = SoupFood("Черепаший суп", 520, 890.5, False)
# ff = FishFood("Консерва рыбная", 340, 1200, "семга")

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


class Food:

    def __init__(self, name, weight, calories):
        self._name = name
        self._weight = weight
        self._calories = calories


class BreadFood(Food):

    def __init__(self, name, weight, calories, white):
        super().__init__(name, weight, calories)
        self._white = white


class SoupFood(Food):

    def __init__(self, name, weight, calories, dietary):
        super().__init__(name, weight, calories)
        self._dietary = dietary


class FishFood(Food):

    def __init__(self, name, weight, calories, fish):
        super().__init__(name, weight, calories)
        self._fish = fish



# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 4.6 Множественное наследование
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что называется множественным наследованием?

# - это когда один дочерний класс непосредственно наследуется от нескольких базовых


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Имеется следующая программа, в которой объявлены три класса:
#
# class A:
#     def __init__(self):
#         print("A")
#         super().__init__()
#
#
# class B:
#     def __init__(self):
#         print("B")
#         super().__init__()
#
#
# class C(A, B):
#     def __init__(self):
#         print("C")
#         super().__init__()
# И создается экземпляр класса C:
#
# c = C()

# В какой последовательности будут выведены буквы A, B, C в консоль (то есть, в какой последовательности будут вызваны
# инициализаторы этих классов):


# - C A B



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. В программе объявлены три класса следующим образом:
#
# class A:
#     def __init__(self, name, old):
#         super().__init__()
#         self.name = name
#         self.old = old
#
#
# class B:
#     def __init__(self, *args, **kwargs):
#         super().__init__(*args, **kwargs)
#
#
# class C(B, A):
#     def __init__(self, name, old, weight, height):
#         super().__init__(name, old)
#         self.weight = weight
#         self.height = height
# И создается объект класса C:
#
# person = C("Balakirev", 33, 80, 185)

# Выберите все верные утверждения, связанные с этой программой.


# - программа выполнится успешно, будет создан объект person с набором указанных локальных атрибутов
# - программа будет успешно выполняться вне зависимости от порядка наследования классов A и B в дочернем классе C



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. С помощью множественного наследования удобно описывать принадлежность объектов к нескольким разным
# группам. Выполним такой пример.


# Определите в программе классы в соответствии с их иерархией, представленной на рисунке выше:
#
# Digit, Integer, Float, Positive, Negative
#
# Каждый объект этих классов должен создаваться однотипной командой вида:
#
# obj = Имя_класса(value)
# где value - числовое значение. В каждом классе следует делать свою проверку на корректность значения value:
#
# - в классе Digit: value - любое число;
# - в классе Integer: value - целое число;
# - в классе Float: value - вещественное число;
# - в классе Positive: value - положительное число;
# - в классе Negative: value - отрицательное число.
#
# Если проверка не проходит, то генерируется исключение командой:
#
# raise TypeError('значение не соответствует типу объекта')
# После этого объявите следующие дочерние классы:
#
# PrimeNumber - простые числа; наследуется от классов Integer и Positive;
# FloatPositive - наследуется от классов Float и Positive.
#
# Создайте три объекта класса PrimeNumber и пять объектов класса FloatPositive с произвольными допустимыми для них
# значениями. Сохраните все эти объекты в виде списка digits.
#
# Затем, используя функции isinstance() и filter(), сформируйте следующие списки из указанных объектов:
#
# lst_positive - все объекты, относящиеся к классу Positive;
# lst_float - все объекты, относящиеся к классу Float.
#
# P.S. В программе требуется объявить только классы и создать списки. На экран выводить ничего не нужно.


import random


class Digit:

    def __init__(self, val):
        if type(val) not in (int, float):
            raise TypeError('значение не соответствует типу объекта')
        self.val = val


class Integer(Digit):

    def __init__(self, val):
        super().__init__(val)
        if type(self.val) != int:
            raise TypeError('значение не соответствует типу объекта')


class Float(Digit):

    def __init__(self, val):
        super().__init__(val)
        if type(self.val) != float:
            raise TypeError('значение не соответствует типу объекта')


class Positive(Digit):

    def __init__(self, val):
        super().__init__(val)
        if self.val < 0:
            raise TypeError('значение не соответствует типу объекта')


class Negative(Digit):

    def __init__(self, val):
        super().__init__(val)
        if self.val >= 0:
            raise TypeError('значение не соответствует типу объекта')


class PrimeNumber(Integer, Positive):

    def __init__(self, val):
        super().__init__(val)


class FloatPositive(Float, Positive):

    def __init__(self, val):
        super().__init__(val)


digits = [*[PrimeNumber(i) for i in range(3)], *[FloatPositive(random.uniform(1, 5)) for i in range(5)]]

lst_positive = filter(lambda x: isinstance(x, Positive), digits)
lst_float = filter(lambda x: isinstance(x, Float), digits)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. В программе объявлены два класса:
#
# class ShopItem:
#     ID_SHOP_ITEM = 0
#
#     def __init__(self):
#         super().__init__()
#         ShopItem.ID_SHOP_ITEM += 1
#         self._id = ShopItem.ID_SHOP_ITEM
#
#     def get_pk(self):
#         return self._id
#
#
# class Book(ShopItem):
#     def __init__(self, title, author, year):
#         super().__init__()
#         self._title = title
#         self._author = author
#         self._year = year
# Затем, создается объект класса Book (книга) и отображается в консоль:
#
# book = Book("Python ООП", "Балакирев", 2022)
# print(book)
# В результате, на экране увидим что то вроде:
#
# <__main__.Book object at 0x0000015FBA4B3D00>
#
# Но нам требуется, чтобы здесь отображались локальные атрибуты объекта с их значениями в формате:
#
# <атрибут_1>: <значение_1>
# <атрибут_2>: <значение_2>
# ...
# <атрибут_N>: <значение_N>
#
# Для этого вам дают задание разработать два класса:
#
# ShopGenericView - для отображения всех локальных атрибутов объектов любых дочерних классов (не только Book);
# ShopUserView - для отображения всех локальных атрибутов, кроме атрибута _id, объектов любых дочерних классов (не
# только Book).
#
# То есть, в этих классах нужно переопределить два магических метода: __str__() и __repr__().
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# class Book(ShopItem, ShopGenericView): ...
# book = Book("Python ООП", "Балакирев", 2022)
# print(book)
# # на экране увидим строчки:
# # _id: 1
# # _title: Python ООП
# # _author: Балакирев
# # _year: 2022
# Другой вариант использования классов:
#
# class Book(ShopItem, ShopUserView): ...
# book = Book("Python ООП", "Балакирев", 2022)
# print(book)
# # на экране увидим строчки:
# # _title: Python ООП
# # _author: Балакирев
# # _year: 2022
# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


class ShopItem:
    ID_SHOP_ITEM = 0

    def __init__(self):
        super().__init__()
        ShopItem.ID_SHOP_ITEM += 1
        self._id = ShopItem.ID_SHOP_ITEM

    def get_pk(self):
        return self._id


# здесь объявляйте классы ShopGenericView и ShopUserView
class ShopGenericView:

    def __str__(self):
        res = list(f'{i[0]}: {i[1]}' for i in list(self.__dict__.items()))
        return '\n'.join(res)


class ShopUserView:

    def __str__(self):
        res = list(f'{i[0]}: {i[1]}' for i in list(self.__dict__.items()) if i[0] != '_id')
        return '\n'.join(res)


class Book(ShopItem):
    def __init__(self, title, author, year):
        super().__init__()
        self._title = title
        self._author = author
        self._year = year



# Второй вариант
class ShopItem:
    ID_SHOP_ITEM = 0

    def __init__(self):
        super().__init__()
        ShopItem.ID_SHOP_ITEM += 1
        self._id = ShopItem.ID_SHOP_ITEM

    def get_pk(self):
        return self._id


# здесь объявляйте классы ShopGenericView и ShopUserView
class ShopGenericView:
    Exclude = tuple()
    def __str__(self):
        return '\n'.join('{0}: {1}'.format(attr, v) for attr, v in self.__dict__.items() if attr not in self.Exclude)

    def __repr__(self):
        return self.__str__()

class ShopUserView(ShopGenericView):
    Exclude = ('_id', )

class Book(ShopItem):
    def __init__(self, title, author, year):
        super().__init__()
        self._title = title
        self._author = author
        self._year = year



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Вам доверили разработать набор классов для описания рецептов различных блюд. И подсказали, что вначале
# нужно объявить отдельные классы для разных продуктов питания, например:
#
# class Meat:
#     """Класс для описания мяса"""
#
#
# class Fish:
#     """Класс для описания рыбы"""
#
#
# class Potatoes:
#     """Класс для описания картофеля"""
# И так далее. Затем, вам в голову приходит два варианта использования этих классов для описания конкретных рецептов
# блюд:
#
# 1-й вариант. Использовать классы продуктов в качестве базовых. Например:
#
# class MeatPuree(Meat, Potatoes):
#     """Рецепт мясного пюре"""
#
#
# class BakedFish(Fish, Potatoes):
#     """Рецепт запеченой рыбы"""
# И так далее.
#
# 2-й вариант. Использовать объекты классов продуктов в качестве значений локальных атрибутов. Например:
#
# class MeatPuree:
#     def __init__(self, meat, potatoes):
#         self.__meat = meat
#         self.__potatoes = potatoes
# где
#
# meat = Meat()
# potatoes = Potatoes()
# И так для всех классов рецептов.
#
# Какой из этих вариантов предпочтительнее использовать на практике и почему?


# - Лучше 2-й вариант, так как он более универсален, проще масштабируется, а большое количество базовых классов делает
# программу сложной для понимания.
# - Лучше 2-й вариант, так как здесь класс MeatPuree можно организовать для самых разных рецептов мясного
# пюре (с разными ингредиентами, а не только теми, что будут указаны в качестве базовых классов).



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. Вам снова доверили разработку набора классов, но теперь для учета различных животных. И несколько
# начальных классов уже написали:
#
# class Animal:
#     """Класс для описания животного"""
#
#
# class Feet:
#     """Класс для описания ног"""
#
#
# class Wings:
#     """Класс для описания крыльев"""
#
#
# class Mouth:
#     """Класс для описания рта"""
#
#
# class Beak:
#     """Класс для описания клюва"""
# Далее, при описании классов конкретных видов животных, эти начальные классы можно использовать несколькими способами:
#
# 1-й вариант. Использовать начальные классы в качестве базовых. Например:
#
# class Monkey(Animal, Feet, Mouth):
#     """Класс для описания обезьян"""
#
#
# class Colibri(Animal, Wings, Beak):
#     """Класс для описания колибри"""
# И так для всех видов животных.
#
# 2-й вариант. Использовать объекты этих классов в качестве значений атрибутов. Например:
#
# class Monkey(Animal):
#     def __init__(self, feet, mouth):
#         self.__feet = feet
#         self.__mouth = mouth
# где
#
# feet = Feet()
# mouth = Mouth()
# Какой из этих вариантов предпочтительнее использовать на практике и почему?


# - 1-й вариант вполне допустим, так как объекты базовых классов являются неотъемлемой частью конкретных видов животных
# и других вариаций быть не может.
# - 2-й вариант вполне допустим, так как в инициализаторе создается необходимый набор локальных атрибутов для каждого
# конкретного вида животного.



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/yXPFcDe6jco
#
# Подвиг 8 (введение в паттерн миксинов - mixins). Часто множественное наследование используют для наполнения дочернего
# класса определенным функционалом. То есть, с указанием каждого нового базового класса, дочерний класс приобретает все
# больше и больше возможностей. И, наоборот, убирая часть базовых классов, дочерний класс теряет соответствующую часть
# функционала.
#
# Например, паттерн миксинов активно используют в популярном фреймворке Django.  В частности, когда нужно указать
# дочернему классу, какие запросы от клиента он должен обрабатывать (запросы типа GET, POST, PUT, DELETE и т.п.). В
# качестве примера реализуем эту идею в очень упрощенном виде, но сохраняя суть паттерна миксинов.
#
# Предположим, что в программе уже существует следующий набор классов:
#
# class RetriveMixin:
#     def get(self, request):
#         return "GET: " + request.get('url')
#
#
# class CreateMixin:
#     def post(self, request):
#         return "POST: " + request.get('url')
#
#
# class UpdateMixin:
#     def put(self, request):
#         return "PUT: " + request.get('url')
# Здесь в каждом классе выполняется имитация обработки запросов. За GET-запрос отвечает метод get() класса
# RetriveMixin, за POST-запрос - метод post() класса CreateMixin, за PUT-запрос - метод put() класса UpdateMixin.
#
# Далее, вам нужно объявить класс с именем GeneralView, в котором следует указать атрибут (на уровне класса):
#
# allowed_methods = ('GET', 'POST', 'PUT', 'DELETE')
# для перечня разрешенных запросов. А также объявить метод render_request со следующей сигнатурой:
#
# def render_request(self, request): ...
#
# Здесь request - это словарь (объект запроса), в котором обязательно должны быть два ключа:
#
# 'url' - адрес для обработки запроса;
# 'method' - метод запроса: 'GET', 'POST', 'PUT', 'DELETE' и т. д.
#
# В методе render_request() нужно сначала проверить, является ли указанный запрос в словаре request
# разрешенным (присутствует в списке allowed_methods). И если это не так, то генерировать исключение командой:
#
# raise TypeError(f"Метод {request.get('method')} не разрешен.")
# Иначе, вызвать метод по его имени:
#
# method_request = request.get('method').lower()  # имя метода, малыми буквами
# Подсказка: чтобы получить ссылку на метод с именем method_request, воспользуйтесь магическим
# методом __getattribute__().
#
# Для использования полученных классов, в программе объявляется следующий дочерний класс:
#
# class DetailView(RetriveMixin, GeneralView):
#     allowed_methods = ('GET', 'PUT', )
# Воспользоваться им можно, например, следующим образом (эти строчки в программе не писать):
#
# view = DetailView()
# html = view.render_request({'url': 'https://stepik.org/course/116336/', 'method': 'GET'})
# print(html)   # GET: https://stepik.org/course/116336/
# Если в запросе указать другой метод:
#
# html = view.render_request({'url': 'https://stepik.org/course/116336/', 'method': 'PUT'})
# то естественным образом возникнет исключение (реализовывать в программе не нужно, это уже встроено в сам язык
# Python):
#
# AttributeError: 'DetailView' object has no attribute 'put'
#
# так как дочерний класс DetailView не имеет метода put. Поправить это можно, если указать соответствующий базовый
# класс:
#
# class DetailView(RetriveMixin, UpdateMixin, GeneralView):
#     allowed_methods = ('GET', 'PUT', )
# Теперь, при выполнении команд:
#
# view = DetailView()
# html = view.render_request({'url': 'https://stepik.org/course/116336/', 'method': 'PUT'})
# print(html)
# будет выведено:
#
# PUT: https://stepik.org/course/116336/
#
# Это и есть принцип работы паттерна миксинов.
#
# P.S. В программе требуется объявить только класс GeneralView. На экран выводить ничего не нужно.


class RetriveMixin:
    def get(self, request):
        return "GET: " + request.get('url')


class CreateMixin:
    def post(self, request):
        return "POST: " + request.get('url')


class UpdateMixin:
    def put(self, request):
        return "PUT: " + request.get('url')


# здесь объявляйте класс GeneralView
class GeneralView:
    allowed_methods = ('GET', 'POST', 'PUT', 'DELETE')

    def render_request(self, requests: dict):
        method = requests.get('method').upper()
        if method not in self.allowed_methods:
            raise TypeError(f"Метод {requests.get('method')} не разрешен.")
        method_request = self.__getattribute__(method.lower())
        if method_request:
            return method_request(requests)


class DetailView(RetriveMixin, UpdateMixin, GeneralView):
    allowed_methods = ('GET', 'POST', )



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9. Объявите класс с именем Money (деньги), объекты которого создаются командой:
#
# money = Money(value)
# где value - любое число (целое или вещественное). Если указывается не числовое значение, то генерируется исключение
# командой:
#
# raise TypeError('сумма должна быть числом')
# В каждом объекте этого класса должен формироваться локальный атрибут _money с соответствующим значением. Также в
# классе Money должно быть объект-свойство (property):
#
# money - для записи и считывания значения из атрибута _money.
#
# В связке с классом Money работает еще один класс:
#
# class MoneyOperators:
#     def __add__(self, other):
#         if type(other) in (int, float):
#             return self.__class__(self.money + other)
#
#         if type(self) != type(other):
#             raise TypeError('Разные типы объектов')
#
#         return self.__class__(self.money + other.money)
# Он определяет работу арифметических операторов. В данном примере описан алгоритм сложения двух объектов класса
# Money (или объектов его дочерних классов).
#
# Обратите внимание, как реализован метод __add__() в этом классе. Он универсален при работе с любыми объектами класса
# Money или его дочерних классов. Здесь атрибут __class__ - это ссылка на класс объекта self. С помощью __class__ можно
# создавать объекты того же класса, что и self.
#
# Вам необходимо добавить в класс MoneyOperators аналогичную реализацию оператора вычитания.
#
# На основе двух классов (Money и MoneyOperators) предполагается создавать классы кошельков разных валют. Например, так:
#
# class MoneyR(Money, MoneyOperators):
#     def __str__(self):
#         return f"MoneyR: {self.money}"
#
#
# class MoneyD(Money, MoneyOperators):
#     def __str__(self):
#         return f"MoneyD: {self.money}"
# И, затем применять их следующим образом (эти строчки в программе писать не нужно):
#
# m1 = MoneyR(1)
# m2 = MoneyD(2)
# m = m1 + 10
# print(m)  # MoneyR: 11
# m = m1 - 5.4
# m = m1 + m2  # TypeError

# P.S. В программе требуется объявить только классы. На экран выводить ничего не нужно.


class MoneyOperators:
    def __add__(self, other):
        if type(other) in (int, float):
            return self.__class__(self.money + other)

        if type(self) != type(other):
            raise TypeError('Разные типы объектов')

        return self.__class__(self.money + other.money)

    # здесь объявляйте еще один метод
    def __sub__(self, other):
        if type(other) in (int, float):
            return self.__class__(self.money - other)

        if type(self) != type(other):
            raise TypeError('Разные типы объектов')

        return self.__class__(self.money - other.money)


class Money:

    def __init__(self, val):
        self._is_valid(val)
        self._money = val

    def _is_valid(self, val):
        if type(val) not in (int, float):
            raise TypeError('сумма должна быть числом')
        return True

    @property
    def money(self):
        return self._money

    @money.setter
    def money(self, val):
        if self._is_valid(val):
            self._money = val
            return


class MoneyR(Money, MoneyOperators):
    def __str__(self):
        return f"MoneyR: {self.money}"


class MoneyD(Money, MoneyOperators):
    def __str__(self):
        return f"MoneyD: {self.money}"



# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 4.7 Коллекция __slots__
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. На что влияет коллекция __slots__, объявленная внутри класса?

# - скорость обращения к локальным атрибутам повышается
# - уменьшается объем памяти, занимаемый объектом класса
# - разрешает в экземплярах класса только те имена атрибутов, которые указаны в __slots__



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе объявлены два класса следующим образом:
#
# class Money:
#     __slots__ = '_money',
#
#     def __init__(self, value):
#         self._money = value
#
#
# class MoneyR(Money):
#     pass
# И, затем, создается объект класса MoneyR:
#
# m = MoneyR(10)
# m.s = 100
# Выберите все верные утверждения, связанные с этой программой.


# - программа выполнится без ошибок, т.к. коллекция __slots__ отсутствует в классе MoneyR, то в его объектах можно
# создавать любые локальные атрибуты
# - коллекция __slots__ накладывает ограничения на атрибуты объектов базового класса Money, но не дочернего
# класса MoneyR



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. В программе объявлены два класса следующим образом:
#
# class Money:
#     __slots__ = '_money',
#
#     def __init__(self, value):
#         self._money = value
#
#
# class MoneyR(Money):
#     __slots__ = '_value',
# И, затем, выполняются команды:
#
# m = MoneyR(10)
# m._money = 100
# m._value = 20

# Выберите все верные утверждения, связанные с этой программой.


# - программа выполнится без ошибок, так как коллекция __slots__ дочернего класса расширяет коллекцию __slots__ базового
# класса и атрибуты с именами _money и _value допустимы
# - если в классе MoneyR прописать __slots__ = '_value', '_money', а в базовом классе убрать определение __slots__, то
# поведение объекта m дочернего класса MoneyR не изменится



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите класс Person, в объектах которого разрешены только локальные атрибуты с именами (ограничение
# задается через коллекцию __slots__):
#
# _fio - ФИО сотрудника (строка);
# _old - возраст сотрудника (целое положительное число);
# _job - занимаемая должность (строка).
#
# Сами объекты должны создаваться командой:
#
# p = Person(fio, old, job)
# Создайте несколько следующих объектов этого класса с информацией:
#
# Суворов, 52, полководец
# Рахманинов, 50, пианист, композитор
# Балакирев, 34, программист и преподаватель
# Пушкин, 32, поэт и писатель
#
# Сохраните все эти объекты в виде списка с именем persons.
#
# P.S. В программе следует объявить только класс и создать список. На экран выводить ничего не нужно.


class Person:
    __slots__ = ('_fio', '_old', '_job')

    def __init__(self, fio, old, job):
        self._fio = fio
        self._old = old
        self._job = job


persons = [Person('Суворов', 52, 'полководец'),
           Person('Рахманинов', 50, 'пианист, композитор'),
           Person('Балакирев', 34, 'программист и преподаватель'),
           Person('Пушкин', 32, 'поэт и писатель')
           ]



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Объявите класс Planet (планета), объекты которого создаются командой:
#
# p = Planet(name, diametr, period_solar, period)
# где name - наименование планеты; diametr - диаметр планеты (любое положительное число); period_solar - период (время)
# обращения планеты вокруг Солнца (любое положительное число); period - период обращения планеты вокруг своей
# оси (любое положительное число).
#
# В каждом объекте класса Planet должны формироваться локальные атрибуты с именами: _name, _diametr, _period_solar,
# _period и соответствующими значениями.


# Затем, объявите класс с именем SolarSystem (солнечная система). В объектах этого класса должны быть допустимы,
# следующие локальные атрибуты (ограничение задается через коллекцию __slots__):
#
# _mercury - ссылка на планету Меркурий (объект класса Planet);
# _venus - ссылка на планету Венера (объект класса Planet);
# _earth - ссылка на планету Земля (объект класса Planet);
# _mars - ссылка на планету Марс (объект класса Planet);
# _jupiter - ссылка на планету Юпитер (объект класса Planet);
# _saturn - ссылка на планету Сатурн (объект класса Planet);
# _uranus - ссылка на планету Уран (объект класса Planet);
# _neptune - ссылка на планету Нептун (объект класса Planet).
#
# Объект класса SolarSystem должен создаваться командой:
#
# s_system = SolarSystem()
# и быть только один (одновременно в программе два и более объектов класса SolarSystem недопустимо). Используйте для
# этого паттерн Singleton.
#
# В момент создания объекта SolarSystem должны автоматически создаваться перечисленные локальные атрибуты и ссылаться
# на соответствующие объекты класса Planet со следующими данными по планетам:


# Создайте в программе объект s_system класса SolarSystem.
#
# P.S. В программе следует объявить только классы и создать объект s_system. На экран выводить ничего не нужно.


class Planet:

    def __init__(self, name, diametr, period_solar, period):
        self._name = name
        self._diametr = diametr
        self._period_solar = period_solar
        self._period = period


class SolarSystem:
    __slots__ = ('_mercury', '_venus', '_earth', '_mars', '_jupiter', '_saturn', '_uranus', '_neptune')
    __INSTANCE = None

    def __new__(cls, *args, **kwargs):
        if cls.__INSTANCE is None:
            cls.__INSTANCE = super().__new__(cls)

        return cls.__INSTANCE

    def __init__(self):
        self._mercury = Planet('Меркурий', 4878, 87.97, 1407.5)
        self._venus = Planet('Венера', 12104, 224.7, 5832.45)
        self._earth = Planet('Земля', 12756, 365.3, 23.93)
        self._mars = Planet('Марс', 6794, 687, 24.62)
        self._jupiter = Planet('Юпитер', 142800, 4330, 9.9)
        self._saturn = Planet('Сатурн', 120660, 10753, 10.63)
        self._uranus = Planet('Уран', 51118, 30665, 17.2)
        self._neptune = Planet('Нептун', 49528, 60150, 16.1)


s_system = SolarSystem()


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Объявите класс с именем Star (звезда), в объектах которого разрешены только локальные атрибуты с
# именами (ограничение задается через коллекцию __slots__):
#
# _name - название звезды (строка);
# _massa - масса звезды (любое положительное число); часто измеряется в массах Солнца;
# _temp - температура поверхности звезды в Кельвинах (любое положительное число).
#
# Объекты этого класса должны создаваться командой:
#
# star = Star(name, massa, temp)
# На основе класса Star объявите следующие дочерние классы:
#
# WhiteDwarf - белый карлик;
# YellowDwarf - желтый карлик;
# RedGiant - красный гигант;
# Pulsar - пульсар.
#
# В каждом объекте этих классов должны быть разрешены (дополнительно к атрибутам базового класса Star) только
# следующие локальные атрибуты:
#
# _type_star - название типа звезды (строка);
# _radius - радиус звезды (любое положительное число); часто измеряется в радиусах Солнца.
#
# Соответственно, объекты этих классов должны создаваться командой:
#
# star = Имя_дочернего_класса(name, massa, temp, type_star, radius)
# Создайте в программе следующие объекты звезд:
#
# RedGiant: Альдебаран; 5; 3600; красный гигант; 45
# WhiteDwarf: Сириус А; 2,1; 9250; белый карлик; 2
# WhiteDwarf: Сириус B; 1; 8200; белый карлик; 0,01
# YellowDwarf: Солнце; 1; 6000; желтый карлик; 1
#
# Все эти объекты сохраните в виде списка stars. Затем, с помощью функций isinstance() и filter() сформируйте новый
# список с именем white_dwarfs, состоящий только из белых карликов (WhiteDwarf).
#
# P.S. В программе следует объявить только классы и создать списки. На экран выводить ничего не нужно.


class Star:
    __slots__ = ('_name', '_massa', '_temp')

    def __init__(self, name, massa, temp):
        self._name = name
        self._massa = massa
        self._temp = temp


class WhiteDwarf(Star):
    __slots__ = ('_type_star', '_radius')

    def __init__(self, name, massa, temp, type_star, radius):
        super().__init__(name, massa, temp)
        self._type_star = type_star
        self._radius = radius


class YellowDwarf(Star):
    __slots__ = ('_type_star', '_radius')

    def __init__(self, name, massa, temp, type_star, radius):
        super().__init__(name, massa, temp)
        self._type_star = type_star
        self._radius = radius


class RedGiant(Star):
    __slots__ = ('_type_star', '_radius')

    def __init__(self, name, massa, temp, type_star, radius):
        super().__init__(name, massa, temp)
        self._type_star = type_star
        self._radius = radius


class Pulsar(Star):
    __slots__ = ('_type_star', '_radius')

    def __init__(self, name, massa, temp, type_star, radius):
        super().__init__(name, massa, temp)
        self._type_star = type_star
        self._radius = radius


stars = [RedGiant('Альдебаран', 5, 3600, 'красный гигант', 45),
         WhiteDwarf('Сириус А', 2.1, 9250, 'белый карлик', 2),
         WhiteDwarf('Сириус B', 1, 8200, 'белый карлик', 0.01),
         YellowDwarf('Солнце', 1, 6000, 'желтый карлик', 1)]

white_dwarfs = list(filter(lambda x: isinstance(x, WhiteDwarf), stars))



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rtma49Ye7hY
#
# Подвиг 7. Объявите класс Note (нота), объекты которого создаются командой:
#
# note = Note(name, ton)
# где name - название ноты (допустимые значения: до, ре, ми, фа, соль, ля, си); ton - тональность ноты (целое число).
# Тональность (ton) принимает следующие целые значения:
#
# -1 - бемоль (flat);
# 0 - обычная нота (normal);
# 1 - диез (sharp).
#
# Если в названии (name) или тональности (ton) передаются недопустимые значения, то генерируется исключение командой:
#
# raise ValueError('недопустимое значение аргумента')
# В каждом объекте класса Note должны формироваться локальные атрибуты с именами _name и _ton с соответствующими
# значениями.
#
# Объявите класс с именем Notes, в объектах которого разрешены только локальные атрибуты с именами (ограничение
# задается через коллекцию __slots__):
#
# _do - ссылка на ноту до (объект класса Note);
# _re - ссылка на ноту ре (объект класса Note);
# _mi - ссылка на ноту ми (объект класса Note);
# _fa - ссылка на ноту фа (объект класса Note);
# _solt - ссылка на ноту соль (объект класса Note);
# _la - ссылка на ноту ля (объект класса Note);
# _si - ссылка на ноту си (объект класса Note).
#
# Объект класса Notes должен создаваться командой:
#
# notes = Notes()
# и быть только один (одновременно в программе два и более объектов класса Notes недопустимо). Используйте для этого
# паттерн Singleton.
#
# В момент создания объекта Notes должны автоматически создаваться перечисленные локальные атрибуты и ссылаться на
# соответствующие объекты класса Note (тональность (ton) у всех нот изначально равна 0).
#
# Обеспечить возможность обращения к нотам по индексам: 0 - до; 1 - ре; ... ; 6 - си. Например:
#
# nota = notes[2]  # ссылка на ноту ми
# notes[3]._ton = -1 # изменение тональности ноты фа
# Если указывается недопустимый индекс (не целое число, или число, выходящее за интервал [0; 6]), то генерируется
# исключение командой:
#
# raise IndexError('недопустимый индекс')
# Создайте в программе объект notes класса Notes.
#
# P.S. В программе следует объявить только классы и создать объект notes. На экран выводить ничего не нужно.


class Note:
    _available_values = ('до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си')

    def __init__(self, name, ton):
        self._name = name
        self._ton = ton

    def __setattr__(self, key, value):
        if key == '_name' and value not in self._available_values:
            raise ValueError('недопустимое значение аргумента')
        if key == '_ton' and value not in (-1, 0, 1):
            raise ValueError('недопустимое значение аргумента')
        object.__setattr__(self, key, value)


class Notes:
    __slots__ = '_do', '_re', '_mi', '_fa', '_solt', '_la', '_si'
    _available_values = ('до', 'ре', 'ми', 'фа', 'соль', 'ля', 'си')
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __del__(self):
        Notes._instance = None

    def __init__(self):
        for k, v in zip(self.__slots__, self._available_values):
            setattr(self, k, Note(v, 0))

    def __getitem__(self, item):
        if not (0 <= item < 7):
            raise IndexError('недопустимый индекс')
        return getattr(self, self.__slots__[item])


notes = Notes()



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/V1fqV9pfARQ
#
# Подвиг 8 (на повторение). В программе объявлен базовый класс Function (функция) следующим образом:
#
# class Function:
#     def __init__(self):
#         self._amplitude = 1.0     # амплитуда функции
#         self._bias = 0.0          # смещение функции по оси Oy
#
#     def __call__(self, x, *args, **kwargs):
#         return self._amplitude * self._get_function(x) + self._bias
#
#     def _get_function(self, x):
#         raise NotImplementedError('метод _get_function должен быть переопределен в дочернем классе')
#
#     def __add__(self, other):
#         if type(other) not in (int, float):
#             raise TypeError('смещение должно быть числом')
#
#         obj = self.__class__(self)
#         obj._bias = self._bias + other
#         return obj
# Здесь в инициализаторе создаются два локальных атрибута:
#
# _amplitude - амплитуда функции;
# _bias - смещение функции по оси ординат (Oy).
#
# Далее, в методе __call__() берется значение функции в точке x через метод _get_function(), который должен быть
# определен в дочерних классах, умножается на амплитуду функции и добавляется ее смещение. Следующий метод __add__()
# позволяет менять смещение функции, изменяя атрибут _bias на указанное значение other.
#
# Обратите внимание, в методе __add__() происходит создание нового объекта командой:
#
# obj = self.__class__(self)
# Здесь __class__ - это ссылка на класс, к которому относится объект self. Благодаря этому в базовом классе можно
# создавать объекты соответствующих дочерних классов. В момент создания объекта ему передается параметр self как
# аргумент. Так будет создаваться копия объекта, т.е. новый объект с тем же набором и значениями локальных атрибутов.
#
# Чтобы обеспечить этот функционал, объявите дочерний класс с именем Linear (линейная функция y = k*x + b), объекты
# которого должны создаваться командами:
#
# obj = Linear(k, b)
# linear = Linear(obj)  # этот вариант используется в базовом классе в методе __add__()
# В первом случае происходит создание объекта линейной функции с параметрами k и b. Во втором - создание объекта со
# значениями параметров k и b, взятыми из объекта obj.
#
# В каждом объекте класса Linear должны создаваться локальные атрибуты с именами _k и _b с соответствующими значениями.
# В результате будет создан универсальный базовый класс Function для работы с произвольными функциями от одного
# аргумента.
#
# Применять эти классы можно следующим образом (эти строчки в программе писать не нужно):
#
# f = Linear(1, 0.5)
# f2 = f + 10   # изменение смещения (атрибут _bias)
# y1 = f(0)     # 0.5
# y2 = f2(0)    # 10.5
# Пропишите в базовом классе Function еще один магический метод для изменения масштаба (амплитуды) функции, чтобы был
# доступен оператор умножения:
#
# f = Linear(1, 0.5)
# f2 = f * 5    # изменение амплитуды (атрибут _amplitude)
# y1 = f(0)     # 0.5
# y2 = f2(0)    # 2.5
# P.S. В программе следует объявить только классы. На экран выводить ничего не нужно.


class Function:
    def __init__(self):
        self._amplitude = 1.0     # амплитуда функции
        self._bias = 0.0          # смещение функции по оси Oy

    def __call__(self, x, *args, **kwargs):
        return self._amplitude * self._get_function(x) + self._bias

    def _get_function(self, x):
        raise NotImplementedError('метод _get_function должен быть переопределен в дочернем классе')

    def __add__(self, other):
        if type(other) not in (int, float):
            raise TypeError('смещение должно быть числом')

        obj = self.__class__(self)
        obj._bias = self._bias + other
        return obj

    # здесь добавляйте еще один магический метод для умножения
    def __mul__(self, other):
        if type(other) not in (int, float):
            raise TypeError('амплитуда должно быть числом')

        obj = self.__class__(self)
        obj._amplitude *= other
        return obj


# здесь объявляйте класс Linear
class Linear(Function):

    def __init__(self, k=None, b=None):
        super().__init__()
        if type(k) == Linear:
            self._k, self._b = k._k, k._b
        else:
            self._k = k
            self._b = b

    def _get_function(self, x):
        return self._k * x + self._b



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (на повторение). В программе объявлен класс и создается его объект:
#
# class Shop:
#     ID_SHOP_ITEM = 0
#
#
# sp = Shop()
# sp.ID_SHOP_ITEM += 1
# print(Shop.ID_SHOP_ITEM)

# Выберите все верные утверждения, связанные с этой программой.


# - в строчке sp.ID_SHOP_ITEM += 1 создается новая локальная переменная ID_SHOP_ITEM со значением 1
# - на экране будет отображено значение 0



# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 4.8 Испытание "Бремя наследия"
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Испытание "Бремя наследия"
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/M_UctsRbNGA
#
# Всевидящее око начальства увидело, что вы прошли еще одну ступень в постижении глубин ООП языка Python - наследование.
# Вас вновь решили испытать и посмотреть, на что вы действительно способны. Тимлид (Teamleader) с широкой улыбкой
# протянул вам следующее задание.
#
# Техническое задание
# Необходимо написать универсальную основу для представления ненаправленных связных графов и поиска в них кратчайших
# маршрутов. Далее, этот алгоритм предполагается применять для прокладки маршрутов: на картах, в метро и так далее.


# Для универсального описания графов, вам требуется объявить в программе следующие классы:
#
# Vertex - для представления вершин графа (на карте это могут быть: здания, остановки, достопримечательности и т.п.);
# Link - для описания связи между двумя произвольными вершинами графа (на карте: маршруты, время в пути и т.п.);
# LinkedGraph - для представления связного графа в целом (карта целиком).


# Объекты класса Vertex должны создаваться командой:
#
# v = Vertex()
# и содержать локальный атрибут:
#
# _links - список связей с другими вершинами графа (список объектов класса Link).
#
# Также в этом классе должно быть объект-свойство (property):
#
# links - для получения ссылки на список _links.
#
# Объекты следующего класса Link должны создаваться командой:
#
# link = Link(v1, v2)
# где v1, v2 - объекты класса Vertex (вершины графа). Внутри каждого объекта класса Link должны формироваться следующие
# локальные атрибуты:
#
# _v1, _v2 - ссылки на объекты класса Vertex, которые соединяются данной связью;
# _dist - длина связи (по умолчанию 1); это может быть длина пути, время в пути и др.
#
# В классе Link должны быть объявлены следующие объекты-свойства:
#
# v1 - для получения ссылки на вершину v1;
# v2 - для получения ссылки на вершину v2;
# dist - для изменения и считывания значения атрибута _dist.
#
# Наконец, объекты третьего класса LinkedGraph должны создаваться командой:
#
# map_graph = LinkedGraph()
# В каждом объекте класса LinkedGraph должны формироваться локальные атрибуты:
#
# _links - список из всех связей графа (из объектов класса Link);
# _vertex - список из всех вершин графа (из объектов класса Vertex).
#
# В самом классе LinkedGraph необходимо объявить (как минимум) следующие методы:
#
# def add_vertex(self, v): ... - для добавления новой вершины v в список _vertex (если она там отсутствует);
# def add_link(self, link): ... - для добавления новой связи link в список _links (если объект link с указанными
# вершинами в списке отсутствует);
# def find_path(self, start_v, stop_v): ... - для поиска кратчайшего маршрута из вершины start_v в вершину stop_v.
#
# Метод find_path() должен возвращать список из вершин кратчайшего маршрута и список из связей этого же маршрута в виде
# кортежа:
#
# ([вершины кратчайшего пути], [связи между вершинами])
#
# Поиск кратчайшего маршрута допустимо делать полным перебором с помощью рекурсивной функции (будем полагать, что общее
# число вершин в графе не превышает 100). Для тех, кто желает испытать себя в полной мере, можно реализовать алгоритм
# Дейкстры поиска кратчайшего пути в связном взвешенном графе.
#
# В методе add_link() при добавлении новой связи следует автоматически добавлять вершины этой связи в список _vertex,
# если они там отсутствуют.
#
# Проверку наличия связи в списке _links следует определять по вершинам этой связи. Например, если в списке имеется
# объект:
#
# _links = [Link(v1, v2)]
#
# то добавлять в него новые объекты Link(v2, v1) или Link(v1, v2) нельзя (обратите внимание у всех трех объектов будут
# разные id, т.е. по id определять вхождение в список нельзя).
#
# Подсказка: проверку на наличие существующей связи можно выполнить с использованием функции filter() и указанием
# нужного условия для отбора объектов.
#
# Пример использования классов, применительно к схеме метро (эти строчки в программе писать не нужно):
#
# map_graph = LinkedGraph()
#
# v1 = Vertex()
# v2 = Vertex()
# v3 = Vertex()
# v4 = Vertex()
# v5 = Vertex()
# v6 = Vertex()
# v7 = Vertex()
#
# map_graph.add_link(Link(v1, v2))
# map_graph.add_link(Link(v2, v3))
# map_graph.add_link(Link(v1, v3))
#
# map_graph.add_link(Link(v4, v5))
# map_graph.add_link(Link(v6, v7))
#
# map_graph.add_link(Link(v2, v7))
# map_graph.add_link(Link(v3, v4))
# map_graph.add_link(Link(v5, v6))
#
# print(len(map_graph._links))   # 8 связей
# print(len(map_graph._vertex))  # 7 вершин
# path = map_graph.find_path(v1, v6)
# Однако, в таком виде применять классы для схемы карты метро не очень удобно. Например, здесь нет указаний названий
# станций, а также длина каждого сегмента равна 1, что не соответствует действительности.
#
# Чтобы поправить этот момент и реализовать программу поиска кратчайшего пути в метро между двумя произвольными
# станциями, объявите еще два дочерних класса:
#
# class Station(Vertex): ... - для описания станций метро;
# class LinkMetro(Link): ... - для описания связей между станциями метро.
#
# Объекты класса Station должны создаваться командой:
#
# st = Station(name)
# где name - название станции (строка). В каждом объекте класса Station должен дополнительно формироваться локальный
# атрибут:
#
# name - название станции метро.
#
# (Не забудьте в инициализаторе дочернего класса вызывать инициализатор базового класса).
#
# В самом классе Station переопределите магические методы __str__() и __repr__(), чтобы они возвращали название
# станции метро (локальный атрибут name).
#
# Объекты второго класса LinkMetro должны создаваться командой:
#
# link = LinkMetro(v1, v2, dist)
# где v1, v2 - вершины (станции метро); dist - расстояние между станциями (любое положительное число).
#
# (Также не забывайте в инициализаторе этого дочернего класса вызывать инициализатор базового класса).
#
# В результате, эти классы должны совместно работать следующим образом (эти строчки в программе писать не нужно):
#
# map_metro = LinkedGraph()
# v1 = Station("Сретенский бульвар")
# v2 = Station("Тургеневская")
# v3 = Station("Чистые пруды")
# v4 = Station("Лубянка")
# v5 = Station("Кузнецкий мост")
# v6 = Station("Китай-город 1")
# v7 = Station("Китай-город 2")
#
# map_metro.add_link(LinkMetro(v1, v2, 1))
# map_metro.add_link(LinkMetro(v2, v3, 1))
# map_metro.add_link(LinkMetro(v1, v3, 1))
#
# map_metro.add_link(LinkMetro(v4, v5, 1))
# map_metro.add_link(LinkMetro(v6, v7, 1))
#
# map_metro.add_link(LinkMetro(v2, v7, 5))
# map_metro.add_link(LinkMetro(v3, v4, 3))
# map_metro.add_link(LinkMetro(v5, v6, 3))
#
# print(len(map_metro._links))
# print(len(map_metro._vertex))
# path = map_metro.find_path(v1, v6)  # от сретенского бульвара до китай-город 1
# print(path[0])    # [Сретенский бульвар, Тургеневская, Китай-город 2, Китай-город 1]
# print(sum([x.dist for x in path[1]]))  # 7
# P.S. В программе нужно объявить только классы Vertex, Link, LinkedGraph, Station, LinkMetro. На экран ничего выводить
# не нужно.


class Vertex:

    def __init__(self):
        self._links = []

    @property
    def links(self):
        return self._links


class Link:

    def __init__(self, v1, v2):
        self._v1 = v1
        self._v2 = v2
        self._dist = 1

    @property
    def v1(self):
        return self._v1

    @property
    def v2(self):
        return self._v2

    @property
    def dist(self):
        return self._dist


class LinkedGraph:

    def __init__(self):
        self._links = []
        self._vertex = []

    def add_vertex(self, v):
        if v not in self._vertex:
            self._vertex.append(v)
            return
        return

    def add_link(self, link):
        t = tuple(filter(lambda x: (id(x.v1) == id(link.v1) and id(x.v2) == id(link.v2)) or
                                   (id(x.v2) == id(link.v1) and id(x.v1) == id(link.v2)), self._links))
        if len(t) == 0:
            self._links.append(link)
            self.add_vertex(link.v1)
            self.add_vertex(link.v2)
            link.v1.links.append(link)
            link.v2.links.append(link)

    def find_path(self, start_v, stop_v):
        self._start_v = start_v
        self._stop_v = stop_v
        return self._next(self._start_v, None, [], [])

    def _dist_path(self, links):
        return sum([x.dist for x in links if x is not None])

    def _next(self, current, link_prev, current_path, current_links):
        current_path += [current]
        if link_prev:
            current_links += [link_prev]

        if current == self._stop_v:
            return current_path, current_links

        len_path = -1
        best_path = []
        best_links = []
        for link in current.links:
            path = []
            links = []
            if link.v1 not in current_path:
                path, links = self._next(link.v1, link, current_path[:], current_links[:])
            elif link.v2 not in current_path:
                path, links = self._next(link.v2, link, current_path[:], current_links[:])

            if self._stop_v in path and (len_path > self._dist_path(links) or len_path == -1):
                len_path = self._dist_path(links)
                best_path = path[:]
                best_links = links[:]

        return best_path, best_links


class Station(Vertex):
    def __init__(self, name):
        super().__init__()
        self.name = name

    def __repr__(self):
        return self.name


class LinkMetro(Link):

    def __init__(self, v1, v2, dist):
        super().__init__(v1, v2)
        self._dist = dist



# ВТОРОЙ ВАРИАНТ (АЛГОРИТМ ДЭЙКСТРЫ)!!!!!!!
import math


class Vertex:
    def __init__(self):
        self._links = []
        self._vertexs = {self}

    @property
    def links(self):
        return self._links

    def add_link(self, links):
        if not isinstance(links, Link):
            raise ValueError
        if links.v1 not in self._vertexs:
            self._links.append(links)
            self._vertexs.add(links.v1)
        elif links.v2 not in self._vertexs:
            self._links.append(links)
            self._vertexs.add(links.v2)


class Station(Vertex):
    def __init__(self, name):
        super().__init__()
        self.name = name

    def __str__(self):
        return self.name

    def __repr__(self):
        return self.name


class Link:
    def __init__(self, v1, v2, dist=1):
        self.v1 = v1
        self.v2 = v2
        self.dist = dist

    @property
    def v1(self):
        return self._v1

    @v1.setter
    def v1(self, v):
        #if isinstance(v, Vertex):
            #raise ValueError
        self._v1 = v

    @property
    def v2(self):
        return self._v2

    @v2.setter
    def v2(self, v):
        #if isinstance(v, Vertex):
            #raise ValueError
        self._v2 = v

    @property
    def dist(self):
        return self._dist

    @dist.setter
    def dist(self, dist):
        if type(dist) != int:
            raise ValueError
        self._dist = dist

    def get_other(self, v):
        if v == self.v1:
            return self.v2
        return self.v2


class LinkMetro(Link):
    def __init__(self, v1, v2, dist):
        super().__init__(v1, v2, dist)


class LinkedGraph:
    def __init__(self):
        self._links = []
        self._vertex = []
        self.links_true = set()

    def add_vertex(self, v):
        if v not in self._vertex:
            self._vertex.append(v)

    def add_link(self, link):
        if not (link.v1, link.v2) in self.links_true and not (link.v2, link.v1) in self.links_true:
            link.v1.add_link(link)
            self._links.append(link)
            self.add_vertex(link.v1)
            self.add_vertex(link.v2)
            self.links_true.add((link.v1, link.v2))

    def find_link(self, v1, v2):
        for i in self._links:
            if (v1 == i.v1 and v2 == i.v2) or (v1 == i.v2 and v2 == i.v1):
                return i


    @staticmethod
    def arg_min(T, S):
        amin = -1
        m = math.inf  # максимальное значение
        for i, t in T.items():
            if t < m and i not in S:
                m = t
                amin = i

        return amin

    def find_path(self, start_v, stop_v):
        N = len(self._vertex)  # число вершин в графе
        T = dict(zip(self._vertex, (math.inf for _ in range(N))))

        v = start_v
        S = {v}
        T[v] = 0  # нулевой вес для стартовой вершины
        M = dict(zip(self._vertex, (0 for _ in range(N)))) # оптимальные связи между вершинами

        while v != -1:
            for i in v.links:
                w = T[v] + i.dist
                j = i.get_other(v)
                if w < T[j]:
                    T[j] = w
                    M[j] = v

            v = self.arg_min(T, S)  # выбираем следующий узел с наименьшим весом
            if v != -1:  # выбрана очередная вершина
                S.add(v)  # добавляем новую вершину в рассмотрение

        # формирование оптимального маршрута:
        start = start_v
        end = stop_v
        P = [end]
        s = []
        while end != start:
            end = M[P[-1]]
            P.append(end)
            s.append(self.find_link(P[-1], P[-2]))

        return P[::-1], s



# ----------------------------------------------------------------------------------------------------------------------



# ======================================================================================================================

# ======================================================================================================================
# ИСКЛЮЧЕНИЯ И МЕНЕДЖЕРЫ КОНТЕКСТА
# ======================================================================================================================

# ======================================================================================================================


# ======================================================================================================================
# 5.1 Введение в обработку исключений. Блоки try / except
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Какие виды исключений бывают в языке Python?
#
# Выберите все подходящие ответы из списка


# - исключения в процессе выполнения программы (момента исполнения)
# - исключения в процессе компиляции программы (синтаксические)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Имеется следующий фрагмент программы:
#
# try:
#     val = float(input())
# except ValueError as e:
#     print(e)

# При каких входных данных выполнение программы перейдет в блок except?


# - при вводе любых не числовых значений



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. В программе объявлена функция:
#
# def get_number(x):
#     try:
#         return int(x)
#     except:
#         try:
#             return float(x)
#         except:
#             return x

# И вызывается со следующими аргументами:
#
# res_1 = get_number('-5')
# res_2 = get_number('5.78')
# res_3 = get_number('8(912)000-000-00')

# Выберите все верные утверждения, связанные с этой программой.


# - при вызове функции get_number(True) она возвратит значение 1
# - при передаче функции get_number() аргумента, который может быть преобразован в целое или вещественное число, будет
# возвращено число, иначе возвращается переданное значение x без изменений
# - res_1 равно числу -5; res_2 равно числу 5.78; res_3 равно строке '8(912)000-000-00'



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Имеется следующая иерархия классов исключений:

# И записан фрагмент программы:
#
# try:
#     x, y = map(float, input().split())
#     d = x / y
# except ArithmeticError:
#     print('ArithmeticError')
# except ZeroDivisionError:
#     print('ZeroDivisionError')

# В каких случаях выполнение программы перейдет в блок обработки исключения ZeroDivisionError?


# - ни в каких, так как класс ZeroDivisionError является дочерним по отношению к классу ArithmeticError



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. В программе объявлен класс Point:
#
# class Point:
#     def __init__(self, x, y):
#         self._x = x
#         self._y = y
# И создается объект этого класса:
#
# pt = Point(1, 2)
# Далее, вам нужно обратиться к атрибуту z объекта pt и, если такой атрибут существует, то вывести его значение на
# экран. Иначе вывести строку (без кавычек):
#
# "Атрибут с именем z не существует"
#
# Реализовать проверку следует с помощью блоков try/except.
#
# Подсказка: при обращении к несуществующему атрибуту генерируется исключение AttributeError.


class Point:
    def __init__(self, x, y):
        self._x = x
        self._y = y


pt = Point(1, 2)

try:
    print(pt.z)
except AttributeError:
    print('Атрибут с именем z не существует')



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Имеется следующий фрагмент программы:
#
# try:
#     x, y = map(float, input().split())
#     d = x / y
# except ZeroDivisionError:
#     print('ZeroDivisionError')
# except:
#     print('except')

# В каких случаях выполнение программы перейдет во второй блок except?


# - при вводе хотя бы одного не числового значения
# - при возникновении любых исключений, кроме исключения ZeroDivisionError



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. В программе вводятся в одну строчку через пробел некоторые данные, например:
#
# "1 -5.6 2 abc 0 False 22.5 hello world"
# Эти данные разбиваются по пробелу и представляются в виде списка строк:
#
# lst_in = input().split()
# Ваша задача посчитать сумму всех целочисленных значений, присутствующих в списке lst_in. Результат (сумму) вывести
# на экран.
#
# Подсказка: отбор только целочисленных значений можно выполнить с помощь функции filter() с последующим их
# преобразованием в целые числа с помощью функции map() и, затем, вычислением их суммы с помощью функции sum(). Для
# отбора целочисленных значений рекомендуется объявить вспомогательную функцию, которая бы возвращала True для строк, в
# которых присутствует целое число и False - для всех остальных строк.


# считывание строки и разбиение ее по пробелам
lst_in = input().split()

def f(x):
    try:
        int(x)
        return True
    except:
        return False

print(sum(list(map(int, (filter(f, lst_in))))))



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/zQDvmHlS6wg
#
# Подвиг 8. В программе вводятся в одну строчку через пробел некоторые данные, например:
#
# "1 -5.6 True abc 0 23.56 hello"
# Эти данные разбиваются по пробелу и представляются в виде списка строк:
#
# lst_in = input().split()
# Ваша задача сформировать новый список с именем lst_out, в котором строки с целыми числами будут представлены как
# целые числа (тип int), строки с вещественными числами, как вещественные (тип float), а остальные данные - без
# изменений.
#
# Например:
#
# lst_out = [1, -5.6, 'True', 'abc', 0, 23.56, 'hello']  # после обработки введенной
# строки "1 -5.6 True abc 0 23.56 hello"
# Реализовать эту задачу следует с помощью функции map() и объявления вспомогательной функции с механизмом обработки
# исключений для непосредственного преобразования данных в целые или вещественные числа.
#
# P.S. В программе нужно только сформировать список lst_out. На экран ничего выводить не нужно.


# считывание строки и разбиение ее по пробелам
lst_in = input().split()

def is_digit(x):
    try:
        return int(x)
    except:
        try:
            return float(x)
        except:
            return x

lst_out = list(map(is_digit, lst_in))



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/eKxzgkKD1fI
#
# Подвиг 9. Объявите в программе класс Triangle, объекты которого создаются командой:
#
# tr = Triangle(a, b, c)
# где a, b, c - длины сторон треугольника (любые положительные числа). В каждом объекте класса Triangle должны
# формироваться локальные атрибуты _a, _b, _c с соответствующими значениями.
#
# Если в качестве хотя бы одной величины a, b, c передается не числовое значение, или меньше либо равно нулю, то
# должно генерироваться исключение командой:
#
# raise TypeError('стороны треугольника должны быть положительными числами')
# Если из переданных значений a, b, c нельзя составить треугольник (условие: каждая сторона должна быть меньше суммы
# двух других), то генерировать исключение командой:
#
# raise ValueError('из указанных длин сторон нельзя составить треугольник')
# Затем, на основе следующего набора данных:
#
# input_data = [(1.0, 4.54, 3), ('abc', 1, 2, 3), (-3, 3, 5.2), (4.2, 5.7, 8.7), (True, 3, 5), (7, 4, 6)]
# необходимо сформировать объекты класса Triangle, но только в том случае, если не возникло никаких исключений. Все
# созданные объекты представить в виде списка с именем lst_tr.
#
# P.S. В программе нужно только сформировать список lst_tr. На экран ничего выводить не нужно.


# здесь объявляйте класс Triangle
class Triangle:

    def __init__(self, a, b, c):
        if type(a) not in (int, float) or type(b) not in (int, float) or type(c) not in (int, float):
            raise TypeError('стороны треугольника должны быть положительными числами')
        if a <= 0 or b <= 0 or c <= 0:
            raise TypeError('стороны треугольника должны быть положительными числами')

        if a > b + c or b > a + c or c > a + b:
            raise ValueError('из указанных длин сторон нельзя составить треугольник')

        self._a = a
        self._b = b
        self._c = c

input_data = [(1.0, 4.54, 3), ('abc', 1, 2, 3), (-3, 3, 5.2), (4.2, 5.7, 8.7), (True, 3, 5), (7, 4, 6)]

# здесь формируйте список lst_tr
lst_tr = []
for data in input_data:
    try:
        tr = Triangle(*data)
    except (TypeError, ValueError):
        pass
    else:
        lst_tr.append(tr)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0vmRMf5f4Iw
#
# Подвиг 10. Объявите в программе класс FloatValidator, объекты которого создаются командой:
#
# fv = FloatValidator(min_value, max_value)
# где min_value, max_value - минимальное и максимальное допустимое значение (диапазон [min_value; max_value]).
#
# Объекты этого класса предполагается использовать следующим образом:
#
# fv(value)
# где value - проверяемое значение. Если value не вещественное число или не принадлежит
# диапазону [min_value; max_value], то генерируется исключение командой:
#
# raise ValueError('значение не прошло валидацию')
# По аналогии, объявите класс IntegerValidator, объекты которого создаются командой:
#
# iv = IntegerValidator(min_value, max_value)
# и используются командой:
#
# iv(value)
# Здесь также генерируется исключение:
#
# raise ValueError('значение не прошло валидацию')
# если value не целое число или не принадлежит диапазону [min_value; max_value].
#
# После этого объявите функцию с сигнатурой:
#
# def is_valid(lst, validators): ...
#
# где lst - список из данных; validators - список из объектов-валидаторов (объектов классов FloatValidator
# и IntegerValidator).
#
# Эта функция должна отбирать из списка все значения, которые прошли хотя бы по одному валидатору. И возвращать новый
# список с элементами, прошедшими проверку.
#
# Пример использования классов и функции (эти строчки в программе не писать):
#
# fv = FloatValidator(0, 10.5)
# iv = IntegerValidator(-10, 20)
# lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv])   # [1, 4.5]
# P.S. В программе нужно только объявить классы и функцию. На экран ничего выводить не нужно.


class FloatValidator:

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if type(value) != float or not (self.min_value <= value <= self.max_value):
            raise ValueError('значение не прошло валидацию')


class IntegerValidator:

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if type(value) != int or not (self.min_value <= value <= self.max_value):
            raise ValueError('значение не прошло валидацию')


def is_valid(lst, validators):
    res = []
    for i in lst:
        for j in validators:
            try:
                j(i)
                res.append(i)
                break
            except ValueError:
                pass
    return res

fv = FloatValidator(0, 10.5)
iv = IntegerValidator(-10, 20)
lst_out = is_valid([1, 4.5, -10.5, 100, True, 'abc', (1, 2)], validators=[fv, iv])   # [1, 4.5]



# Второй вариант
class Validator:
    value_types = None

    def __init__(self, min_value, max_value):
        self.min_value = min_value
        self.max_value = max_value

    def __call__(self, value):
        if self.value_types and \
        (type(value) not in self.value_types or
         not self.min_value <= value <= self.max_value):
            raise ValueError('значение не прошло валидацию')
        return True


class FloatValidator(Validator):
    value_types = (float, )


class IntegerValidator(Validator):
    value_types = (int, )


def is_valid(lst, validators):
    def validate(x):
        for val in validators:
            try: return val(x)
            except ValueError: continue
        return False
    return [*filter(validate, lst)]



# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 5.2 Обработка исключений. Блоки finally и else
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Имеется следующий фрагмент программы:
#
# try:
#     val = float(input())
# except ValueError as e:
#     print(e)
# else:
#     val *= 10
#     print(val)
# При каких входных данных выполнение программы перейдет в блок else?


# - при вводе любых вещественных значений
# - при вводе любых целочисленных значений



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В каком порядке можно записывать блоки try/except/else/finally, чтобы программа работала без ошибок?


# - try/except/else/finally
# - try/except/else
# - try/except/finally



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Имеется следующий фрагмент программы:
#
# try:
#     val = float(input())
# except ValueError as e:
#     print(e)
# else:
#     val *= 10
#     print(val)
# finally:
#     print("finally")
# При каких входных данных выполнение программы перейдет в блок finally?


# - при вводе любых вещественных значений
# - при вводе любых строк (данных)
# - всегда будет переходить, вне зависимости от возникновения исключений



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. В программе вводятся два значения в одну строчку через пробел. Значениями могут быть числа, слова, булевы
# величины (True/False). Необходимо прочитать эти значения из входного потока. Если оба значения являются числами, то
# вычислить их сумму, иначе соединить их в одну строку с помощью оператора + (конкатенации строк). Результат вывести на
# экран (в блоке finally).
#
# P.S. Реализовать программу с использованием блоков try/except/finally.


try:
    a, b = input().split()
    res = int(a) + int(b)
except:
    try:
        res = sum(map(float, [a, b]))
    except:
        res = a + b
finally:
    print(res)


# Второй вариант
a, b = input().split()
try:
    a, b = map(int, (a, b))
except ValueError:
    try:
        a, b = map(float, (a, b))
    except ValueError:
        pass
finally:
    print(a + b)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Объявите в программе класс Point, объекты которого должны создаваться командами:
#
# pt = Point()
# pt = Point(x, y)
# где x, y - произвольные числа (координаты точки).
#
# В каждом объекте класса Point должны формироваться локальные атрибуты _x, _y с соответствующими значениями. Если
# аргументы не указываются (первая команда), то _x = 0, _y = 0.
#
# Далее, в программе вводятся два значения в одну строчку через пробел. Значениями могут быть числа, слова, булевы
# величины (True/False). Необходимо прочитать эти значения из входного потока. Если оба значения являются числами, то
# формировать объект pt командой:
#
# pt = Point(x, y)
# Если хотя бы одно из значений не числовое, то формировать объект pt командой:
#
# pt = Point()
# Реализовать этот функционал с помощью блоков try/except. А в блоке finally вывести на экран сообщение в
# формате (без кавычек):
#
# "Point: x = <значение x>, y = <значение y>"
#
# Sample Input:
#
# 10 20
# Sample Output:
#
# Point: x = 10, y = 20


class Point:

    def __init__(self, x=0, y=0):
        self._x = x
        self._y = y

    def __str__(self):
        return f"Point: x = {self._x}, y = {self._y}"


try:
    a, b = map(int, input().split())
    pt = Point(a, b)
except:
    pt = Point()
finally:
    print(pt)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. В программе объявлена функция для вычисления частного двух чисел:
#
# def get_div(x, y):
#     try:
#         res = x / y
#         return res
#     except ZeroDivisionError:
#         res = 100
#         return res
#     finally:
#         res = -1
#         print(f"finally: {res}")
# Выберите все верные утверждения, связанные с этой программой.


# - при вызове get_div(10, 0) функция возвратит значение 100 и на экран будет выведена строчка "finally: -1"
# - при вызове get_div(1, 2) функция возвратит значение 0.5 и на экран будет выведена строчка "finally: -1"



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. В практике программирования блок else используют как элемент отладки программы: в него прописывают текст
# программы, в котором заведомо не произойдет исключений, отлавливаемых в блоке try. Выполним на практике такой пример.
#
# Вам необходимо объявить функцию с сигнатурой:
#
# def get_loss(w1, w2, w3, w4): ...
#
# где w1, w2, w3, w4 - любые числа. Функция должна возвращать значение, вычисленное по формуле:
#
# y = 10 * w1 // w2 - 5 * w2 * w3 + w4
#
# Здесь фрагмент вычисления w1 // w2 содержит потенциальную ошибку деления на ноль, поэтому его следует делать в
# блоке try. А в блоке else продолжить вычисления, где не используются операции деления.
#
# Если происходит деление на ноль, то функция должна возвращать строку:
#
# "деление на ноль"
#
# P.S. В программе нужно объявить только функцию. Вызывать ее и выводить на экран ничего не нужно.


def get_loss(w1, w2, w3, w4):
    try:
        y = 10 * w1 // w2
    except ZeroDivisionError:
        return "деление на ноль"
    else:
        return y - 5 * w2 * w3 + w4



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/o66Is1ab4ho
#
# Подвиг 8. Объявите класс с именем Rect (прямоугольник), объекты которого создаются командой:
#
# r = Rect(x, y, width, height)
# где x, y - координаты верхнего левого угла (любые числа); width, height - ширина и высота
# прямоугольника (положительные числа). Ось абсцисс (Ox) направлена вправо, ось ординат (Oy) направлена вниз.
#
# В каждом объекте класса Rect должны формироваться локальные атрибуты с именами: _x, _y, _width, _height и
# соответствующими значениями. Если переданные аргументы x, y (не числа) и width, height не положительные числа, то
# генерировать исключение командой:
#
# raise ValueError('некорректные координаты и параметры прямоугольника')
# В классе Rect реализовать метод:
#
# def is_collision(self, rect): ...
#
# который проверяет пересечение текущего прямоугольника с другим (с объектом rect). Если прямоугольники
# пересекаются, то должно генерироваться исключение командой:
#
# raise TypeError('прямоугольники пересекаются')
# Сформировать в программе несколько объектов класса Rect со следующими значениями:
#
# 0; 0; 5; 3
# 6; 0; 3; 5
# 3; 2; 4; 4
# 0; 8; 8; 1
#
# Сохранить их в списке lst_rect. На основе списка lst_rect сформировать еще один список lst_not_collision, в котором
# должны быть объекты rect не пересекающиеся ни с какими другими объектами в списке lst_rect.
#
# P.S. В программе требуется объявить только класс и списки. На экран выводить ничего не нужно.
#
# Подсказка. Для определения пересечения двух прямоугольников, у которых стороны параллельны осям координат (как в
# этом подвиге) достаточно проверить, что верхняя грань первого прямоугольника находится ниже нижней грани второго, или
# нижняя грань первого прямоугольника выше верхней грани второго. И то же самое для вертикальных граней.


class Rect:

    def __init__(self, x, y, width, height):
        self._x = x
        self._y = y
        self._width = width
        self._height = height

    def __setattr__(self, key, value):
        if type(value) not in (int, float):
            raise ValueError('некорректные координаты и параметры прямоугольника')
        if key in ('_width', '_height') and value <= 0:
            raise ValueError('некорректные координаты и параметры прямоугольника')

        object.__setattr__(self, key, value)

    def is_collision(self, rect):
        if not isinstance(rect, Rect):
            raise TypeError('аргументом метода is_collision() должен быть объект класса Rect')

        if not (self._x + self._width < rect._x or rect._x + rect._width < self._x or self._y + self._height < rect._y
                or rect._y + rect._height < self._y):
            raise TypeError('прямоугольники пересекаются')


def is_collision(r1, r2):
    try:
        r1.is_collision(r2)
    except TypeError:
        return True
    return False

lst_rect = [Rect(0, 0, 5, 3), Rect(6, 0, 3, 5), Rect(3, 2, 4, 5), Rect(0, 8, 8, 1)]
lst_not_collision = [lst_rect[i] for i in range(len(lst_rect))
                     if not any(is_collision(lst_rect[i], lst_rect[j]) for j in range(len(lst_rect)) if i != j)]



# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 5.3 Распространение исключений (propagation exceptions)
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. В программе объявлены два класса следующим образом:
#
# class Geom:
#     def __init__(self, width, color):
#         if type(width) not in (int, float) or type(color) != str or width < 0:
#             raise ValueError('неверные параметры фигуры')
#
#         self._width = width
#         self._color = color
#
#
# class Ellipse(Geom):
#     def __init__(self, x1, y1, x2, y2, width=1, color='red'):
#         super().__init__(width, color)
#
#         if not self._is_valid(x1) or not self._is_valid(y1) or not self._is_valid(x2) or not self._is_valid(y2):
#             raise ValueError('неверные координаты фигуры')
#
#         self._x1 = x1
#         self._y1 = y1
#         self._x2 = x2
#         self._y2 = y2
#
#     def _is_valid(self, x):
#         return type(x) in (int, float)
# И создается объект класса Ellipse:
#
# try:
#     x1, y1, x2, y2, w = map(float, input().split())
#     el = Ellipse(x1, y1, x2, y2, w)
# except ValueError as e:
#     print(e)
# Выберите все верные утверждения, связанные с этой программой.


# - если бы переменная w ссылалась на строку, то в классе Geom было бы сгенерировано исключение, которое поднялось бы
# до класса Ellipse и обработано в основной программе в блоке try
# - при вводе положительных числовых значений объект класса Ellipse будет создан успешно
# - все исключения, формируемые в классе Geom, можно обрабатывать внутри класса Ellipse



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Вы видите в консольном окне следующие строчки сообщения об ошибке:
#
# Traceback (most recent call last):
#   File "D:\Python\Projects\oop\ex1.py", line 26, in <module>
#     el = Ellipse(1, 2, 3, 4, '1')
#   File "D:\Python\Projects\oop\ex1.py", line 12, in __init__
#     super().__init__(width, color)
#   File "D:\Python\Projects\oop\ex1.py", line 4, in __init__
#     raise ValueError('неверные параметры фигуры')
# ValueError: неверные параметры фигуры
#
# Выберите все верные утверждения, которые можно сделать из этого вывода.


# - исключение ValueError сгенерировано в 4-й строчке программы в методе __init__()
# - исключение ValueError стало следствием вызова метода __init__() в 12-й строчке программы
# - исключение ValueError не было обработано в основном модуле программы в 26-й строчке
# - исключение ValueError сгенерировано в 4-й строчке программы и связано с работой команд, записанных
# в 12-й и 26-й строчках



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Объявите функцию с сигнатурой:
#
# def input_int_numbers(): ...
#
# которая бы считывала строку из введенных целых чисел, записанных через пробел, и возвращала кортеж из введенных
# чисел (в виде целых чисел, а не строк).
#
# Если хотя бы одно значение не является целым числом, то генерировать исключение, командой:
#
# raise TypeError('все числа должны быть целыми')
# Вызовите эту функцию в цикле до тех пор, пока пользователь не введет в строке все целочисленные значения (то есть,
# цикл завершается, когда функция отработает штатно, без генерации исключения).
#
# Выведите на экран прочитанные значения, записанные в виде строки через пробел.
#
# Sample Input:
# 1 abc 3 5
# 2.4 -5 4 3 2
# 0 -5 8 11
# 1 2 3 4

# Sample Output:
# 0 -5 8 11


def input_int_numbers():
    try:
        a = tuple(map(int, input().split()))
    except TypeError:
        raise TypeError('все числа должны быть целыми')
    else:
        return a


while True:
    try:
        a = input_int_numbers()
    except:
        continue
    else:
        print(*a)
        break


# Второе решение
def input_int_numbers(input_data):
    try:
        return list(map(int, input_data))
    except:
        raise TypeError('все числа должны быть целыми')

a = None
while a is None:
    input_data = input().split()
    try:
         a = input_int_numbers(input_data)
    except:
        continue

print(*a)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/IexoPrHUSaA
#
# Подвиг 4. Объявите класс с именем ValidatorString, объекты которого создаются командой:
#
# vs = ValidatorString(min_length, max_length, chars)
# где min_length, max_length - минимально и максимально допустимая длина строки (целые числа, формируемые
# диапазон [min_length; max_length]); chars - строка из набора символов (хотя бы один из них должен присутствовать в
# проверяемой строке). Если chars - пустая строка, то проверку на вхождение символов не делать.
#
# В самом классе ValidatorString объявите метод:
#
# def is_valid(self, string): ...
#
# который проверяет строку string на соответствие критериям: string должна быть строкой, с длиной в
# диапазоне [min_length; max_length] и в string присутствует хотя бы один символ из chars. Если хотя бы один из этих
# критериев не выполняется, то генерируется исключение командой:
#
# raise ValueError('недопустимая строка')
# Затем, объявите класс с именем LoginForm, объекты которого создаются командой:
#
# lg = LoginForm(login_validator, password_validator)
# где login_validator - валидатор для логина (объект класса ValidatorString); password_validator - валидатор для
# пароля (объект класса ValidatorString).
#
# В самом классе LoginForm объявите следующий метод:
#
# def form(self, request): ...
#
# где request - объект запроса (словарь). В словаре request должен быть ключ 'login' со значением введенного
# логина (строки) и ключ 'password' со значением введенного пароля (строка). Если хотя бы одного ключа нет, то
# генерировать исключение командой:
#
# raise TypeError('в запросе отсутствует логин или пароль')
# В противном случае (если проверка для request прошла), проверять корректность полученного формой логина и пароля с
# помощью валидаторов, указанных в параметрах login_validator и password_validator, при создании объекта формы.
#
# Если логин/пароль введены верно, то в объекте класса LoginForm локальным атрибутам _login и _password присвоить
# соответствующие значения.
#
# Пример использования классов (эти строчки должны быть в программе):
#
# login_v = ValidatorString(4, 50, "")
# password_v = ValidatorString(10, 50, "!$#@%&?")
# lg = LoginForm(login_v, password_v)
# login, password = input().split()
# try:
#     lg.form({'login': login, 'password': password})
# except (TypeError, ValueError) as e:
#     print(e)
# else:
#     print(lg._login)

# Sample Input:
# sergey balakirev!

# Sample Output:
# sergey


class ValidatorString:

    def __init__(self, min_length, max_length, chars):
        self.min_length = min_length
        self.max_length = max_length
        self.chars = chars

    def is_valid(self, string):
        if self.chars == '':
            if type(string) == str and self.min_length <= len(string) <= self.max_length:
                return True
            raise ValueError('недопустимая строка')
        else:
            if type(string) == str and self.min_length <= len(string) <= self.max_length \
                    and any([x in self.chars for x in string]):
                return True
        raise ValueError('недопустимая строка')


class LoginForm:

    def __init__(self, login_validator, password_validator):
        self.login_validator = login_validator
        self.password_validator = password_validator
        self._login = None
        self._password = None

    def form(self, request):
        if 'login' not in request or 'password' not in request:
            raise TypeError('в запросе отсутствует логин или пароль')
        if self.login_validator.is_valid(request['login']):
            self._login = request['login']
        if self.password_validator.is_valid(request['password']):
            self._password = request['password']


# Второй вариант
class ValidatorString:
    def __init__(self, min_length, max_length, chars):
        self.min_length = min_length
        self.max_length = max_length
        self.chars = chars

    def is_valid(self, string):
        if not len(string) in range(self.min_length, self.max_length + 1) or \
           self.chars and not any(c in self.chars for c in string):
            raise ValueError('недопустимая строка')
        return string


class LoginForm:
    def __init__(self, login_validator, password_validator):
        self.login_validator = login_validator
        self.password_validator = password_validator

    def form(self, request):
        if not all(w in request for w in ('login', 'password')):
            raise TypeError('в запросе отсутствует логин или пароль')
        self._login = self.login_validator.is_valid(request.get('login'))
        self._password = self.password_validator.is_valid(request.get('password'))


login_v = ValidatorString(4, 50, "")
password_v = ValidatorString(10, 50, "!$#@%&?")
lg = LoginForm(login_v, password_v)
login, password = input().split()
try:
    lg.form({'login': login, 'password': password})
except (TypeError, ValueError) as e:
    print(e)
else:
    print(lg._login)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/AVh6hs06oCU
#
# Подвиг 5. Вы начинаете разрабатывать свой сервис по тестированию. Для этого вам поручается разработать базовый
# класс Test для всех видов тестов, объекты которого создаются командой:
#
# test = Test(descr)
# где descr - формулировка теста (строка). Если длина строки descr меньше 10 или больше 10 000 символов, то
# генерировать исключение командой:
#
# raise ValueError('формулировка теста должна быть от 10 до 10 000 символов')
# В самом классе Test должен быть объявлен абстрактный метод:
#
# def run(self): ...
#
# который должен быть переопределен в дочернем классе. Если это не так, то должно генерироваться исключение командой:
#
# raise NotImplementedError
# Далее, объявите дочерний класс с именем TestAnsDigit для тестирования правильного введенного числового ответа на
# вопрос теста. Объекты класса TestAnsDigit должны создаваться командой:
#
# test_d = TestAnsDigit(descr, ans_digit, max_error_digit)
# где ans_digit - верный числовой ответ на тест; max_error_digit - максимальная погрешность в указании числового
# ответа (необходимо для проверки корректности вещественных чисел, по умолчанию принимает значение 0.01).
#
# Если аргумент ans_digit или max_error_digit не число (также проверить, что max_error_digit больше или равно нулю), то
# генерировать исключение командой:
#
# raise ValueError('недопустимые значения аргументов теста')
# В классе TestAnsDigit переопределите метод:
#
# def run(self): ...
#
# который должен читать строку из входного потока (ответ пользователя) командой:
#
# ans = float(input()) # именно такой командой, ее прописывайте в методе run()
# и возвращать булево значение True, если введенный числовой ответ ans принадлежит
# диапазону [ans_digit-max_error_digit; ans_digit+max_error_digit]. Иначе возвращается булево значение False.
#
# Теперь нужно воспользоваться классом TestAnsDigit. Для этого в программе вначале читается сам тест с помощью команд:
#
# descr, ans = map(str.strip, input().split('|'))  # например: Какое значение получится при вычислении 2+2? | 4
# ans = float(ans) # здесь для простоты полагаем, что ans точно число и ошибок в преобразовании быть не может
# Далее, вам необходимо создать объект класса TestAnsDigit с аргументами descr, ans, а аргумент max_error_digit должен
# принимать значение по умолчанию 0.01.
#
# Запустите тест командой run() и выведите на экран результат его работы (значение True или False). Если в процессе
# создания объекта класса TestAnsDigit или в процессе работы метода run() возникли исключения, то они должны быть обработаны и на экран выведено сообщение, содержащееся в исключении.
#
# Sample Input:
# Какое значение получим, при выполнении команды int(5.7)? | 5
# 6

# Sample Output:
# False


class Test:

    def __init__(self, descr):
        if not 10 <= len(descr) <= 10000:
            raise ValueError('формулировка теста должна быть от 10 до 10 000 символов')

        self.descr = descr

    def run(self):
        raise NotImplementedError


class TestAnsDigit(Test):

    def __init__(self, descr, ans_digit, max_error_digit=0.01):
        if type(ans_digit) not in (int, float) or type(max_error_digit) not in (int, float) or max_error_digit < 0:
            raise ValueError('недопустимые значения аргументов теста')

        super().__init__(descr)
        self.ans_digit = ans_digit
        self.max_error_digit = max_error_digit

    def run(self):
        ans = float(input())
        if self.ans_digit - self.max_error_digit <= ans <= self.ans_digit + self.max_error_digit:
            return True
        return False


descr, ans = map(str.strip, input().split('|'))  # например: Какое значение получится при вычислении 2+2? | 4
ans = float(ans) # здесь для простоты полагаем, что ans точно число и ошибок в преобразовании быть не может

try:
    test = TestAnsDigit(descr, ans)
    res = test.run()
except Exception as e:
    print(e)
else:
    print(res)


# Второй вариант
from numbers import Real


class Test:
    def __init__(self, descr: str):
        self.descr = descr

    def __setattr__(self, key, value):
        if key == 'descr' and (len(value) < 10 or len(value) > 10_000):
            raise ValueError('формулировка теста должна быть от 10 до 10 000 символов')
        super().__setattr__(key, value)

    def run(self):
        raise NotImplementedError


class TestAnsDigit(Test):
    def __init__(self, descr, ans_digit, max_error_digit=0.01):
        super().__init__(descr)
        self.ans_digit, self.max_error_digit = ans_digit, max_error_digit

    def __setattr__(self, key, value):
        if key in ('ans_digit', 'max_error_digit'):
            if not isinstance(value, Real):
                raise ValueError('недопустимые значения аргументов теста')
            if key == 'max_error_digit' and value < 0:
                raise ValueError('недопустимые значения аргументов теста')
        super().__setattr__(key, value)

    def run(self):
        ans = float(input())  # именно такой командой, ее прописывайте в методе run()
        low = self.ans_digit - self.max_error_digit
        height = self.ans_digit + self.max_error_digit

        return low <= ans <= height


descr, ans = map(str.strip, input().split('|'))
try:
    testAnsDigit = TestAnsDigit(descr, float(ans))
    print(testAnsDigit.run())
except Exception as e:
    print(e)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. В программе выполняется считывание числовых данных из входного потока, командой:
#
# digits = list(map(float, input().split()))
# Эти данные следует представить в виде объекта класса TupleLimit. Сам класс должен наследоваться от класса tuple, а
# его объекты создаваться командой:
#
# tl = TupleLimit(lst, max_length)
# где lst - коллекция (список или кортеж) из данных; max_length - максимально допустимая длина коллекции TupleLimit.
# Если длина lst превышает значение max_length, то должно генерироваться исключение командой:
#
# raise ValueError('число элементов коллекции превышает заданный предел')
# В самом классе TupleLimit переопределить магические методы __str__() и __repr__() для отображения объекта класса
# TupleLimit в виде строки из набора данных lst, записанных через пробел. Например:
#
# "1.0 2.5 -5.0 11.2"
#
# Создайте в программе объект класса TupleLimit для прочитанных данных digits и параметром max_length = 5. Выведите на
# экран объект в случае его успешного создания. Иначе, выведите сообщение обработанного исключения.
#
# Sample Input:
#
# 1 2 3 4 5
# Sample Output:
#
# 1.0 2.0 3.0 4.0 5.0


# здесь объявляйте класс
class TupleLimit(tuple):

    def __new__(cls, lst, max_length):
        if len(lst) > max_length:
            raise ValueError('число элементов коллекции превышает заданный предел')
        return super().__new__(cls, lst)

    def __str__(self):
        return ' '.join(map(str, self))

    def __repr__(self):
        return ' '.join(map(str, self))


digits = list(map(float, input().split()))  # эту строчку не менять (коллекцию digits также не менять)

# здесь создавайте объект класса
try:
    res = TupleLimit(digits, max_length=5)
except Exception as e:
    print(e)
else:
    print(res)



# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 5.4 Инструкция raise и пользовательские исключения
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Выберите все верные утверждения, связанные с оператором raise.


# - после оператора raise следует указывать объект класса, унаследованного от BaseException
# - оператор raise позволяет генерировать различные исключения
# - после выполнения оператора raise программа останавливает свою работу, если исключение не обрабатывается



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Имеется следующий фрагмент программы:
#
# class LimitException(Exception):
#     """Превышение лимита"""
#
#
# error = LimitException('превышение лимита нагрузки')
# raise error
#
# Выберите все верные утверждения, относящиеся к этой программе.


# - при выполнении команды raise error на экран будет выведено сообщение "превышение лимита нагрузки"
# - команда raise error сгенерирует исключение типа LimitException



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Имеется следующий фрагмент программы:
#
# class LimitException(Exception):
#     """Превышение лимита"""
#
#
# class ServerLimitException(LimitException):
#     """Превышение нагрузки на сервер"""
#
#
# try:
#     raise ServerLimitException('превышение серверной нагрузки')
# except LimitException:
#     print("LimitException")
# except ServerLimitException:
#     print("ServerLimitException")
#
# Выберите все верные утверждения, относящиеся к этой программе.


# - при выполнении этой программы на экране будет отображена строка "LimitException"
# - программа ни при каких типах исключений не перейдет во второй блок except
# - после выполнения оператора raise программа перейдет в первый блок except



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите класс-исключение с именем StringException, унаследованным от базового класса Exception. После
# этого объявите еще два класса-исключения:
#
# NegativeLengthString - ошибка, если длина отрицательная;
# ExceedLengthString - ошибка, если длина превышает заданное значение;
#
# унаследованные от базового класса StringException.
#
# Затем, в блоке try (см. программу) пропишите команду генерации исключения для перехода в блок обработки
# исключения ExceedLengthString.


# здесь объявляйте классы
class StringException(Exception):
    pass


class NegativeLengthString(StringException):
    """ошибка, если длина отрицательная"""


class ExceedLengthString(StringException):
    """ошибка, если длина превышает заданное значение"""

try:
    # здесь команда для генерации исключения
    raise ExceedLengthString()
except NegativeLengthString:
    print("NegativeLengthString")
except ExceedLengthString:
    print("ExceedLengthString")
except StringException:
    print("StringException")



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/6wnJd7OrNaI
#
# Подвиг 5. Объявите в программе класс-исключение с именем PrimaryKeyError, унаследованным от базового
# класса Exception. Объекты класса PrimaryKeyError должны создаваться командами:
#
# e1 = PrimaryKeyError()          # Первичный ключ должен быть целым неотрицательным числом
# e2 = PrimaryKeyError(id='abc')  # Значение первичного ключа id = abc недопустимо
# e3 = PrimaryKeyError(pk='123')  # Значение первичного ключа pk = 123 недопустимо
# В первом варианте команды должно формироваться сообщение об ошибке "Первичный ключ должен быть целым неотрицательным
# числом". При втором варианте:
#
# "Значение первичного ключа id = <id> недопустимо"
#
# И при третьем:
#
# "Значение первичного ключа pk = <pk> недопустимо"
#
# Эти сообщения должны формироваться при отображении объектов класса PrimaryKeyError, например:
#
# print(e2) # Значение первичного ключа id = abc недопустимо
# Затем, сгенерируйте это исключение с аргументом id = -10.5, обработайте его и отобразите на экране объект исключения.
#
# Sample Input:
#

# Sample Output:
# Значение первичного ключа id = -10.5 недопустимо


class PrimaryKeyError(Exception):

    def __init__(self, **kwargs):
        if not kwargs:
            self.error_message = "Первичный ключ должен быть целым неотрицательным числом"
        else:
            k, v = list(kwargs.items())[0]
            self.error_message = f"Значение первичного ключа {k} = {v} недопустимо"

    def __str__(self):
        return self.error_message


try:
    raise PrimaryKeyError(id=-10.5)
except PrimaryKeyError as e:
    print(e)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Объявите класс DateString для представления дат, объекты которого создаются командой:
#
# date = DateString(date_string)
# где date_string - строка с датой в формате:
#
# "DD.MM.YYYY"
#
# здесь DD - день (целое число от 1 до 31); MM - месяц (целое число от 1 до 12); YYYY - год (целое число от 1 до 3000).
# Например:
#
# date = DateString("26.05.2022")
# или
#
# date = DateString("26.5.2022") # незначащий ноль может отсутствовать
# Если указанная дата в строке записана неверно (не по формату), то генерировать исключение с помощью собственного
# класса:
#
# DateError - класс-исключения, унаследованный от класса Exception.
#
# В самом классе DateString переопределить магический метод __str__() для формирования строки даты в формате:
#
# "DD.MM.YYYY"
#
# (здесь должны фигурировать незначащие нули, например, для аргумента "26.5.2022" должна формироваться
# строка "26.05.2022").
#
# Далее, в программе выполняется считывание строки из входного потока командой:
#
# date_string = input()
# Ваша задача создать объект класса DateString с аргументом date_string и вывести объект на экран командой:
#
# print(date) # date - объект класса DateString
# Если же произошло исключение, то вывести сообщение (без кавычек):
#
# "Неверный формат даты"
#
# Sample Input:
# 1.2.1812

# Sample Output:
# 01.02.1812


class DateError(Exception): ...


class DateString:
    def __init__(self, date_string):
        d, m, y = map(int, date_string.split('.'))
        if d not in range(1, 32) or m not in range(1, 13) or y not in range(1, 3001):
            raise DateError("Неверный формат даты")
        self.d = d
        self.m = m
        self.y = y

    def __str__(self):
        return f'{self.d:02}.{self.m:02}.{self.y:04}'


date_string = input()
try:
    print(DateString(date_string))
except DateError as e:
    print(e)


# Второй вариант
from datetime import datetime

class DateError(Exception):
    pass

class DateString:
    def __init__(self, date):
        try:
            self.date = datetime.strptime(date, '%d.%m.%Y').strftime('%d.%m.%Y')
        except ValueError:
            raise DateError

    def __str__(self):
        return self.date


date_string = input()
try:
    print(DateString(date_string))
except DateError:
    print("Неверный формат даты")


# Третий вариант
import re


class DateString:
    REGEX = r"(?:0?[1-9]|[1-2][0-9]|3[01])\.(?:0?[1-9]|1[0-2])\.(?:[0-2]?[0-9]{1,3}|3000)"

    def __init__(self, date_string):
        if not re.fullmatch(self.REGEX, date_string) or re.search(r"\.0{1,4}$", date_string):
            raise DateError

        self.day, self.month, self.year = map(int, date_string.split('.'))

    def __str__(self):
        return f"{str(self.day).rjust(2, '0')}.{str(self.month).rjust(2, '0')}.{str(self.year).rjust(4, '0')}"


class DateError(Exception):
    def __str__(self):
        return "Неверный формат даты"


date_string = input()
try:
    date = DateString(date_string)
except DateError as err:
    print(err)
else:
    print(date)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/wLaOyNN8x7E
#
# Значимый подвиг 7. Вам поручается разработать класс TupleData, элементами которого могут являются только объекты
# классов: CellInteger, CellFloat и CellString.


# Вначале в программе нужно объявить класс CellInteger, CellFloat и CellString, объекты которых создаются командами:
#
# cell_1 = CellInteger(min_value, max_value)
# cell_2 = CellFloat(min_value, max_value)
# cell_3 = CellString(min_length, max_length)
# где min_value, max_value - минимальное и максимальное допустимое значение в ячейке; min_length,
# max_length - минимальная и максимальная допустимая длина строки в ячейке.
#
# В каждом объекте этих классов должны формироваться локальные атрибуты с именами _min_value, _max_value
# или _min_length, _max_length и соответствующими значениями.
#
# Запись и считывание текущего значения в ячейке должно выполняться через объект-свойство (property) с именем:
#
# value - для записи и считывания значения в ячейке (изначально возвращает значение None).
#
# Если в момент записи новое значение не соответствует диапазону [min_value; max_value] или [min_length; max_length],
# то генерируется исключения командами:
#
# raise CellIntegerException('значение выходит за допустимый диапазон')  # для объектов класса CellInteger
# raise CellFloatException('значение выходит за допустимый диапазон')    # для объектов класса CellFloat
# raise CellStringException('длина строки выходит за допустимый диапазон')  # для объектов класса CellString
# Все три класса исключений должны быть унаследованы от одного общего класса:
#
# CellException
#
# Далее, объявите класс TupleData, объекты которого создаются командой:
#
# ld = TupleData(cell_1, ..., cell_N)
# где cell_1, ..., cell_N - объекты классов CellInteger, CellFloat и CellString (в любом порядке и любом количестве).
#
# Обращение к отдельной ячейке должно выполняться с помощью оператора:
#
# value = ld[index] # считывание значения из ячейке с индексом index
# ld[index] = value # запись нового значения в ячейку с индексом index
# Индекс index отсчитывается с нуля (для первой ячейки) и является целым числом. Если значение index выходит за
# диапазон [0; число ячеек-1], то генерировать исключение IndexError.
#
# Также с объектами класса TupleData должны выполняться следующие функции и операторы:
#
# res = len(ld) # возвращает общее число элементов (ячеек) в объекте ld
# for d in ld:  # перебирает значения ячеек объекта ld (значения, а не объекты ячеек)
#     print(d)
# Все эти классы в программе можно использовать следующим образом:
#
# ld = TupleData(CellInteger(0, 10), CellInteger(11, 20), CellFloat(-10, 10), CellString(1, 100))
#
# try:
#     ld[0] = 1
#     ld[1] = 20
#     ld[2] = -5.6
#     ld[3] = "Python ООП"
# except CellIntegerException as e:
#     print(e)
# except CellFloatException as e:
#     print(e)
# except CellStringException as e:
#     print(e)
# except CellException:
#     print("Ошибка при обращении к ячейке")
# except Exception:
#     print("Общая ошибка при работе с объектом TupleData")

# P.S. Данная программа должна быть выполнена штатно, без ошибок. На экран отображать ничего не нужно.


class CellException(Exception):
    pass


class CellIntegerException(CellException):

    def __str__(self):
        return 'значение выходит за допустимый диапазон'


class CellFloatException(CellException):

    def __str__(self):
        return 'значение выходит за допустимый диапазон'


class CellStringException(CellException):

    def __str__(self):
        return 'длина строки выходит за допустимый диапазон'


class CellInteger:

    def __init__(self, min_value, max_value, value=None):
        self.__value = value
        self._min_value = min_value
        self._max_value = max_value

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, val):
        if type(val) != int or val not in range(self._min_value, self._max_value + 1):
            raise CellIntegerException()
        self.__value = val


class CellFloat:

    def __init__(self, min_value, max_value, value=None):
        self.__value = value
        self._min_value = min_value
        self._max_value = max_value

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, val):
        if type(val) != float or val not in range(self._min_value, self._max_value + 1):
            raise CellFloatException()
        self.__value = val


class CellString:

    def __init__(self, min_length, max_length, value=None):
        self.__value = value
        self._min_length = min_length
        self._max_length = max_length

    @property
    def value(self):
        return self.__value

    @value.setter
    def value(self, val):
        if type(val) != str or len(val) not in range(self._min_length, self._max_length + 1):
            raise CellStringException()
        self.__value = val


class TupleData:

    def __init__(self, *args):
        self.args = list(args)

    def check_index(self, indx):
        if type(indx) == int and 0 <= indx <= len(self.args) - 1:
            return True
        raise IndexError()

    def __getitem__(self, item):
        self.check_index(item)
        return self.args[item]

    def __setitem__(self, key, value):
        self.check_index(key)
        self.args[key] = value

    def __len__(self):
        return len(self.args)

    def __iter__(self):
        return iter(self.args)


ld = TupleData(CellInteger(0, 10), CellInteger(11, 20), CellFloat(-10, 10), CellString(1, 100))

try:
    ld[0] = 1
    ld[1] = 20
    ld[2] = -5.6
    ld[3] = "Python ООП"
except CellIntegerException as e:
    print(e)
except CellFloatException as e:
    print(e)
except CellStringException as e:
    print(e)
except CellException:
    print("Ошибка при обращении к ячейке")
except Exception:
    print("Общая ошибка при работе с объектом TupleData")



# ----------------------------------------------------------------------------------------------------------------------



# ======================================================================================================================
# 5.5 Менеджеры контекстов. Оператор with
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Выберите все верные утверждения, связанные с работой оператора with.


# - перед началом выполнения операторов внутри менеджера контекста выполняется метод __enter__, а после
# завершения - метод __exit__
# - после оператора with необходимо указывать объект класса, в котором обязательно должны быть реализованы
# методы __enter__ и __exit__



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Метод __exit__ имеет следующую сигнатуру:
#
# def __exit__(self, exc_type, exc_val, exc_tb): ...
#
# За что отвечают параметры exc_type, exc_val, exc_tb этого метода?


# - exc_type : тип возникшего исключения (None, если не произошло)
# exc_val : объект класса возникшего исключения (None, если не произошло)
# exc_tb : трассировка стека возникшего исключения (None, если не произошло)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Объявите класс PrimaryKey, который должен работать совместно с менеджером контекста следующим образом:
#
# with PrimaryKey() as pk:
#     raise ValueError
# где pk - ссылка на объект класса PrimaryKey. Класс PrimaryKey должен в момент входа в менеджер контекста выводить на
# экран сообщение "вход", а при завершении работы менеджера контекста выводить тип возникшего исключения.
#
# Класс PrimaryKey следует реализовать так, чтобы менеджер контекста сам обрабатывал возникшее исключение.


class PrimaryKey:

    def __enter__(self):
        print('вход')

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(exc_type)
        return True



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/4SewG1p3f-s
#
# Подвиг 4. Вам поручено разработать класс DatabaseConnection для управления подключением к базе данных. Объекты этого
# класса создаются командой:
#
# conn = DatabaseConnection()
# В самом классе необходимо объявить метод:
#
# def connect(self, login, password): ...
#
# для подключения к БД. В данной реализации этот метод должен устанавливать локальный атрибут _fl_connection_open в
# значение True:
#
# _fl_connection_open = True
# и генерировать исключение с помощью собственного класса ConnectionError унаследованного от базового класса Exception.
#
# Также в классе DatabaseConnection должен быть метод:
#
# def close(self): ...
#
# для закрытия соединения. В этом методе нужно атрибут _fl_connection_open установить в значение False.
#
# Метод close() необходимо вызывать всякий раз после завершения работы с БД, вне зависимости от того, произошли
# какие-либо исключения или нет.
#
# Этот функционал (автоматическое закрытие соединения с БД) предполагается реализовывать посредством менеджера
# контекста с использованием класса DatabaseConnection следующим образом:
#
# with DatabaseConnection() as conn:
#     # операторы менеджера контекста
# Пропишите дополнительно в классе DatabaseConnection необходимые магические методы для такого его использования
# совместно с оператором with.
#
# P.S. В программе нужно объявить только класс. На экран ничего выводить не нужно.


class ConnectionError(Exception):
    pass


class DataBaseConnection:

    def __init__(self):
        self._fl_connection_open = False

    def connect(self, login, password):
        self._fl_connection_open = True
        raise ConnectionError()

    def close(self):
        self._fl_connection_open = False

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YPppgpsCo3E
#
# Подвиг 5. Объявите класс Box (ящик), объекты которого создаются командой:
#
# box = Box(name, max_weight)
# где name - название ящика (строка); max_weight - максимальный суммарный вес вещей в ящике (любое положительное число).
#
# В каждом объекте этого класса должны формироваться локальные атрибуты:
#
# _name - ссылка на параметр name;
# _max_weight - ссылка на параметр max_weight;
# _things - список из вещей, хранящиеся в ящике (изначально пустой список).
#
# В классе Box объявите метод:
#
# def add_thing(self, obj)
#
# для добавления новой вещи в ящик, где obj - кортеж из двух значений:
#
# (название_вещи, вес_вещи)
#
# Если в момент добавления новой вещи суммарный вес всех вещей в ящике становится больше величины _max_weight, то
# генерировать исключение командой:
#
# raise ValueError('превышен суммарный вес вещей')
# Затем, объявите еще один класс BoxDefender, который должен работать совместно с менеджером контекста следующим
# образом (эти строчки в программе не писать):
#
# box = Box("сундук", 1000)
# box.add_thing(("спички", 46.6))
# box.add_thing(("рубашка", 134))
#
# with BoxDefender(box) as b:
#     b.add_thing(("зонт", 346.6))
#     b.add_thing(("шина", 500))
#     ...
# Здесь b - это ссылка на объект класса Box. Если при добавлении вещей возникает исключение ValueError, то объект box
# должен оставаться без изменений (с теми вещами, что были до вызова менеджера контекста). Иначе, все добавленные вещи
# остаются в объекте box.
#
# P.S. В программе только объявить классы. Выводить что-либо на экран и использовать классы не нужно.


class Box:

    def __init__(self, name, max_weight):
        self._name = name
        self._max_weight = max_weight
        self._things = []

    @property
    def things(self):
        return self._things

    @things.setter
    def things(self, lst):
        self._things = lst

    @property
    def total_weight(self):
        return sum(x[1] for x in self._things)

    def add_thing(self, obj):
        name, weight = obj
        if self.total_weight + weight > self._max_weight:
            raise ValueError('превышен суммарный вес вещей')

        self._things.append(obj)


class BoxDefender:

    def __init__(self, box):
        self._box = box
        self._things = box._things[:]

    def __enter__(self):
        return self._box

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            self._box._things = self._things

        return False



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6 (на повторение). Имеется следующий фрагмент программы:
#
# class PrinterError(Exception):
#     """Класс общих ошибок принтера"""
#
#
# class PrinterConnectionError(PrinterError):
#     """Ошибка соединения с принтером"""
#
#
# class PrinterPageError(PrinterError):
#     """Ошибка отсутствия бумаги в принтере"""
#
#
# try:
#     raise PrinterConnectionError('соединение с принтером отсутствует')
# except (PrinterConnectionError, PrinterPageError) as e:
#     print(e)
# except PrinterError as e:
#     print(e)

# Выберите все верные утверждения, связанные с этой программой.


# - при выполнении программы на экране будет отображена строка "соединение с принтером отсутствует"
# - при возникновении исключений PrinterConnectionError или PrinterPageError выполнение программы перейдет в
# блок except с этими двумя классами



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. Возможно ли в ООП обойтись без механизма обработки исключений и менеджеров контекста?


# - да, но программа может получиться трудно понимаемой и трудно расширяемой
# - вполне возможны ситуации, когда блоки try/except можно заменить операторами if/elif/else без потери качества
# программного кода



# ----------------------------------------------------------------------------------------------------------------------



# ======================================================================================================================
# 5.6 Посвящение в объектно-ориентированное программирование
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Посвящение в ООП
# Вы прошли серию испытаний и совершили множество подвигов, чтобы лицом к лицу столкнуться с настоящим
# вызовом, достойным лишь избранных! Для подтверждения своих знаний и навыков вам предлагается пройти этап посвящения
# в объектно-ориентированное программирование. И вот задание, которое выпало на вашу долю.
#
# Руководство компании целыми днями не знает куда себя деть. Поэтому они решили дать задание своим программистам
# написать программу игры "Морской бой". Но эта игра будет немного отличаться от классической. Для тех, кто не знаком
# с этой древней, как мир, игрой, напомню ее краткое описание.
#
# Каждый игрок у себя на бумаге рисует игровое поле 10 х 10 клеток и расставляет на нем десять
# кораблей: однопалубных - 4; двухпалубных - 3; трехпалубных - 2; четырехпалубный - 1.


# Корабли расставляются случайным образом, но так, чтобы не выходили за пределы игрового поля и не соприкасались друг
# с другом (в том числе и по диагонали).
#
# Затем, игроки по очереди называют клетки, куда производят выстрелы. И отмечают эти выстрелы на другом таком же поле
# в 10 х 10 клеток, которое представляет поле соперника. Соперник при этом должен честно отвечать: "промах", если ни
# один корабль не был задет и "попал", если произошло попадание. Выигрывает тот игрок, который первым поразит все
# корабли соперника.
#
# Но это была игра из глубокого прошлого. Теперь же, в компьютерную эру, корабли на игровом поле могут перемещаться в
# направлении своей ориентации на одну клетку после каждого хода соперника, если в них не было ни одного попадания.
#
# Итак, лично вам поручается сделать важный фрагмент этой игры - расстановку и управление кораблями в этой игре. А само
# задание звучит так.
#
# Техническое задание
# В программе необходимо объявить два класса:
#
# Ship - для представления кораблей;
# GamePole - для описания игрового поля.
#
# Класс Ship
# Класс Ship должен описывать корабли набором следующих параметров:
#
# x, y - координаты начала расположения корабля (целые числа);
# length - длина корабля (число палуб: целое значение: 1, 2, 3 или 4);
# tp - ориентация корабля (1 - горизонтальная; 2 - вертикальная).


# Объекты класса Ship должны создаваться командами:
#
# ship = Ship(length)
# ship = Ship(length, tp)
# ship = Ship(length, tp, x, y)
# По умолчанию (если не указывается) параметр tp = 1, а координаты x, y равны None.
#
# В каждом объекте класса Ship должны формироваться следующие локальные атрибуты:
#
# _x, _y - координаты корабля (целые значения в диапазоне [0; size), где size - размер игрового поля);
# _length - длина корабля (число палуб);
# _tp - ориентация корабля;
# _is_move - возможно ли перемещение корабля (изначально равно True);
# _cells - изначально список длиной length, состоящий из единиц (например, при length=3, _cells = [1, 1, 1]).
#
# Список _cells будет сигнализировать о попадании соперником в какую-либо палубу корабля. Если стоит 1, то попадания
# не было, а если стоит значение 2, то произошло попадание в соответствующую палубу.
#
# При попадании в корабль (хотя бы одну его палубу), флаг _is_move устанавливается в False и перемещение корабля по
# игровому полю прекращается.
#
# В самом классе Ship должны быть реализованы следующие методы (конечно, возможны и другие, дополнительные):
#
# set_start_coords(x, y) - установка начальных координат (запись значений в локальные атрибуты _x, _y);
# get_start_coords() - получение начальных координат корабля в виде кортежа x, y;
# move(go) - перемещение корабля в направлении его ориентации на go клеток (go = 1 - движение в одну сторону на
# клетку; go = -1 - движение в другую сторону на одну клетку); движение возможно только если флаг _is_move = True;
# is_collide(ship) - проверка на столкновение с другим кораблем ship (столкновением считается, если другой корабль или
# пересекается с текущим или просто соприкасается, в том числе и по диагонали); метод возвращает True, если
# столкновение есть и False - в противном случае;
# is_out_pole(size) - проверка на выход корабля за пределы игрового поля (size - размер игрового
# поля, обычно, size = 10); возвращается булево значение True, если корабль вышел из игрового поля и False - в
# противном случае;
#
# С помощью магических методов __getitem__() и __setitem__() обеспечить доступ к коллекции _cells следующим образом:
#
# value = ship[indx] # считывание значения из _cells по индексу indx (индекс отсчитывается от 0)
# ship[indx] = value # запись нового значения в коллекцию _cells
# Класс GamePole
# Следующий класс GamePole должен обеспечивать работу с игровым полем. Объекты этого класса создаются командой:
#
# pole = GamePole(size)
# где size - размеры игрового поля (обычно, size = 10).
#
# В каждом объекте этого класса должны формироваться локальные атрибуты:
#
# _size - размер игрового поля (целое положительное число);
# _ships - список из кораблей (объектов класса Ship); изначально пустой список.
#
# В самом классе GamePole должны быть реализованы следующие методы (возможны и другие, дополнительные методы):
#
# init() - начальная инициализация игрового поля; здесь создается список из кораблей (объектов класса Ship):
# однопалубных - 4; двухпалубных - 3; трехпалубных - 2; четырехпалубный - 1 (ориентация этих кораблей должна быть
# случайной).
#
# Корабли формируются в коллекции _ships следующим образом: однопалубных - 4; двухпалубных - 3; трехпалубных - 2;
# четырехпалубный - 1. Ориентация этих кораблей должна быть случайной. Для этого можно воспользоваться функцией
# randint следующим образом:
#
# [Ship(4, tp=randint(1, 2)), Ship(3, tp=randint(1, 2)), Ship(3, tp=randint(1, 2)), ...]
# Начальные координаты x, y не расставленных кораблей равны None.
#
# После этого, выполняется их расстановка на игровом поле со случайными координатами так, чтобы корабли не пересекались
# между собой.
#
# get_ships() - возвращает коллекцию _ships;
# move_ships() - перемещает каждый корабль из коллекции _ships на одну клетку (случайным образом вперед или назад) в
# направлении ориентации корабля; если перемещение в выбранную сторону невозможно (другой корабль или пределы игрового
# поля), то попытаться переместиться в противоположную сторону, иначе (если перемещения невозможны), оставаться на
# месте;
# show() - отображение игрового поля в консоли (корабли должны отображаться значениями из коллекции _cells каждого
# корабля, вода - значением 0);
#
# get_pole() - получение текущего игрового поля в виде двумерного (вложенного) кортежа размерами size x size элементов.
#
# Пример отображения игрового поля:
#
# 0 0 1 0 1 1 1 0 0 0
# 1 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 1 0 0 1
# 0 0 0 0 1 0 1 0 0 1
# 0 0 0 0 0 0 1 0 0 0
# 1 1 0 0 0 0 0 0 0 0
# 0 0 0 0 0 0 1 0 0 0
# 0 1 1 1 1 0 0 0 0 0
# 0 0 0 0 0 0 0 1 1 0
# Пример использования классов (эти строчки в программе не писать):
#
# SIZE_GAME_POLE = 10
#
# pole = GamePole(SIZE_GAME_POLE)
# pole.init()
# pole.show()
#
# pole.move_ships()
# print()
# pole.show()

# В программе требуется только объявить классы Ship и GamePole с соответствующим функционалом. На экран выводить
# ничего не нужно.
#
# P.S. Для самых преданных поклонников программирования и ООП. Завершите эту программу, добавив еще один класс
# SeaBattle для управления игровым процессом в целом. Игра должна осуществляться между человеком и компьютером.
# Выстрелы со стороны компьютера можно реализовать случайным образом в свободные клетки. Сыграйте в эту игру и
# выиграйте у компьютера.


from random import randint, choice
from itertools import product
from copy import deepcopy
from uuid import uuid4


class ShipError(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return self.message


class ShipDefender:
    """Не изменяет параметры корабля, если в процессе изменения возникла ошибка"""

    def __init__(self, ship):
        self._ship = ship

    def __enter__(self):
        self._temp_ship = deepcopy(self._ship)
        return self._temp_ship

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type is None:
            self._ship.__dict__ = self._temp_ship.__dict__
        return True


class Ship:
    def __init__(self, length, tp=1, x=None, y=None):
        """
        :param x: х-координата начала расположения корабля;
        :type x: int | None
        :param y: у-координата начала расположения корабля;
        :type y: int | None
        :param length: длина корабля (число палуб: целое значение: 1, 2, 3 или 4);
        :type length: int
        :param tp: ориентация корабля (1 - горизонтальная; 2 - вертикальная).
        :type tp: int
        """
        self._id = uuid4()  # для сравнения кораблей, помогает в self.move()
        self._x, self._y = None, None
        self._full_coords = None  # полные координаты
        self._area = None  # вся занимаемая площадь
        self._length = length
        self._tp = tp
        self._is_move = True
        self._cells = [1 for _ in range(self._length)]
        self._is_alive = True
        self.set_start_coords(x, y)

    def set_start_coords(self, x, y):
        """Установка начальных координат (запись значений в локальные атрибуты _x, _y)
        тут же считаем занимаемую площадь и координаты всех палуб"""
        self._x = x
        self._y = y
        self._calculate_full_coords()
        self._calculate_area()

    def get_start_coords(self) -> tuple:
        """Получение начальных координат корабля в виде кортежа x, y;"""
        return self._x, self._y

    def move(self, go=1):
        """Перемещение корабля в направлении его ориентации на go клеток
        движение возможно только если флаг _is_move = True;

        :param go: (go = 1 - движение вниз / вправо на 1 клетку;
        go = -1 - движение вверх / влево на 1 клетку);
        """
        if self._is_move:
            x, y = self._x, self._y
            if self._tp == 2:
                y += go
            else:
                x += go
            self.set_start_coords(x, y)

    def is_collide(self, ship) -> bool:
        """Проверка на столкновение с другим кораблем ship
        (столкновением считается, если другой корабль или пересекается с текущим или просто соприкасается,
        в том числе и по диагонали);
        метод возвращает True, если столкновение есть и False - в противном случае;"""
        if self == ship:
            return False
        if self.full_coords is None or ship.full_coords is None:
            return False
        ship1 = self.full_coords
        ship2 = ship.area + ship.full_coords
        return any(x in ship2 for x in ship1)

    def is_out_pole(self, size) -> bool:
        """Проверка на выход корабля за пределы игрового поля
        возвращается булево значение True, если корабль вышел из игрового поля и False - в противном случае;

        :param size: размер игрового поля, обычно, size = 10);"""
        if self._x is not None and self._y is not None:
            return any(x not in range(size) or y not in range(size) for x, y in self.full_coords)
        return False

    @property
    def full_coords(self):
        """Координаты всех палуб корабля"""
        return self._full_coords

    def _calculate_full_coords(self):
        """Вычисление координат всех палуб"""
        if hasattr(self, '_x') and hasattr(self, '_y') \
                and self._x is not None and self._y is not None:
            if self._tp == 2:
                ship_xs = [self._x for _ in range(self._length)]
                ship_ys = [*range(self._y, self._y + self._length)]
            else:
                ship_xs = [*range(self._x, self._x + self._length)]
                ship_ys = [self._y for _ in range(self._length)]
            self._full_coords = [*zip(ship_xs, ship_ys)]

    @property
    def area(self):
        """Занимаемая площадь, в которой не может быть другого корабля"""
        return self._area

    def _calculate_area(self):
        """Вычисление координат всех точек, в которых не может быть другого корабля"""
        if self.full_coords:
            area = []
            for x, y in self.full_coords:
                tmp_coords = []
                for dx, dy in product((-1, 0, 1), repeat=2):
                    if (x + dx, y + dy) not in self.full_coords:
                        tmp_coords.append((x + dx, y + dy))
                area.extend(tmp_coords)
            self._area = area

    def __getitem__(self, idx):
        return self._cells[idx]

    def __setitem__(self, idx, val):
        self._cells[idx] = val

    def __repr__(self):
        return f'Ship {self._length} ({"v" if self._tp == 2 else "h"}) {self.full_coords}'

    def __hash__(self):
        return hash(self._id)

    def __eq__(self, other):
        return hash(self) == hash(other)

    @property
    def is_alive(self):
        return any(x != 2 for x in self._cells)


class GamePole:
    COMMON_FLEET = [(4, 1), (3, 2), (2, 3), (1, 4)]
    place_ships_attempts = 0

    def __init__(self, size=10, fleet=None):
        """
        :param size: размер поля, по умолчанию 10
        :param fleet: список кортежей (палубы, корабли), по умолчанию - из значения класса COMMON_FLEET
        :type fleet: list[tuple[int, int]] | None
        """
        self._size = size
        self._ships = []
        self.__fleet = self.COMMON_FLEET if fleet is None else fleet

    def get_ships(self):
        return self._ships

    def init(self):
        """Заполнение игрового поля. Генерация и расстановка кораблей"""
        self.__gen_ships()
        self.__place_ships()

    def __gen_ships(self):
        """Генерирование кораблей"""
        for decks, quant in self.__fleet:
            self._ships.extend([Ship(decks, tp=randint(1, 2)) for _ in range(quant)])

    def __check_collide(self, ship):
        """Проверка столкновения корабля с другими кораблями флотилии"""
        for other_ship in self._ships:
            if ship.is_collide(other_ship):
                return True
        return False

    def __check_ship_position(self, ship):
        """Проверка выхода за пределы поля и столкновения с другими кораблями"""
        if ship.is_out_pole(self._size):
            raise ShipError('корабль за пределами поля')
        if self.__check_collide(ship):
            raise ShipError('корабли соприкасаются')

    def __place_ships(self):
        """Расстановка кораблей на поле, с учетом ограничений
        если за 100 попыток поставить корабль не удалось,
        сбрасываем расставленные корабли и начинаем заново"""
        try:
            placed_ships = 0
            bad_combination = False
            total_ships = len(self._ships)
            while placed_ships < total_ships and not bad_combination:  # пока расставлены не все корабли
                for ship in self._ships:
                    not_placed = True
                    attempts = 0
                    while not_placed:
                        attempts += 1
                        with ShipDefender(ship) as s:  # не изменяем корабль, пока нормально не встанет
                            x, y = (randint(0, self._size - 1) for _ in 'xy')
                            s.set_start_coords(x, y)
                            self.__check_ship_position(s)
                            not_placed = False
                            placed_ships += 1
                        if attempts > 100:  # если пытались поставить корабль 100 раз, прерываем цикл
                            bad_combination = True
                            self.place_ships_attempts += 1
                            break
                    if bad_combination: break
            if bad_combination:  # если не удалось поставить корабль, начинаем расставлять заново
                self._ships = []
                self.init()
        except RecursionError:  # если совсем не удается расставить корабли
            raise GamePoleError(f"""Ошибка!
Не смогли расставить корабли за {self.place_ships_attempts} попыток.
Измените размер поля или количество кораблей""")

    def move_ships(self):
        """Перемещает каждый корабль из коллекции _ships на одну клетку
        (случайным образом вперед или назад) в направлении ориентации корабля;
        если перемещение в выбранную сторону невозможно (другой корабль или пределы игрового поля),
        то попытаться переместиться в противоположную сторону, иначе (если перемещения невозможны),
        оставаться на месте"""
        for ship in self._ships:
            step = choice((1, -1))
            not_moved = True
            tries = 0
            while not_moved and tries < 2:
                with ShipDefender(ship) as s:
                    s.move(step)
                    self.__check_ship_position(s)
                    not_moved = False
                step = -step
                tries += 1

    def show(self):
        """Отображение игрового поля в консоли
        (корабли должны отображаться значениями из коллекции _cells каждого корабля,
        вода - значением 0);"""
        [print(*row) for row in self.get_pole()]

    def get_text_pole(self, hidden=False):
        """Возвращаем либо поле со всеми кораблями, либо только с подбитыми"""
        if hidden:
            pole = [['▒' if x == 2 else '░' for x in row] for row in self.get_pole()]
        else:
            pole = [['░' if x == 0 else '▓' if x == 1 else '▒' for x in row] for row in self.get_pole()]

        for ship in self._ships:  # mark area around killed ships
            if not ship.is_alive:
                for row, col in ship.area:
                    if row in range(self._size) and col in range(self._size):
                        pole[row][col] = '·'
        return pole

    def get_pole(self):
        """Получение текущего игрового поля в виде двумерного (вложенного)
        кортежа размерами size x size элементов."""
        pole = [[0 for _ in range(self._size)] for _ in range(self._size)]
        for ship in self._ships:
            for coords, deck in zip(ship.full_coords, ship._cells):
                row, col = coords
                pole[row][col] = deck
        return tuple(map(tuple, pole))

    def check_hit(self, x, y):
        """Проверяем попали ли в корабль"""
        for ship in self._ships:
            if (x, y) in ship.full_coords:
                ship._is_move = False
                idx = ship.full_coords.index((x, y))
                ship._cells[idx] = 2
                if ship.is_alive:
                    return 1  # ранен
                else:
                    return 2  # убит
        return 0  # мимо

    @property
    def is_alive_ships(self):
        return any(ship.is_alive for ship in self._ships)


class SeaBattle:
    def __init__(self, size=None, fleet=None, hide_pc_pole=True):
        self._size = size if size else 10
        self._human, self._pc = (GamePole(self._size, fleet) for _ in '12')
        self._human.init()
        self._pc.init()
        self._hide_pc_pole = hide_pc_pole  # показывать или нет поле компьютера (чит)
        self._game_over = False
        self._human_turn = True
        self._human_hit_ship_cells = set()  # координаты попадания в корабль человеком
        self._pc_hit_ship_cells = set()  # координаты попадания в корабль компьютером
        self._pc_last_hit = None  # координаты последнего попадание компьютера
        self._pc_try_to_kill = set()  # координаты сделанных выстрелов вокруг последнего попадания
        self._pc_already_hit = set()  # уже обстрелянные компьютером ячейки, периодически обнуляются

    @property
    def game_over(self):
        return self._game_over

    def input_coords(self):
        try:
            x, y = tuple(map(int, input('=> input x, y (separated by space): ').split()))
            if any(i not in range(self._size) for i in (x, y)):
                raise IndexError(f'x or y is out of pole. It should be from 0 to {self._size - 1}')
            if (x, y) in self._human_hit_ship_cells:
                raise IndexError('cell has been shot already and some ship has been hit')
            return x, y
        except IndexError as e:
            print(e)
            return False
        except ValueError as e:
            print(f'Input error ({e}), try again')
            return False

    def do_hit(self, x, y, human_hit) -> int:
        """Делаем выстрел, печатаем результат, проверяем окончание игры,
        возвращаем цифровой результат выстрела 0 - мимо, 1 - ранил, 2 - убил"""
        hit_text = {0: 'Missed', 1: 'Wounded', 2: 'Killed'}
        hit_pole = self._pc if human_hit else self._human
        hit_result = hit_pole.check_hit(x, y)
        print(f'{"Human" if human_hit else "PC"} hit at {(x, y)} and', hit_text.get(hit_result))
        self._game_over = not hit_pole.is_alive_ships
        return hit_result

    def hit(self):
        print("-" * 50)
        winner = ''
        if self._human_turn:
            self._human_go()
            if self._game_over:
                winner = 'Human'
            else:
                self._pc.move_ships()
                self.show_poles()
        else:
            self._pc_go()
            if self._game_over:
                winner = 'Computer'
            else:
                self._human.move_ships()
        if self._game_over:
            print(f'{"=" * 10} Game Over {"=" * 10}')
            self.show_poles()
            print(f'{"=" * 10} {winner} wins {"=" * 10}'.upper())

    def show_poles(self):
        """Выводим на печать оба поля рядом"""
        human_pole = self._human.get_text_pole()
        pc_pole = self._pc.get_text_pole(hidden=self._hide_pc_pole)
        num_head = ' '.join(map(str, range(self._size)))
        num_head_str = f'{" " * 3}{num_head}{" " * (7 if self._size > 10 else 8)}{num_head}'
        human = f'{"human":^{len(num_head_str) // 2}}'
        pc = f'{"computer":^{len(num_head_str) // 2 + 5}}'
        print(f'{human} {pc}')
        print(num_head_str)
        for i, rows in enumerate(zip(human_pole, pc_pole)):
            h, p = rows
            print(f'{i:>2}', *h, f'{" " * 3}', f'{i:>2}', *p)

    def _human_go(self):
        coords = None
        while not coords:
            coords = self.input_coords()
        x, y = coords
        hit = self.do_hit(x, y, human_hit=True)
        if not hit:  # если не попали - передаем ход
            self._human_turn = False
        else:
            self._human_hit_ship_cells.add((x, y))
            if hit == 2:  # если убили
                for ship in self._pc.get_ships():  # исключаем из стрельбы ячейки вокруг убитого корабля
                    if not ship.is_alive:
                        self._human_hit_ship_cells.update(ship.area)

    def _pc_go(self):
        """Выстрел компьютера. Для придания хоть какой-то осмысленности его действиям:
        сохраняем координаты попадания и стреляем вокруг них, пока хоть кого нибудь не убьем.
        Чтобы особо часто в одно место не стрелял - заносим координаты выстрела в сет,
        сет периодически обнуляем. Постоянно храним только координаты попадания в корабль"""
        attempts = 0
        if self._pc_last_hit is not None:
            x, y = self._pc_last_hit
            while (x, y) in self._pc_try_to_kill \
                    or (x, y) in self._pc_hit_ship_cells \
                    or (x, y) in self._pc_already_hit:
                x = randint(max(0, x - 3), min(self._size - 1, x + 3))
                y = randint(max(0, y - 3), min(self._size - 1, y + 3))
                attempts += 1
                if attempts > 15:
                    self._pc_already_hit = set()
            self._pc_try_to_kill.add((x, y))
        else:
            x, y = (randint(0, self._size - 1) for _ in 'xy')
            while (x, y) in self._pc_hit_ship_cells or (x, y) in self._pc_already_hit:
                x, y = (randint(0, self._size - 1) for _ in 'xy')
                attempts += 1
                if attempts > 15:  # если долго не удается подобрать координаты
                    self._pc_already_hit = set()  # обнуляем сет ячеек в которые стреляли
        hit = self.do_hit(x, y, human_hit=False)
        self._pc_already_hit.add((x, y))
        if not hit:  # если не попали, передаем ход
            self._human_turn = True
        else:
            self._pc_hit_ship_cells.add((x, y))
            if hit == 2:
                for ship in self._human.get_ships():  # исключаем из стрельбы ячейки вокруг убитого корабля
                    if not ship.is_alive:
                        self._pc_hit_ship_cells.update(ship.area)
                self._pc_last_hit = None  # если убили, обнуляем последнее попадание
                self._pc_try_to_kill = set()  # и обстрелянные ячейки
            else:
                if self._pc_last_hit is None:  # если ранили и не было последнего попадания
                    self._pc_last_hit = (x, y)  # сохраняем координаты


def battle():
    """Можно указать размер поля и какие корабли расставлять
    можно подглядеть поле компьютера"""
    # size = 7
    # ships = [(2, 2), (3, 2), (1, 4)]    # 2 - двухпалубных, 2 - трехпалубных, 4 - однопалубных
    # hide_pc_pole = False                # открывает поле компьютера
    # sea_battle = SeaBattle(size, ships, hide_pc_pole=hide_pc_pole)

    sea_battle = SeaBattle()  # ну или со значениями по умолчанию

    while not sea_battle.game_over:
        sea_battle.hit()


if __name__ == '__main__':
    battle()



# ======================================================================================================================
# FINISH COURSE
# ======================================================================================================================