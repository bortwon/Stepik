# Добрый, добрый Python ООП - обучающий курс от Сергея Балакирева
# ======================================================================================================================
# 1. ПЕРВЫЕ ШАГИ В ООП.

# ----------------------------------------------------------------------------------------------------------------------
# 1.2 Концепция ООП простыми словами


# Подвиг 1. Что составляет основу ООП?
# - инкапсуляция
# - наследование
# - полиморфизм

# Подвиг 2. Как следует воспринимать класс в ООП?
# - как шаблон, по которому конструируются объекты этого класса

# Подвиг 3. В чем суть идеи наследования в ООП?
# - на основе одного или нескольких классов создается новый (дочерний) класс
# - наследование позволяет как бы вынести «за скобки» общее для разных классов

# Подвиг 4. Можно ли создавать программы без использования ООП?
# - да, например, используя парадигму структурного программирования (не включая ООП)

# Подвиг 5. Вам предстоит написать программу хранения информации по книгам: автор, заголовок, год издания, число
# страниц. Помогут ли здесь классы для представления этой разнородной информации?
# - да, описать каждую книгу как объект класса "Книга" хорошая идея

# Подвиг 6. Каким термином из ООП можно охарактеризовать ограничение доступа к элементам класса?
# - инкапсуляция

# Подвиг 7. Вам предстоит создать программу несложного графического редактора с рисованием различных графических
# примитивов (линия, прямоугольник, эллипс, треугольник и т.п.). Будет ли иметь смысл использовать при ее реализации
# концепцию ООП?
# - да, ООП здесь может заметно упростить программный код

# Подвиг 8. Каким термином из ООП можно охарактеризовать универсальность интерфейса доступа к разным типам данных?
# - полиморфизм


# ---------------------------------------------------------------------------------------------------------------------
# 1.3. Классы и объекты. Атрибуты классов и объектов

# setattr(Point, 'prop', 1) - функция создает новый атрибут в указанном пространстве имен(в данном случае в классе
# Point) с заданным значением.

# getattr(Point, 'a', False) - функция для обращения к тому или иному атрибуту класса, ей пользуются только в том
# случае, если есть опасность обращения к несуществующим атрибутам.

# delattr(Point, 'type_pt') - функция для удаления атрибута.

# hasattr(Point, 'prop') - проверка существования того или иного свойства атрибута.


# Подвиг 1. Отметьте все верные, с точки зрения стандарта PEP8, имена классов.
# - DataBase
# - SergeyBalakirev
# - Data123

# Подвиг 2. Выберите утверждения справедливые для классов языка Python.
# - Каждый класс (объявленный в программе) можно воспринимать как новый (пользовательский) тип данных.
# - Класс описывает шаблон для формирования его объектов.
# - Класс образует пространство имен для переменных и методов, объявленных в нем.


# Подвиг 3. Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12

# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими
# значениями.

class DataBase:
    pk = 1
    title = 'Классы и объекты'
    author = 'Сергей Балакирев'
    views = 14356
    comments = 12


# Подвиг 4. Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
#
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:
#
# inflation: 100

class Goods:
    title = 'Мороженое'
    weight = 154
    tp = 'Еда'
    price = 1024
Goods.price = 2048
setattr(Goods, 'inflation', 100)


# Подвиг 5. Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"

# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.

class Car:
    pass
setattr(Car, 'model', 'Тойота')
setattr(Car, 'color', 'Розовый')
setattr(Car, 'number', 'П111УУ77')
print(Car.__dict__['color'])


# Подвиг 6. Объявите класс с именем Notes и определите в нем следующие атрибуты:
#
# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

class Notes:
    uid = 1005435
    title = 'Шутка'
    author = 'И.С. Бах'
    pages = 2
res = getattr(Notes, 'author')
print(res)


# Подвиг 7. Объявите класс с именем Dictionary и определите в нем следующие атрибуты:
#
# rus: "Питон"
# eng: "Python"

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в
# классе нет, то функция getattr() должна возвращать булево значение False.

class Dictionary:
    rus = "Питон"
    eng = "Python"

print(getattr(Dictionary, 'rus_word', False))


# Подвиг 8. Объявите класс с именем TravelBlog и объявите в нем атрибут:
#
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
#
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
#
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
#
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

class TravelBlog:
    total_blogs = 0


tb1 = TravelBlog()
tb1.name = 'Франция'
tb1.days = 6
TravelBlog.total_blogs += 1
tb2 = TravelBlog()
tb2.name = 'Италия'
tb2.days = 5
TravelBlog.total_blogs += 1


class TravelBlog:
    total_blogs = 0

    def __init__(self, name, days):
        self.name = name
        self.days = days
        TravelBlog.total_blogs += 1


tb1 = TravelBlog('Франция', 6)
tb2 = TravelBlog('Италия', 5)


# Подвиг 9. Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'

# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:

# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'

# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта
# fig1 в одну строчку через пробел в порядке, указанном в задании.

class Figure:
    type_fig = 'ellipse'
    color = 'red'

fig1 = Figure()
fig1.start_pt = (10, 5)
fig1.end_pt = (100, 20)
fig1.color = 'blue'
delattr(fig1, 'color')
print(*fig1.__dict__.keys())


# Подвиг 10. Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'

# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите
# True, если оно присутствует в объекте p1 и False - если отсутствует.

class Person:
    name = 'Сергей Балакирев'
    job = 'Программист'
    city = 'Москва'

p1 = Person()
print('job' in p1.__dict__)


# Подвиг 11. Выберите верное значение атрибута, которое будет выведено на экран при выполнении следующей программы:
#
# class Figures:
#     type = 'ellipse'
#     color = 'red'
#
#
# fig1 = Figures()
# print(fig1.color)

# - red


# Подвиг 12. Установите соответствия между функциями и их описаниями.

# setattr() - позволяет создавать новый атрибут или устанавливать значение уже существующего в классе или объекте
# getattr() - позволяет получать значение указанного атрибута из класса или объекта
# hasattr() - позволяет проверять атрибут на наличие в классе или объекте
# delattr() - позволяет удалять атрибут в классе или объекте


# Подвиг 13. Выберите верные способы удаления атрибута tp из класса Point.
# - delattr(Point, 'tp')
# - del Point.tp

# Подвиг 14. В программе объявлен следующий класс:
#
# class Magazine:
#     name = 'Наука и жизнь'
#     price = 1101
# Что произойдет при выполнении команды:
# print(getattr(Magazine, 'id'))


# - Ошибка, так как атрибут id отсутствует в классе Magazine