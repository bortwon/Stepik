# Добрый, добрый Python ООП - обучающий курс от Сергея Балакирева
# ======================================================================================================================
# 1. ПЕРВЫЕ ШАГИ В ООП.

# ----------------------------------------------------------------------------------------------------------------------
# 1.2 Концепция ООП простыми словами


# Подвиг 1. Что составляет основу ООП?
# - инкапсуляция
# - наследование
# - полиморфизм

# Подвиг 2. Как следует воспринимать класс в ООП?
# - как шаблон, по которому конструируются объекты этого класса

# Подвиг 3. В чем суть идеи наследования в ООП?
# - на основе одного или нескольких классов создается новый (дочерний) класс
# - наследование позволяет как бы вынести «за скобки» общее для разных классов

# Подвиг 4. Можно ли создавать программы без использования ООП?
# - да, например, используя парадигму структурного программирования (не включая ООП)

# Подвиг 5. Вам предстоит написать программу хранения информации по книгам: автор, заголовок, год издания, число
# страниц. Помогут ли здесь классы для представления этой разнородной информации?
# - да, описать каждую книгу как объект класса "Книга" хорошая идея

# Подвиг 6. Каким термином из ООП можно охарактеризовать ограничение доступа к элементам класса?
# - инкапсуляция

# Подвиг 7. Вам предстоит создать программу несложного графического редактора с рисованием различных графических
# примитивов (линия, прямоугольник, эллипс, треугольник и т.п.). Будет ли иметь смысл использовать при ее реализации
# концепцию ООП?
# - да, ООП здесь может заметно упростить программный код

# Подвиг 8. Каким термином из ООП можно охарактеризовать универсальность интерфейса доступа к разным типам данных?
# - полиморфизм


# ---------------------------------------------------------------------------------------------------------------------
# 1.3. Классы и объекты. Атрибуты классов и объектов

# setattr(Point, 'prop', 1) - функция создает новый атрибут в указанном пространстве имен(в данном случае в классе
# Point) с заданным значением.

# getattr(Point, 'a', False) - функция для обращения к тому или иному атрибуту класса, ей пользуются только в том
# случае, если есть опасность обращения к несуществующим атрибутам.

# delattr(Point, 'type_pt') - функция для удаления атрибута.

# hasattr(Point, 'prop') - проверка существования того или иного свойства атрибута.


# Подвиг 1. Отметьте все верные, с точки зрения стандарта PEP8, имена классов.
# - DataBase
# - SergeyBalakirev
# - Data123

# Подвиг 2. Выберите утверждения справедливые для классов языка Python.
# - Каждый класс (объявленный в программе) можно воспринимать как новый (пользовательский) тип данных.
# - Класс описывает шаблон для формирования его объектов.
# - Класс образует пространство имен для переменных и методов, объявленных в нем.


# Подвиг 3. Объявите класс с именем DataBase, который бы хранил в себе следующую информацию:

# pk: 1
# title: "Классы и объекты"
# author: "Сергей Балакирев"
# views: 14356
# comments: 12

# Имена переменных (атрибутов класса) используйте такие же (pk, title, author, views и comments) с соответствующими
# значениями.

class DataBase:
    pk = 1
    title = 'Классы и объекты'
    author = 'Сергей Балакирев'
    views = 14356
    comments = 12


# Подвиг 4. Объявите класс с именем Goods и пропишите в нем следующие атрибуты (переменные):
#
# title: "Мороженое"
# weight: 154
# tp: "Еда"
# price: 1024
# Затем, после объявления класса, измените его атрибут price на значение 2048 и добавьте еще один атрибут:
#
# inflation: 100

class Goods:
    title = 'Мороженое'
    weight = 154
    tp = 'Еда'
    price = 1024
Goods.price = 2048
setattr(Goods, 'inflation', 100)


# Подвиг 5. Объявите пустой класс с именем Car. С помощью функции setattr() добавьте в этот класс атрибуты:

# model: "Тойота"
# color: "Розовый"
# number: "П111УУ77"

# Выведите на экран значение атрибута color, используя словарь __dict__ класса Car.

class Car:
    pass
setattr(Car, 'model', 'Тойота')
setattr(Car, 'color', 'Розовый')
setattr(Car, 'number', 'П111УУ77')
print(Car.__dict__['color'])


# Подвиг 6. Объявите класс с именем Notes и определите в нем следующие атрибуты:
#
# uid: 1005435
# title: "Шутка"
# author: "И.С. Бах"
# pages: 2

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута author.

class Notes:
    uid = 1005435
    title = 'Шутка'
    author = 'И.С. Бах'
    pages = 2
res = getattr(Notes, 'author')
print(res)


# Подвиг 7. Объявите класс с именем Dictionary и определите в нем следующие атрибуты:
#
# rus: "Питон"
# eng: "Python"

# Затем, с помощью функции getattr() прочитайте и выведите на экран значение атрибута rus_word. Если такого атрибута в
# классе нет, то функция getattr() должна возвращать булево значение False.

class Dictionary:
    rus = "Питон"
    eng = "Python"

print(getattr(Dictionary, 'rus_word', False))


# Подвиг 8. Объявите класс с именем TravelBlog и объявите в нем атрибут:
#
# total_blogs: 0
# Создайте экземпляр этого класса с именем tb1, сформируйте в нем два локальных свойства:
#
# name: 'Франция'
# days: 6
# Увеличьте значение атрибута total_blogs класса TravelBlog на единицу.
#
# Создайте еще один экземпляр класса TravelBlog с именем tb2, сформируйте в нем два локальных свойства:
#
# name: 'Италия'
# days: 5
# Увеличьте значение атрибута total_blogs класса TravelBlog еще на единицу.
#
# P.S. На экран ничего выводить не нужно.

class TravelBlog:
    total_blogs = 0


tb1 = TravelBlog()
tb1.name = 'Франция'
tb1.days = 6
TravelBlog.total_blogs += 1
tb2 = TravelBlog()
tb2.name = 'Италия'
tb2.days = 5
TravelBlog.total_blogs += 1


class TravelBlog:
    total_blogs = 0

    def __init__(self, name, days):
        self.name = name
        self.days = days
        TravelBlog.total_blogs += 1


tb1 = TravelBlog('Франция', 6)
tb2 = TravelBlog('Италия', 5)


# Подвиг 9. Объявите класс с именем Figure и двумя атрибутами:
#
# type_fig: 'ellipse'
# color: 'red'

# Создайте экземпляр с именем fig1 этого класса и добавьте в него следующие локальные атрибуты:

# start_pt: (10, 5)
# end_pt: (100, 20)
# color: 'blue'

# Удалите из экземпляра класса свойство color и выведите на экран список всех локальных свойств (без значений) объекта
# fig1 в одну строчку через пробел в порядке, указанном в задании.

class Figure:
    type_fig = 'ellipse'
    color = 'red'

fig1 = Figure()
fig1.start_pt = (10, 5)
fig1.end_pt = (100, 20)
fig1.color = 'blue'
delattr(fig1, 'color')
print(*fig1.__dict__.keys())


# Подвиг 10. Объявите класс с именем Person и атрибутами:
#
# name: 'Сергей Балакирев'
# job: 'Программист'
# city: 'Москва'

# Создайте экземпляр p1 этого класса и проверьте, существует ли у него локальное свойство с именем job. Выведите
# True, если оно присутствует в объекте p1 и False - если отсутствует.

class Person:
    name = 'Сергей Балакирев'
    job = 'Программист'
    city = 'Москва'

p1 = Person()
print('job' in p1.__dict__)


# Подвиг 11. Выберите верное значение атрибута, которое будет выведено на экран при выполнении следующей программы:
#
# class Figures:
#     type = 'ellipse'
#     color = 'red'
#
#
# fig1 = Figures()
# print(fig1.color)

# - red


# Подвиг 12. Установите соответствия между функциями и их описаниями.

# setattr() - позволяет создавать новый атрибут или устанавливать значение уже существующего в классе или объекте
# getattr() - позволяет получать значение указанного атрибута из класса или объекта
# hasattr() - позволяет проверять атрибут на наличие в классе или объекте
# delattr() - позволяет удалять атрибут в классе или объекте


# Подвиг 13. Выберите верные способы удаления атрибута tp из класса Point.
# - delattr(Point, 'tp')
# - del Point.tp

# Подвиг 14. В программе объявлен следующий класс:
#
# class Magazine:
#     name = 'Наука и жизнь'
#     price = 1101
# Что произойдет при выполнении команды:
# print(getattr(Magazine, 'id'))


# - Ошибка, так как атрибут id отсутствует в классе Magazine

# ----------------------------------------------------------------------------------------------------------------------
# 1.4. Методы классов. Параметр self

# Подвиг 1. Что называется методом класса?
# - Любая (не статическая) функция, объявленная внутри класса


# Подвиг 2. Что называют атрибутами класса?
# - Переменные и имена методов (ссылки на методы) класса


# Подвиг 3. Какую роль играет параметр self в методах класса?
# - это ссылка на объект класса, из которого был вызван метод



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/AbMOpQSt1fA
# Подвиг 4. Объявите класс с именем MediaPlayer с двумя методами:
#
# open(file) - для открытия медиа-файла с именем file (создает локальное свойство filename со значением аргумента file в объекте класса MediaPlayer)
# play() - для воспроизведения медиа-файла (выводит на экран строку "Воспроизведение <название медиа-файла>")
#
# Создайте два экземпляра этого класса с именами: media1 и media2. Вызовите из них метод open() с аргументом "filemedia1" для объекта media1 и "filemedia2" для объекта media2. После этого вызовите через объекты метод play(). При этом, на экране должно отобразиться две строки (без кавычек):
#
# "Воспроизведение filemedia1"
# "Воспроизведение filemedia2"

class MediaPlayer:

    def open(self, file):
        self.filename = file

    def play(self):
        print(f'Воспроизведение {self.filename}')


media1 = MediaPlayer()
media2 = MediaPlayer()
media1.open('filemedia1')
media2.open('filemedia2')
media1.play()
media2.play()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/XNbphw3bYAI
# Подвиг 5. Объявите класс с именем Graph и методами:
#
# set_data(data) - передача набора данных data для последующего отображения (data - список числовых данных);
# draw() - отображение данных (в том же порядке, что и в списке data)
#
# и атрибутом:
#
# LIMIT_Y = [0, 10]
#
# Метод set_data() должен формировать локальное свойство data объекта класса Graph. Атрибут data должен ссылаться на
# переданный в метод список. Метод draw() должен выводить на экран список в виде строки из чисел, разделенных
# пробелами и принадлежащие заданному диапазону атрибута LIMIT_Y (границы включаются).
#
# Создайте объект graph_1 класса Graph, вызовите для него метод set_data() и передайте список:
#
# [10, -5, 100, 20, 0, 80, 45, 2, 5, 7]
#
# Затем, вызовите метод draw() через объект graph_1. На экране должна появиться строка с соответствующим набором
# чисел, записанных через пробел. Например (вывод без кавычек):
#
# "10 0 2 5 7"

class Graph:
    LIMIT_Y = [0, 10]

    def set_data(self, data):
        self.data = data

    def draw(self):
        print(*filter(lambda x: self.LIMIT_Y[0] <= x <= self.LIMIT_Y[1], self.data))


graph_1 = Graph()
graph_1.set_data([10, -5, 100, 20, 0, 80, 45, 2, 5, 7])
graph_1.draw()



# Подвиг 6. Имеется следующий класс:
#
# class Stepik:
#     def next_task(self):
#         return "Следующее задание"
# И создается объект этого класса:
#
# my_st = Stepik()

# Выберите все верные варианты вызова метода next_task()
# - my_st.next_task()
# - Stepik.next_task(my_st)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/IxXtZXrnnDY
# Подвиг 7. Имеется следующий класс для считывания информации из входного потока:
#
# import sys
#
#
# class StreamReader:
#     FIELDS = ('id', 'title', 'pages')
#
#     def readlines(self):
#         lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
#         sd = StreamData()
#         res = sd.create(self.FIELDS, lst_in)
#         return sd, res

# Которым, затем, можно воспользоваться следующим образом:
#
# sr = StreamReader()
# data, result = sr.readlines()

# Необходимо перед классом StreamReader объявить еще один класс StreamData с методом:
#
# def create(self, fields, lst_values): ...
#
# который бы на входе получал кортеж FIELDS из названий локальных атрибутов (передается в атрибут fields) и список строк lst_in (передается в атрибут lst_values) и формировал бы в объекте класса StreamData локальные свойства с именами полей из fields и соответствующими значениями из lst_values.
#
# Если создание локальных свойств проходит успешно, то метод create() возвращает True, иначе - False. Если число полей и число строк не совпадает, то метод create() возвращает False и локальные атрибуты создавать не нужно.
#
# P.S. В программе нужно дополнительно объявить только класс StreamData. Больше ничего делать не нужно.
#
# Пример входной информации (Sample Input):
#
# 10
# Питон - основы мастерства
# 512


import sys


# здесь объявляется класс StreamData

class StreamData:
    def create(self, fields, lst_values):
        if len(fields) != len(lst_values):
            return False
        else:
            for x in list(zip(fields, lst_values)):
                setattr(self, str(x[0]), x[1])
            return True


class StreamReader:
    FIELDS = ('id', 'title', 'pages')

    def readlines(self):
        lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
        sd = StreamData()
        res = sd.create(self.FIELDS, lst_in)
        return sd, res


sr = StreamReader()
data, result = sr.readlines()


# Подвиг 8. В программе объявлен класс:
#
# class String:
#     is_empty = False
# А, затем, создаются два его экземпляра:
#
# s1 = String()
# s2 = String()
# После этого выполняется команда:
#
# s2.is_empty = True

# Выберите верные утверждения, связанные с этой программой.
# - Значение s1.is_empty будет по-прежнему False, а значение s2.is_empty примет новое значение True
# - Переменная a = s1.is_empty будет ссылаться на атрибут is_empty класса String
# - Переменная b = s2.is_empty будет ссылаться на локальный атрибут is_empty объекта s2
# - Последняя команда создаст локальное свойство is_empty со значением True в экземпляре s2



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ljahVEppmxM
# Подвиг 9. Из входного потока читаются строки данных с помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока
# в формате: id, name, old, salary (записанные через пробел). Например:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200
# ...
#
# То есть, каждая строка - это элемент списка lst_in.
#
# Необходимо в класс DataBase:
#
# class DataBase:
#     lst_data = []
#     FIELDS = ('id', 'name', 'old', 'salary')
# добавить два метода:
#
# select(self, a, b) - возвращает список из элементов списка lst_data в диапазоне [a; b] (включительно) по их индексам
# (не id, а индексам списка); также учесть, что граница b может превышать длину списка.
# insert(self, data) - для добавления в список lst_data новых данных из переданного списка строк data;
#
# Каждая запись в списке lst_data должна быть представлена словарем в формате:
#
# {'id': 'номер', 'name': 'имя', 'old': 'возраст', 'salary': 'зарплата'}
#
# Например:
#
# {'id': '1', 'name': 'Сергей', 'old': '35', 'salary': '120000'}
#
# Примечание: в этой задаче число элементов в строке (разделенных пробелом) всегда совпадает с числом полей в
# коллекции FIELDS.
#
# P. S. Ваша задача только добавить два метода в класс DataBase.
#
# Sample Input:
#
# 1 Сергей 35 120000
# 2 Федор 23 12000
# 3 Иван 13 1200


import sys

# программу не менять, только добавить два метода
lst_in = list(map(str.strip, sys.stdin.readlines()))  # считывание списка строк из входного потока


class DataBase:
    lst_data = []
    FIELDS = ('id', 'name', 'old', 'salary')

    # здесь добавлять методы
    def select(self, a, b):
        return self.lst_data[a: b + 1]

    def insert(self, data):
        for i in data:
            self.lst_data.append(dict(zip(self.FIELDS, i.split())))


db = DataBase()
db.insert(lst_in)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/butyKEUntK0
# Подвиг 10. Объявите класс с именем Translator (для перевода с английского на русский) со следующими методами:
#
# add(self, eng, rus) - для добавления новой связки английского и русского слова (если английское слово уже существует,
# то новое русское слово добавляется как синоним для перевода, например, go - идти, ходить, ехать); если связка eng-rus
# уже существует, то второй раз ее добавлять не нужно, например:  add('go', 'идти'), add('go', 'идти');
# remove(self, eng) - для удаления связки по указанному английскому слову;
# translate(self, eng) - для перевода с английского на русский (метод должен возвращать список из русских
# слов, соответствующих переводу английского слова, даже если в списке всего одно слово).
#
# Все добавления и удаления связок должны выполняться внутри каждого конкретного объекта класса Translator, т.е.
# связки хранить локально внутри экземпляров классов класса Translator.
#
# Создайте экземпляр tr класса Translator и вызовите метод add для следующих связок:
#
# tree - дерево
# car - машина
# car - автомобиль
# leaf - лист
# river - река
# go - идти
# go - ехать
# go - ходить
# milk - молоко
#
# Затем методом remove() удалите связку для английского слова car. С помощью метода translate() переведите слово go.
# Результат выведите на экран в виде строки из всех русских слов, связанных со словом go:
#
# Вывод в формате: идти ехать ходить


class Translator:
    res = {}

    def add(self, eng, rus):
        if eng in self.res.keys():
            if rus not in self.res[eng]:
                self.res[eng].append(rus)
        else:
            self.res[eng] = [rus]

    def remove(self, eng):
        del self.res[eng]

    def translate(self, eng):
        return self.res[eng]


tr = Translator()
tr.add("tree", "дерево")
tr.add("car", "машина")
tr.add("car", "автомобиль")
tr.add("leaf", "лист")
tr.add("river", "река")
tr.add("go", "идти")
tr.add("go", "ехать")
tr.add("go", "ходить")
tr.add("milk", "молоко")

tr.remove('car')
print(*tr.translate('go'))


# ----------------------------------------------------------------------------------------------------------------------
# 1.5 Инициализатор __init__ и финализатор __del__


#Подвиг 1. Какой магический метод вызывается автоматически для инициализации объекта класса?
# - __init__()


# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/nT_sMhJsw1E
# Подвиг 2. Объявите класс Money так, чтобы объекты этого класса можно было создавать следующим образом:
#
# my_money = Money(100)
# your_money = Money(1000)
# Здесь при создании объектов указывается количество денег, которое должно сохраняться в локальном свойстве (атрибуте)
# money каждого экземпляра класса.
#
# P.S. На экран в программе ничего выводить не нужно.

class Money:
    def __init__(self, x = 0):
        self.money = x

my_money = Money(100)
your_money = Money(1000)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/DEyOq7Gpko4
# Подвиг 3. Объявите класс Point так, чтобы объекты этого класса можно было создавать командами:
#
# p1 = Point(10, 20)
# p2 = Point(12, 5, 'red')
# Здесь первые два значения - это координаты точки на плоскости (локальные свойства x, y), а третий необязательный
# ргумент - цвет точки (локальное свойство color). Если цвет не указывается, то он по умолчанию принимает значение
# black.
#
# Создайте тысячу таких объектов с координатами (1, 1), (3, 3), (5, 5), ... то есть, с увеличением на два для каждой
# новой точки. Каждый объект следует поместить в список points (по порядку). Для второго объекта в списке points
# укажите цвет 'yellow'.
#
# P.S. На экран в программе ничего выводить не нужно.


class Point:
    def __init__(self, x, y, color='black'):
        self.x = x
        self.y = y
        self.color = color


points = [Point(c, c) for c in range(1, 2000, 2)]

points[1].color = 'yellow'



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/bPH4It1_d0c
# Подвиг 4. Объявите три класса геометрических фигур: Line, Rect, Ellipse. Должна быть возможность создавать объекты
# каждого класса следующими командами:
#
# g1 = Line(a, b, c, d)
# g2 = Rect(a, b, c, d)
# g3 = Ellipse(a, b, c, d)
# Здесь в качестве аргументов a, b, c, d передаются координаты верхнего правого и нижнего левого углов (произвольные
# числа). В каждом объекте координаты должны сохраняться в локальных свойствах sp (верхний правый угол) и ep (нижний
# левый) в виде кортежей (a, b) и (c, d) соответственно.
#
# Сформируйте 217 объектов этих классов: для каждого текущего объекта класс выбирается случайно (или Line, или Rect,
# или Ellipse). Координаты также генерируются случайным образом (числовые значения). Все объекты сохраните в списке
# elements.
#
# В списке elements обнулите координаты объектов только для класса Line.
#
# P.S. На экран в программе ничего выводить не нужно.


import random

class Line:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Rect:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)

class Ellipse:
    def __init__(self, a, b, c, d):
        self.sp = (a, b)
        self.ep = (c, d)


elements = []
while len(elements) != 217:
    a, b, c, d = [random.randint(0, 9) for _ in range(4)]
    elements.append(random.choice([Line(0, 0, 0, 0), Rect(a, b, c, d), Ellipse(a, b, c, d)]))



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Vr4c1LgE91o
# Подвиг 5. Объявите класс TriangleChecker, объекты которого можно было бы создавать командой:
#
# tr = TriangleChecker(a, b, c)
# Здесь a, b, c - длины сторон треугольника.
#
# В классе TriangleChecker необходимо объявить метод is_triangle(), который бы возвращал следующие коды:
#
# 1 - если хотя бы одна сторона не число (не float или int) или хотя бы одно число меньше или равно нулю;
# 2 - указанные числа a, b, c не могут являться длинами сторон треугольника;
# 3 - стороны a, b, c образуют треугольник.
#
# Проверку параметров a, b, c проводить именно в таком порядке.
#
# Прочитайте из входного потока строку, содержащую три числа, разделенных пробелами, командой:
#
# a, b, c = map(int, input().split())
# Затем, создайте объект tr класса TriangleChecker и передайте ему прочитанные значения a, b, c. Вызовите метод
# is_triangle() из объекта tr и выведите результат на экран (код, который она вернет).
#
# Sample Input:
# 3 4 5

# Sample Output:
# 3


# здесь объявите класс TriangleChecker
class TriangleChecker:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def is_triangle(self):
        if not all(map(lambda x: type(x) in (int, float), [self.a, self.b, self.c])):
            return 1
        elif not all(map(lambda x: x > 0, [self.a, self.b, self.c])):
            return 1
        elif self.a >= self.b + self.c or self.b >= self.a + self.c or self.c >= self.a + self.b:
            return 2
        else:
            return 3


a, b, c = map(int, input().split())  # эту строчку не менять
# здесь создайте экземпляр tr класса TriangleChecker и вызовите метод is_triangle() с выводом информации на экран
tr = TriangleChecker(a, b, c)
print(tr.is_triangle())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/a3Har3Z_89Q
# Подвиг 6. Объявите класс Graph, объекты которого можно было бы создавать с помощью команды:
#
# gr_1 = Graph(data)
# где data - список из числовых данных (данные для графика). При создании каждого экземпляра класса должны формироваться следующие локальные свойства:
#
# data - ссылка на список из числовых данных (у каждого объекта должен быть свой список с данными, нужно создавать копию переданного списка);
# is_show - булево значение (True/False) для показа (True) и сокрытия (False) данных графика (по умолчанию True);
#
# В этом классе объявите следующие методы:
#
# set_data(self, data) - для передачи нового списка данных в текущий график;
# show_table(self) - для отображения данных в виде строки из списка чисел (числа следуют через пробел);
# show_graph(self) - для отображения данных в виде графика (метод выводит в консоль сообщение: "Графическое отображение данных: <строка из чисел следующих через пробел>");
# show_bar(self) - для отображения данных в виде столбчатой диаграммы (метод выводит в консоль сообщение: "Столбчатая диаграмма: <строка из чисел следующих через пробел>");
# set_show(self, fl_show) - метод для изменения локального свойства is_show на переданное значение fl_show.
#
# Если локальное свойство is_show равно False, то методы show_table(), show_graph() и show_bar() должны выводить сообщение:
#
# "Отображение данных закрыто"
#
# Прочитайте из входного потока числовые данные с помощью команды:
#
# data_graph = list(map(int, input().split()))
# Создайте объект gr класса Graph с набором прочитанных данных, вызовите метод show_bar(), затем метод set_show() со значением fl_show = False и вызовите метод show_table(). На экране должны отобразиться две соответствующие строки.
#
# Sample Input:
# 8 11 10 -32 0 7 18

# Sample Output:
# Столбчатая диаграмма: 8 11 10 -32 0 7 18
# Отображение данных закрыто


class Graph:

    def __init__(self, data, is_show = True):
        self.data = data[:]
        self.is_show = is_show

    def set_data(self, data):
        self.data = data
        return data

    def show_table(self):
        if self.is_show == True:
            return f'{" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_graph(self):
        if self.is_show == True:
            return f'Графическое отображение данных: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def show_bar(self):
        if self.is_show == True:
            return f'Столбчатая диаграмма: {" ".join(list(map(str, self.data)))}'
        else:
            return 'Отображение данных закрыто'

    def set_show(self, fl_show):
        self.is_show = fl_show

data_graph = list(map(int, input().split()))
gr = Graph(data=data_graph)
print(gr.show_bar())
gr.set_show(fl_show=False)
print(gr.show_table())



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZTCdEB_6h1I
# Подвиг 7. Объявите в программе следующие несколько классов:
#
# CPU - класс для описания процессоров;
# Memory - класс для описания памяти;
# MotherBoard - класс для описания материнских плат.
#
# Обеспечить возможность создания объектов каждого класса командами:
#
# cpu = CPU(наименование, тактовая частота)
# mem = Memory(наименование, размер памяти)
# mb = MotherBoard(наименование, процессор, память1, память2, ..., памятьN)
# Обратите внимание при создании объекта класса MotherBoard можно передавать несколько объектов класса Memory,
# максимум N - по числу слотов памяти на материнской плате (N = 4).
#
# Объекты классов должны иметь следующие локальные свойства:
#
# для класса CPU: name - наименование; fr - тактовая частота;
# для класса Memory: name - наименование; volume - объем памяти;
# для класса MotherBoard: name - наименование; cpu - ссылка на объект класса CPU; total_mem_slots = 4 - общее число
# слотов памяти (атрибут прописывается с этим значением и не меняется); mem_slots - список из объектов класса Memory
# (максимум total_mem_slots = 4 штук по максимальному числу слотов памяти).
#
# Класс MotherBoard должен иметь метод get_config(self) для возвращения текущей конфигурации компонентов на материнской
# плате в виде следующего списка из четырех строк:
#
# ['Материнская плата: <наименование>',
# 'Центральный процессор: <наименование>, <тактовая частота>',
# 'Слотов памяти: <общее число слотов памяти>',
# 'Память: <наименование_1> - <объем_1>; <наименование_2> - <объем_2>; ...; <наименование_N> - <объем_N>']
#
# Создайте объект mb класса MotherBoard с одним CPU (объект класса CPU) и двумя слотами памяти (объекты класса Memory).
#
# P.S. Отображать на экране ничего не нужно, только создать объект по указанным требованиям.


class CPU:

    def __init__(self, name, fr):
        self.name = name
        self.fr = fr


class Memory:

    def __init__(self, name, volume):
        self.name = name
        self.volume = volume


class MotherBoard:

    def __init__(self,  name, cpu,  *mems):
        self.name = name
        self.cpu = cpu
        self.total_mem_slots = 4
        self.mem_slots = mems[:self.total_mem_slots]

    def get_config(self):
        return [f'Материнская плата: {self.name}',
                f'Центральный процессор: {self.cpu.name}, {self.cpu.fr}',
                f'Слотов памяти: {self.total_mem_slots}',
                'Память: ' + "; ".join(map(lambda x: f"{x.name} - {x.volume}", self.mem_slots))]

mb = MotherBoard('', CPU('INTEL', 2000), Memory('Kingston', 2000))




# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HbtVara1GPI
# Подвиг 8. Объявите в программе класс Cart (корзина), объекты которого создаются командой:
#
# cart = Cart()
# Каждый объект класса Cart должен иметь локальное свойство goods - список объектов для покупки
# (объекты классов Table, TV, Notebook и Cup). Изначально этот список должен быть пустым.
#
# В классе Cart объявить методы:
#
# add(self, gd) - добавление в корзину товара, представленного объектом gd;
# remove(self, indx) - удаление из корзины товара по индексу indx;
# get_list(self) - получение из корзины товаров в виде списка из строк:
#
# ['<наименовние_1>: <цена_1>',
# '<наименовние_2>: <цена_2>',
# ...
# '<наименовние_N>: <цена_N>']
#
# Объявите в программе следующие классы для описания товаров:
#
# Table - столы;
# TV - телевизоры;
# Notebook - ноутбуки;
# Cup - кружки.
#
# Объекты этих классов должны создаваться командой:
#
# gd = ИмяКласса(name, price)
# Каждый объект классов товаров должен содержать локальные свойства:
#
# name - наименование;
# price - цена.
#
# Создайте в программе объект cart класса Cart. Добавьте в него два телевизора (TV), один стол (Table), два ноутбука
# (Notebook) и одну кружку (Cup). Названия и цены придумайте сами.
#
# P.S. Отображать на экране ничего не нужно, только создать объекты по указанным требованиям.


class Cart:

    def __init__(self, goods=[]):
        self.goods = goods

    def add(self, gd):
        self.goods.append(gd)

    def remove(self, indx):
        self.goods.remove(self.goods[indx])

    def get_list(self):
        return [f'{i.name}: {i.price}' for i in self.goods]


class Table:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class TV:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Notebook:

    def __init__(self, name, price):
        self.name = name
        self.price = price


class Cup:

    def __init__(self, name, price):
        self.name = name
        self.price = price


cart = Cart()
tv1 = TV('Samsung', 11000)
table = Table('IKEA', 5000)
notebook = Notebook('Mac', 100000)
notebook2 = Notebook('HP', 50000)
cup = Cup('Best Mommy', 500)

cart.add(tv1)
cart.add(tv1)
cart.add(table)
cart.add(notebook)
cart.add(notebook2)
cart.add(cup)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/3WfWCBKRKIM
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 9. Вам необходимо реализовать односвязный список (не список языка Python, объекты в списке не хранить, а
# формировать связанную структуру, показанную на рисунке) из объектов класса ListObject:
#
#
#
# Для этого объявите в программе класс ListObject, объекты которого создаются командой:
#
# obj = ListObject(data)
# Каждый объект класса ListObject должен содержать локальные свойства:
#
# next_obj - ссылка на следующий присоединенный объект (если следующего объекта нет, то next_obj = None);
# data - данные объекта в виде строки.
#
# В самом классе ListObject должен быть объявлен метод:
#
# link(self, obj) - для присоединения объекта obj такого же класса к текущему объекту self (то есть, атрибут next_obj
# объекта self должен ссылаться на obj).
#
# Прочитайте список строк из входного потока командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Затем сформируйте односвязный список, в объектах которых (в атрибуте data) хранятся строки из списка lst_in (первая
# строка в первом объекте, вторая - во втором и  т.д.). На первый добавленный объект класса ListObject должна ссылаться
# переменная head_obj.
#
# P.S. В программе что-либо выводить на экран не нужно.
#
# Sample Input:
# 1. Первые шаги в ООП
# 1.1 Как правильно проходить этот курс
# 1.2 Концепция ООП простыми словами
# 1.3 Классы и объекты. Атрибуты классов и объектов
# 1.4 Методы классов. Параметр self
# 1.5 Инициализатор init и финализатор del
# 1.6 Магический метод new. Пример паттерна Singleton
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)

# Sample Output:


import sys


# здесь объявляются все необходимые классы
class ListObject:

    def __init__(self, data):
        self.data = data
        self.next_obj = None

    def link(self, obj):
        self.next_obj = obj


# считывание списка из входного потока (эту строку не менять)
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять

# здесь создаются объекты классов и вызываются нужные методы
head_obj = ListObject(lst_in[0])
obj = head_obj
for i in range(1, len(lst_in)):
    obj_new = ListObject(lst_in[i])
    obj.link(obj_new)
    obj = obj_new



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/gmjwMakXk0c
# Большой подвиг 10. Объявите два класса:
#
# Cell - для представления клетки игрового поля;
# GamePole - для управления игровым полем, размером N x N клеток.
#
# С помощью класса Cell предполагается создавать отдельные клетки командой:
#
# c1 = Cell(around_mines, mine)
# Здесь around_mines - число мин вокруг данной клетки поля; mine - булева величина (True/False), означающая наличие
# мины в текущей клетке. При этом, в каждом объекте класса Cell должны создаваться локальные свойства:
#
# around_mines - число мин вокруг клетки (начальное значение 0);
# mine - наличие мины в текущей клетке (True/False);
# fl_open - открыта/закрыта клетка - булево значение (True/False). Изначально все клетки закрыты (False).

# С помощью класса GamePole должна быть возможность создавать квадратное игровое поле с числом клеток N x N:
#
# pole_game = GamePole(N, M)
# Здесь N - размер поля; M - общее число мин на поле. При этом, каждая клетка представляется объектом класса Cell и все
# объекты хранятся в двумерном списке N x N элементов - локальном свойстве pole объекта класса GamePole.
#
# В классе GamePole должны быть также реализованы следующие методы:
#
# init() - инициализация поля с новой расстановкой M мин (случайным образом по игровому полю, разумеется каждая мина
# должна находиться в отдельной клетке).
# show() - отображение поля в консоли в виде таблицы чисел открытых клеток (если клетка не открыта, то отображается
# символ #).
#
# При создании экземпляра класса GamePole в его инициализаторе следует вызывать метод init() для первоначальной
# инициализации игрового поля.
#
# В классе GamePole могут быть и другие вспомогательные методы.
#
# Создайте экземпляр pole_game класса GamePole с размером поля N = 10 и числом мин M = 12.
#
# P.S. На экран в программе ничего выводить не нужно.


from random import randint

class Cell:
    def __init__(self, around_mines=0, mine=False):
        self.around_mines = around_mines
        self.mine = mine
        self.fl_open = False

class GamePole:
    def __init__(self, N, M):
        self._n = N
        self._m = M
        self.pole = [[Cell() for n in range(self._n)] for n in range(self._n)]
        self.init()

    def init(self):
        m = 0
        while m < self._m:
            i = randint(0, self._n - 1)
            j = randint(0, self._n - 1)
            if self.pole[i][j].mine:
                continue
            self.pole[i][j].mine = True
            m += 1

        indx = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)
        for x in range(self._n):
            for y in range(self._n):
                if not self.pole[x][y].mine:
                    mines = sum((self.pole[x+i][y+j].mine for i, j in indx if 0 <= x+i < self._n and 0 <= y+j < self._n))
                    self.pole[x][y].around_mines = mines

    def show(self):
        for row in self.pole:
            print(*map(lambda x: '#' if not x.fl_open else x.around_mines if not x.mine else '*', row))


pole_game = GamePole(10, 12)
pole_game.show()



# ----------------------------------------------------------------------------------------------------------------------
# 1.6 Магический метод __new__. Пример паттерна Singleton
# ----------------------------------------------------------------------------------------------------------------------


# Подвиг 1. В какой момент вызывается магический метод __new__()?
# - непосредственно перед созданием объекта класса


# Подвиг 2. Что должен возвращать магический метод __new__() для успешного создания объектов класса?
# - адрес нового созданного объекта


# Подвиг 3. Конструктор класса (метод __new__) можно записать со следующей сигнатурой:
#
# def __new__(cls, *args, **kwargs): ...

# Какую роль здесь играет первый параметр cls?
# - ссылка на класс, для которого создается объект


# Подвиг 4. В каком порядке вызывается конструктор класса __new__() и инициализатор __init__() при создании объекта
# класса?
# - сначала всегда вызывается метод __new__(), затем метод __init__()


# Подвиг 5. При переопределении метода __new__() объект создается командой super().__new__(cls):
#
# def __new__(cls, *args, **kwargs):
#    return super().__new__(cls)

# Выберите верное утверждение для ее объяснения.
# - Идет обращение к базовому классу, из которого вызывается конструктор - метод __new__(cls) с аргументом cls - ссылки
# на текущий класс



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/7aVqWfrAdqw
# Подвиг 6. Объявите класс AbstractClass, объекты которого нельзя было бы создавать. При выполнении команды:
#
# obj = AbstractClass()
# переменная obj должна ссылаться на строку с содержимым:
#
# "Ошибка: нельзя создавать объекты абстрактного класса"
#
# P.S. В программе объявить только класс, выводить на экран ничего не нужно.

class AbstractClass:

    def __new__(cls, *args, **kwargs):
        return "Ошибка: нельзя создавать объекты абстрактного класса"



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/uE1uf7Qtbh4
#
# Подвиг 7. Объявите класс SingletonFive, с помощью которого можно было бы создавать объекты командой:
#
# a = SingletonFive(<наименование>)
# Здесь <наименование> - это данные, которые сохраняются в локальном свойстве name созданного объекта.
#
# Этот класс должен формировать только первые пять объектов. Остальные (шестой, седьмой и т.д.) должны быть ссылкой на
# последний (пятый) созданный объект.
#
# Создайте первые десять объектов класса SingletonFive с помощью следующего фрагмента программы:
#
# objs = [SingletonFive(str(n)) for n in range(10)]
# P.S. В программе на экран ничего выводить не нужно.


class SingletonFive:
    __instance = None
    __count = 0

    def __new__(cls, *args, **kwargs):
        if cls.__count < 5:
            cls.__instance = super().__new__(cls)
            cls.__count += 1

        return cls.__instance

    def __init__(self, name):
        self.name = name


obj = [SingletonFive(str(n)) for n in range(10)]



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/sX_uP7GVqkc
# Подвиг 8. В программе объявлена переменная TYPE_OS и два следующих класса:
#
# TYPE_OS = 1 # 1 - Windows; 2 - Linux
#
# class DialogWindows:
#     name_class = "DialogWindows"
#
#
# class DialogLinux:
#     name_class = "DialogLinux"
# Необходимо объявить третий класс с именем Dialog, который бы создавал объекты командой:
#
# dlg = Dialog(<название>)
# Здесь <название> - это строка, которая сохраняется в локальном свойстве name объекта dlg.
#
# Класс Dialog должен создавать объекты класса DialogWindows, если переменная TYPE_OS = 1 и объекты класса DialogLinux,
# если переменная TYPE_OS не равна 1. При этом, переменная TYPE_OS может меняться в последующих строчках программы.
# Имейте это в виду, при объявлении класса Dialog.
#
# P.S. В программе на экран ничего выводить не нужно. Только объявить класс Dialog


TYPE_OS = 1 # 1 - Windows; 2 - Linux

class DialogWindows:
    name_class = "DialogWindows"


class DialogLinux:
    name_class = "DialogLinux"


class Dialog:

    def __new__(cls, *args, **kwargs):
        obj = None
        if TYPE_OS == 1:
            obj = super().__new__(DialogWindows)
        else:
            obj = super().__new__(DialogLinux)

        obj.name = args[0]
        return obj



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/U4zwfmbEiCI
# Подвиг 9 (на повторение материала). Объявите класс Point для представления точек на плоскости. Создавать объекты
# этого класса предполагается командой:
#
# pt = Point(x, y)
# Здесь x, y - числовые координаты точки на плоскости (числа), то есть, в каждом объекте этого класса создаются
# локальные свойства x, y, которые хранят конкретные координаты точки.
#
# Необходимо в классе Point реализовать метод clone(self), который бы создавал новый объект класса Point как копию
# текущего объекта с локальными атрибутами x, y и соответствующими значениями.
#
# Создайте в программе объект pt класса Point и еще один объект pt_clone через вызов метода clone.
#
# P.S. В программе на экран ничего выводить не нужно.


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def clone(self):
        return Point(self.x, self.y)

pt = Point(1, 2)
pt_clone = pt.clone()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5aJVuJ5jGqk
# Подвиг 10 (на повторение материала). В программе предполагается реализовать парсер (обработчик) строки (string) в
# определенный выходной формат. Для этого объявлен следующий класс:
#
# class Loader:
#     def parse_format(self, string, factory):
#         seq = factory.build_sequence()
#         for sub in string.split(","):
#             item = factory.build_number(sub)
#             seq.append(item)
#
#         return seq
#
# И предполагается его использовать следующим образом:
#
# ld = Loader()
# res = ld.parse_format("4, 5, -6.5", Factory())
# На выходе (в переменной res) ожидается получить список из набора вещественных чисел. Например, для заданной строки,
# должно получиться:
#
# [4.0, 5.0, -6.5]
#
# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя методами:
#
# build_sequence(self) - для создания начального пустого списка (метод должен возвращать пустой список);
# build_number(self, string) - для преобразования переданной в метод строки (string) в вещественное значение (метод
# должен возвращать полученное вещественное число).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


class Factory:

    def build_sequence(self):
        return []


    def build_number(self, string):
        return float(string)


class Loader:
    def parse_format(self, string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
ld = Loader()
s = input()
res = ld.parse_format(s, Factory())



# ----------------------------------------------------------------------------------------------------------------------
# 1.7 Методы класса (classmethod) и статические методы (staticmethod)
# ----------------------------------------------------------------------------------------------------------------------

# Теория
class Test:
    x = 1
    y = 2

    def __init__(self):
        self.x = 3
        self.y = 4

    @staticmethod
    def static_method(x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    @classmethod
    def class_method(cls, x, y):
        a = x + y
        b = self.x + self.y  # <-- ОШИБКА не понимает, что такое self
        c = cls.x + cls.y
        d = Test.x + Test.y
        return a, b, c, d

    def self_method(self, x, y):
        a = x + y
        b = self.x + self.y
        c = cls.x + cls.y  # <-- ОШИБКА не понимает, что такое cls
        d = Test.x + Test.y
        return a, b, c, d

    def func_method(x, y):  # <-- ОШИБКА пихает в х ссылку на объект, ошибка при вызове
        a = x + y  # <-- ОШИБКА ^
        b = self.x + self.y  # <-- ОШИБКА ^
        c = cls.x + cls.y  # <-- ОШИБКА ^
        d = Test.x + Test.y
        return a, b, c, d

    def empty_method():  # <-- ОШИБКА не знает куда бы запихнуть ссылку на объект
        return 123




# Подвиг 1. В программе объявлен следующий класс с одним методом:
class Stepik:
    def get_certificate(self):
        return False

# И создается объект этого класса:

st = Stepik()
# Выберите все верные варианты вызова метода get_certificate:
# - Stepik.get_certificate(st)
# - st.get_certificate()


# Подвиг 2. В программе объявлен следующий класс с одним методом:
class Loader:
    @classmethod
    def json_parse(cls):
        return ""

# И создается объект этого класса:

ld = Loader()

# Выберите все верные варианты вызова метода json_parse:
# - Loader.json_parse()
# - ld.json_parse()
# - res = Loader.json_parse()
# - res = ld.json_parse()



# Подвиг 3. В программе объявлен следующий класс с одним методом:
class Math:
    @staticmethod
    def sqrt(x):
        return x ** 0.5

# И создается объект этого класса:

m = Math()

# Выберите все верные варианты вызова метода sqrt:
# - res = m.sqrt(2)
# - res = Math.sqrt(4)


# Подвиг 4. За что отвечает параметр cls в методах класса, объявленных следующим образом:
class Loader:
    @classmethod
    def json_parse(cls): ...

# - Ссылка на класс Loader


# Подвиг 5. В чем отличие между методами класса (объявленными через @classmethod) и статическими методами
# (объявленными через @staticmethod)?

# - методы класса предназначены для работы с атрибутами класса и переданными аргументами, а статические - только с
# переданными им аргументами


# Подвиг 6. В программе предполагается реализовать парсер (обработчик) строки с данными string в определенный выходной
# формат. Для этого объявлен следующий класс:

class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)

class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq

# И предполагается его использовать следующим образом:

res = Loader.parse_format("4, 5, -6", Factory)

# На выходе (в переменной res) ожидается получать список из набора целых чисел. Например, для заданной строки,
# должно получиться:

[4, 5, -6]

# Для реализации этой идеи необходимо вначале программы прописать класс Factory с двумя статическими методами:
#
# build_sequence() - для создания пустого списка (метод возвращает пустой список);
# build_number(string) - для преобразования строки (string) в целое число (метод возвращает полученное целочисленное
# значение).
#
# Объявите класс с именем Factory, чтобы получать на выходе искомый результат.
#
# P.S. В программе на экран ничего выводить не нужно.


# Здесь объявляется класс Factory
class Factory:
    @staticmethod
    def build_sequence():
        return []

    @staticmethod
    def build_number(string):
        return int(string)


class Loader:
    @staticmethod
    def parse_format(string, factory):
        seq = factory.build_sequence()
        for sub in string.split(","):
            item = factory.build_number(sub)
            seq.append(item)

        return seq


# эти строчки не менять!
res = Loader.parse_format("1, 2, 3, -5, 10", Factory)



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/D02X5B6zLi8
# Подвиг 7. В программе объявлен следующий класс для работы с формами ввода логин/пароль:

# class FormLogin:
#     def __init__(self, lgn, psw):
#         self.login = lgn
#         self.password = psw
#
#     def render_template(self):
#         return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])

# Который предполагается использовать следующим образом:

# login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
# html = login.render_template()

# Необходимо прописать классы TextInput и PasswordInput, объекты которых формируются командами:

# login = TextInput(name, size)
# psw = PasswordInput(name, size)

# В каждом объекте этих классов должны быть следующие локальные свойства:

# name - название для поля (сохраняет передаваемое имя, например, "Логин" или "Пароль");
# size - размер поля ввода (целое число, по умолчанию 10).

# Также классы TextInput и PasswordInput должны иметь метод:

# get_html(self) - возвращает сформированную HTML-строку в формате (1-я строка для класса TextInput ; 2-я - для класса
# PasswordInput):

# <p class='login'><имя поля>: <input type='text' size=<размер поля> />
# <p class='password'><имя поля>: <input type='text' size=<размер поля> />

# Например, для поля login:

# <p class='login'>Логин: <input type='text' size=10 />

# Также классы TextInput и PasswordInput должны иметь метод класса (@classmethod):

# check_name(cls, name) - для проверки корректности переданного имя поля (следует вызывать в инициализаторе) по
# следующим критериям:

# - длина имени не менее 3 символов и не более 50;
# - в именах могут использоваться только символы русского, английского алфавитов, цифры и пробелы

# Если проверка не проходит, то генерировать исключение командой:

# raise ValueError("некорректное поле name")
# Для проверки допустимых символов в каждом классе должен быть прописан атрибут CHARS_CORRECT:

# CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
# CHARS_CORRECT = CHARS + CHARS.upper() + digits
# По заданию нужно объявить только классы TextInput и PasswordInput с соответствующим функционалом. Более ничего.

# P. S. В данном задании получится дублирование кода в классах TextInput и PasswordInput. На данном этапе - это
# нормально.

from string import ascii_lowercase, digits

# здесь объявляйте классы TextInput и PasswordInput
class TextInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size


    def get_html(self):
        return f"<p class='login'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class PasswordInput:
    CHARS = "абвгдеёжзийклмнопрстуфхцчшщьыъэюя " + ascii_lowercase
    CHARS_CORRECT = CHARS + CHARS.upper() + digits

    def __init__(self, name, size=10):
        self.check_name(name)
        self.name = name
        self.size = size

    def get_html(self):
        return f"<p class='password'>{self.name}: <input type='text' size={self.size} />"

    @classmethod
    def check_name(cls, name):
        if 3 <= len(name) <= 50:
            for i in name:
                if i not in cls.CHARS_CORRECT:
                    raise ValueError('некорректное поле name')
        else:
            raise ValueError('некорректное поле name')
        return True


class FormLogin:
    def __init__(self, lgn, psw):
        self.login = lgn
        self.password = psw

    def render_template(self):
        return "\n".join(['<form action="#">', self.login.get_html(), self.password.get_html(), '</form>'])


# эти строчки не менять
login = FormLogin(TextInput("Логин"), PasswordInput("Пароль"))
html = login.render_template()



# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/9766M0dS1qc
#
# Подвиг 8. Объявите класс CardCheck для проверки корректности информации на пластиковых картах. Этот класс должен иметь
# следующие методы:
#
# check_card_number(number) - проверяет строку с номером карты и возвращает булево значение True, если номер в верном
# формате и False - в противном случае. Формат номера следующий: XXXX-XXXX-XXXX-XXXX, где X - любая цифра (от 0 до 9).
# check_name(name) - проверяет строку name с именем пользователя карты. Возвращает булево значение True, если имя
# записано верно и False - в противном случае.
#
# Формат имени: два слова (имя и фамилия) через пробел, записанные заглавными латинскими символами и цифрами.
# Например, SERGEI BALAKIREV.
#
# Предполагается использовать класс CardCheck следующим образом (эти строчки в программе не писать):

# is_number = CardCheck.check_card_number("1234-5678-9012-0000")
# is_name = CardCheck.check_name("SERGEI BALAKIREV")
# Для проверки допустимых символов в классе должен быть прописан атрибут:

# CHARS_FOR_NAME = ascii_lowercase.upper() + digits
# Подумайте, как правильнее объявить методы check_card_number и check_name (декораторами @classmethod и @staticmethod).

# P.S. В программе только объявить класс. На экран ничего выводить не нужно.
from string import ascii_lowercase, digits
class CardCheck:
    CHARS_FOR_NAME = ascii_lowercase.upper() + digits

    @staticmethod
    def check_card_number(number):
        number_card_list = number.split('-')
        if len(number_card_list) != 4:
            return False
        for i in number_card_list:
            if len(i) == 4 and i.isdigit():
                continue
            else:
                return False
        return True

    @classmethod
    def check_name(cls, name):
        if name.count(' ') == 1:
            name = name.replace(' ', '')
            for i in name:
                if i in cls.CHARS_FOR_NAME:
                    continue
                else:
                    return False
        else:
            return False
        return True


# При помощи регулярок
import re


class CardCheck:
    @staticmethod
    def check_card_number(number):
        return bool(re.fullmatch(r"\d{4}(?:-\d{4}){3}", number))

    @staticmethod
    def check_name(name):
        return bool(re.fullmatch(r"[A-Z\d]+ [A-Z\d]+", name))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YkDq9p8n17A
#
# Подвиг 9. Объявите в программе класс Video с двумя методами:
#
# create(self, name) - для задания имени name текущего видео (метод сохраняет имя name в локальном атрибуте name
# объекта класса Video);
# play(self) - для воспроизведения видео (метод выводит на экран строку "воспроизведение видео <name>").
#
# Объявите еще один класс с именем YouTube, в котором объявите два метода (с декоратором @classmethod):
#
# add_video(cls, video) - для добавления нового видео (метод помещает объект video класса Video в список);
# play(cls, video_indx) - для проигрывания видео из списка по указанному индексу (индексация с нуля).
#
# (здесь cls - ссылка на класс YouTube). И список (тоже внутри класса YouTube):
#
# videos - для хранения добавленных объектов класса Video (изначально список пуст).
#
# Метод play() класса YouTube должен обращаться к объекту класса Video по индексу списка videos и, затем, вызывать
# метод play() класса Video.
#
# Методы add_video и play вызывайте напрямую из класса YouTube. Создавать экземпляр этого класса не нужно.
#
# Создайте два объекта v1 и v2 класса Video, затем, через метод create() передайте им имена "Python" и "Python ООП".
# После этого с помощью метода add_video класса YouTube, добавьте в него эти два видео и воспроизведите (с помощью
# метода play класса YouTube) сначала первое, а затем, второе видео.
#
# Sample Input:
#
# Sample Output:
#
# воспроизведение видео Python
# воспроизведение видео Python ООП

class Video:
    name = None
    def create(self, name):
        self.name = name

    def play(self):
        print(f'воспроизведение видео {self.name}')


class YouTube:
    videos = []

    @classmethod
    def add_video(cls, video):
        cls.videos.append(video)

    @classmethod
    def play(cls, video_indx):
        cls.videos[video_indx].play()

v1 = Video()
v2 = Video()
v1.create('Python')
v2.create('Python ООП')
YouTube.add_video(v1)
YouTube.add_video(v2)
YouTube.play(0)
YouTube.play(1)




# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Y4Hvpg4FuKs
#
# Подвиг 10 (на повторение). Объявите класс AppStore - интернет-магазин приложений для устройств под iOS. В этом
# классе должны быть реализованы следующие методы:
#
# add_application(self, app) - добавление нового приложения app в магазин;
# remove_application(self, app) - удаление приложения app из магазина;
# block_application(self, app) - блокировка приложения app (устанавливает локальное свойство blocked объекта app в
# значение True);
# total_apps(self) - возвращает общее число приложений в магазине.
#
# Класс AppStore предполагается использовать следующим образом (эти строчки в программе не писать):
#
# store = AppStore()
# app_youtube = Application("Youtube")
# store.add_application(app_youtube)
# store.remove_application(app_youtube)
# Здесь Application - класс, описывающий добавляемое приложение с указанным именем. Каждый объект класса Application
# должен содержать локальные свойства:
#
# name - наименование приложения (строка);
# blocked - булево значение (True - приложение заблокировано; False - не заблокировано, изначально False).
#
# Как хранить список приложений в объектах класса AppStore решите сами.
#
# P.S. В программе нужно только объявить классы с указанным функционалом.


class AppStore:

    def __init__(self):
        self.apps = []
    def add_application(self, app):
        self.apps.append(app)

    def remove_application(self, app):
        self.apps.remove(app)

    def block_application(self, app):
        app.blocked = True

    def total_apps(self):
        return len(self.apps)


class Application:
    def __init__(self, name, blocked=False):
        self.name = name
        self.blocked = blocked



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/38QoBSpQqnM
#
# Подвиг 11 (на повторение). Объявите класс для мессенджера с именем Viber. В этом классе должны быть следующие методы:
#
# add_message(msg) - добавление нового сообщения в список сообщений;
# remove_message(msg) - удаление сообщения из списка;
# set_like(msg) - поставить/убрать лайк для сообщения msg (т.е. изменить атрибут fl_like объекта msg: если лайка нет
# то он ставится, если уже есть, то убирается);
# show_last_message(число) - отображение последних сообщений;
# total_messages() - возвращает общее число сообщений.
#
# Эти методы предполагается использовать следующим образом (эти строчки в программе не писать):
#
# msg = Message("Всем привет!")
# Viber.add_message(msg)
# Viber.add_message(Message("Это курс по Python ООП."))
# Viber.add_message(Message("Что вы о нем думаете?"))
# Viber.set_like(msg)
# Viber.remove_message(msg)
# Класс Message (необходимо также объявить) позволяет создавать объекты-сообщения со следующим набором локальных
# свойств:
#
# text - текст сообщения (строка);
# fl_like - поставлен или не поставлен лайк у сообщения (булево значение True - если лайк есть и False - в противном
# случае, изначально False);
#
# P.S. Как хранить список сообщений, решите самостоятельно.

class Message:
    def __init__(self, text, fl_like=False):
        self.text = text
        self.fl_like = fl_like

class Viber:

    msgs = []

    @classmethod
    def add_message(cls, msg):
        cls.msgs.append(msg)

    @classmethod
    def remove_message(cls, msg):
        cls.msgs.remove(msg)

    @classmethod
    def set_like(cls, msg):
        if msg.fl_like:
            msg.fl_like = False
        else:
            msg.fl_like = True

    @classmethod
    def show_last_message(cls, amount):
        print(cls.msgs[-amount:])

    @classmethod
    def total_messages(cls):
        return len(cls.msgs)


# ======================================================================================================================
# 1.8 Испытание свойствами и методами
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор (решение смотреть только после своей попытки): https://youtu.be/26pwwOu_-d0
#
# Время первого испытания. Представьте, что вы получили задание от заказчика. Вас просят реализовать простую имитацию
# локальной сети, состоящую из набора серверов, соединенных между собой через роутер.
#
#
#
# Каждый сервер может отправлять пакет любому другому серверу сети. Для этого у каждого есть свой уникальный IP-адрес.
# Для простоты - это просто целое (натуральное) число от 1 и до N, где N - общее число серверов. Алгоритм следующий.
# Предположим, сервер с IP = 2 собирается отправить пакет информации серверу с IP = 3. Для этого, он сначала отправляет
# пакет роутеру, а уже тот, смотрит на IP-адрес и пересылает пакет нужному узлу (серверу).
#
# Для реализации этой схемы программе предлагается объявить три класса:
#
# Server - для описания работы серверов в сети;
# Router - для описания работы роутеров в сети (в данной задаче полагается один роутер);
# Data - для описания пакета информации.
#
# Серверы будут создаваться командой:
#
# sv = Server()
# При этом, уникальный IP-адрес каждого сервера должен формироваться автоматически при создании нового экземпляра
# класса Server.
#
# Далее, роутер должен создаваться аналогичной командой:
#
# router = Router()
# А, пакеты данных, командой:
#
# data = Data(строка с данными, IP-адрес назначения)
# Для формирования и функционирования локальной сети, в классе Router должны быть реализованы следующие методы:
#
# link(server) - для присоединения сервера server (объекта класса Server) к роутеру (для простоты, каждый сервер
# соединен только с одним роутером);
# unlink(server) - для отсоединения сервера server (объекта класса Server) от роутера;
# send_data() - для отправки всех пакетов (объектов класса Data) из буфера роутера соответствующим серверам (после
# отправки буфер должен очищаться).
#
# И одно обязательное локальное свойство (могут быть и другие свойства):
#
# buffer - список для хранения принятых от серверов пакетов (объектов класса Data).
#
# Класс Server должен содержать свой набор методов:
#
# send_data(data) - для отправки информационного пакета data (объекта класса Data) с указанным IP-адресом получателя
# (пакет отправляется роутеру и сохраняется в его буфере - локальном свойстве buffer);
# get_data() - возвращает список принятых пакетов (если ничего принято не было, то возвращается пустой список) и
# очищает входной буфер;
# get_ip() - возвращает свой IP-адрес.
#
# Соответственно в объектах класса Server должны быть локальные свойства:
#
# buffer - список принятых пакетов (объекты класса Data, изначально пустой);
# ip - IP-адрес текущего сервера.
#
# Наконец, объекты класса Data должны содержать два следующих локальных свойства:
#
# data - передаваемые данные (строка);
# ip - IP-адрес назначения.
#
# Пример использования этих классов (эти строчки в программе писать не нужно):
#
# router = Router()
# sv_from = Server()
# sv_from2 = Server()
# router.link(sv_from)
# router.link(sv_from2)
# router.link(Server())
# router.link(Server())
# sv_to = Server()
# router.link(sv_to)
# sv_from.send_data(Data("Hello", sv_to.get_ip()))
# sv_from2.send_data(Data("Hello", sv_to.get_ip()))
# sv_to.send_data(Data("Hi", sv_from.get_ip()))
# router.send_data()
# msg_lst_from = sv_from.get_data()
# msg_lst_to = sv_to.get_data()
# Ваша задача реализовать классы Router, Server и Data в соответствии с приведенным техническим заданием (ТЗ).
# Что-либо выводить на экран не нужно.


class Router:

    def __init__(self):
        self.buffer = []
        self.servers = {}

    def link(self, server):
        self.servers[server.ip] = server
        server.router = self

    def unlink(self, server):
        s = self.servers.pop(server.ip, False)
        if s:
            s.router = None

    def send_data(self):
        for d in self.buffer:
            if d.ip in self.servers:
                self.servers[d.ip].buffer.append(d)
        self.buffer.clear()

class Server:
    server_ip = 1

    def __init__(self):
        self.buffer = []
        self.ip = Server.server_ip
        Server.server_ip += 1
        self.router = None

    def send_data(self, data):
        if self.router:
            self.router.buffer.append(data)

    def get_data(self):
        b = self.buffer[:]
        self.buffer.clear()
        return b

    def get_ip(self):
        return self.ip


class Data:

    def __init__(self, msg, ip):
        self.data = msg
        self.ip = ip



# ======================================================================================================================
# 2. Режимы доступа, свойства и дескрипторы
# ======================================================================================================================

# ======================================================================================================================
# 2.1. Режимы доступа public, private, protected. Сеттеры и геттеры
# ----------------------------------------------------------------------------------------------------------------------

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствия между именами атрибутов классов и их режимами доступа.

# self.data - публичный режим доступа (public)
# self._word - защищенный режим доступа (protected)
# self.__buffer - приватный режим доступа (private)

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Какую роль играет приватный (private) режим доступа атрибутов классов?

# - скрывает приватные переменные и методы от прямого доступа к ним (по исходным именам) вне класса
# - предостерегает программиста (использующего класс) от прямого использования приватных атрибутов вне класса

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Lqo3xcfaUZU
# Подвиг 3. Объявите класс с именем Clock и определите в нем следующие переменные и методы:
#
# - приватная локальная переменная time для хранения текущего времени, целое число (своя для каждого объекта класса
# Clock с начальным значением 0);
# - публичный метод set_time(tm) для установки текущего времени (присваивает значение tm приватному локальному свойству
# time, если метод check_time(tm) возвратил True);
# - публичный метод get_time() для получения текущего времени из приватной локальной переменной time;
# - приватный метод класса check_time(tm) для проверки корректности времени в переменной tm (возвращает True, если
# значение корректно и False - в противном случае).
#
# Проверка корректности выполняется по критерию: tm должна быть целым числом, больше или равна нулю и меньше 100 000.
#
# Объекты класса Clock предполагается использовать командой:
#
# clock = Clock(время)
# Создайте объект clock класса Clock и установите время, равным 4530.
#
# P.S. На экран ничего выводить не нужно.

class Clock:

    def __init__(self, time=0):
        self.__time = time

    def __check_time(self, tm):
        return True if type(tm) == int and 0 <= tm <= 100000 else False

    def set_time(self, tm):
        if self.__check_time(tm):
            self.__time = tm

    def get_time(self):
        return self.__time

clock = Clock(4530)


# Вторая версия
class Clock:
    __MIN_TIME = 0
    __MAX_TIME = 100_000

    def __init__(self, time=0):
        self.__time = time if self.__check_time(time) else 0

    def set_time(self, tm):
        if self.__check_time(tm):
            self.__time = tm

    def get_time(self):
        return self.__time

    @classmethod
    def __check_time(cls, tm):
        return type(tm) is int and cls.__MIN_TIME <= tm < cls.__MAX_TIME


clock = Clock()
clock.set_time(4530)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/iYcfCeRTyww
# Подвиг 4. Объявите класс с именем Money и определите в нем следующие переменные и методы:
#
# - приватная локальная переменная money (целочисленная) для хранения количества денег (своя для каждого объекта класса
# Money);
# - публичный метод set_money(money) для передачи нового значения приватной локальной переменной money (изменение
# выполняется только если метод check_money(money) возвращает значение True);
# - публичный метод get_money() для получения текущего объема средств (денег);
# - публичный метод add_money(mn) для прибавления средств из объекта mn класса Money к средствам текущего объекта;
# - приватный метод класса check_money(money) для проверки корректности объема средств в параметре money (возвращает
# True, если значение корректно и False - в противном случае).
#
# Проверка корректности выполняется по критерию: параметр money должен быть целым числом, больше или равным нулю.
#
# Пример использования класса Money (эти строчки в программе не писать):
#
# mn_1 = Money(10)
# mn_2 = Money(20)
# mn_1.set_money(100)
# mn_2.add_money(mn_1)
# m1 = mn_1.get_money()    # 100
# m2 = mn_2.get_money()    # 120


class Money:

    def __init__(self, money):
        self.__money = money

    def set_money(self, money):
        if self.__check_money(money):
            self.__money = money

    @classmethod
    def __check_money(cls, money):
        return True if type(money) is int and money >= 0 else False

    def get_money(self):
        return self.__money

    def add_money(self, mn):
        self.__money += mn.get_money()


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Какую роль в классах играют сеттеры и геттеры и что они из себя представляют?

# - это публичные методы для считывания и записи значений в приватные переменные класса или его объектов


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/w0SAD6zNLlw
# Подвиг 6. Объявите класс Book со следующим набором сеттеров и геттеров:
#
# set_title(self, title) - запись в локальное приватное свойство __title объектов класса Book значения title;
# set_author(self, author) - запись в локальное приватное свойство __author объектов класса Book значения author;
# set_price(self, price) - запись в локальное приватное свойство __price объектов класса Book значения price;
# get_title(self) - получение значения локального приватного свойства __title объектов класса Book;
# get_author(self) - получение значения локального приватного свойства __author объектов класса Book;
# get_price(self) - получение значения локального приватного свойства __price объектов класса Book;
#
# Объекты класса Book предполагается создавать командой:
#
# book = Book(автор, название, цена)
# При этом, в каждом объекте должны создаваться приватные локальные свойства:
#
# __author - строка с именем автора;
# __title - строка с названием книги;
# __price - целое число с ценой книги.
#
# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.


class Book:

    def __init__(self, author, title, price):
        self.__author = author
        self.__title = title
        self.__price = price

    def set_title(self, title):
        self.__title = title

    def set_author(self, author):
        self.__author = author

    def set_price(self, price):
        self.__price = price

    def get_title(self):
        return self.__title

    def get_author(self):
        return self.__author

    def get_price(self):
        return self.__price


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/ZX8fVI0KTfE
# Подвиг 7. Объявите класс Line для описания линии на плоскости, объекты которого предполагается создавать командой:
#
# line = Line(x1, y1, x2, y2)
# При этом в объекте line должны создаваться следующие приватные локальные свойства:
#
# __x1, __y1 - начальная координата;
# __x2, __y2 - конечная координата.
#
# В самом классе Line должны быть реализованы следующие сеттеры и геттеры:
#
# set_coords(self, x1, y1, x2, y2) - для изменения координат линии;
# get_coords(self) - для получения кортежа из текущих координат линии.
#
# А также метод:
#
# draw(self) - для отображения в консоли списка текущих координат линии (в одну строчку через пробел).
#
# P.S. В программе требуется объявить только класс. Ничего на экран выводить не нужно.

class Line:

    def __init__(self, x1, y1, x2, y2):
        self.__x1 = x1
        self.__x2 = x2
        self.__y1 = y1
        self.__y2 = y2

    def set_coords(self, x1, y1, x2, y2):
        self.__x1 = x1
        self.__x2 = x2
        self.__y1 = y1
        self.__y2 = y2

    def get_coords(self):
        return self.__x1, self.__y1, self.__x2, self.__y2

    def draw(self):
        print(*self.get_coords())


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rcj0pB1aB5M
#
# Подвиг 8. Объявите в программе два класса Point и Rectangle. Объекты первого класса должны создаваться командой:
#
# pt = Point(x, y)
# где x, y - координаты точки на плоскости (целые или вещественные числа). При этом в объектах класса Point должны
# формироваться следующие локальные свойства:
#
# __x, __y - координаты точки на плоскости.
#
# и один геттер:
#
# get_coords() - возвращение кортежа текущих координат __x, __y
#
# Объекты второго класса Rectangle (прямоугольник) должны создаваться командами:
#
# r1 = Rectangle(Point(x1, y1), Point(x2, y2))
# или
#
# r2 = Rectangle(x1, y1, x2, y2)
# Здесь первая координата (x1, y1) - верхний левый угол, а вторая координата (x2, y2) - правый нижний. При этом, в
# объектах класса Rectangle (вне зависимости от способа их создания) должны формироваться следующие локальные свойства:
#
# __sp - объект класса Point с координатами x1, y1 (верхний левый угол);
# __ep - объект класса Point с координатами x2, y2 (нижний правый угол).
#
# Также к классе Rectangle должны быть реализованы следующие методы:
#
# set_coords(self, sp, ep) - изменение текущих координат, где sp, ep - объекты класса Point;
# get_coords(self) - возвращение кортежа из объектов класса Point с текущими координатами прямоугольника (ссылки на
# локальные свойства __sp и __ep);
# draw(self) - отображение в консоли сообщения: "Прямоугольник с координатами: (x1, y1) (x2, y2)".
# Здесь x1, y1, x2, y2 - соответствующие числовые значения координат.
#
# Создайте объект rect класса Rectangle с координатами (0, 0), (20, 34).
#
# P.S. На экран ничего выводить не нужно.


class Point:

    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def get_coords(self):
        return self.__x, self.__y


class Rectangle:

    def __init__(self, *args):
        if len(args) == 4:
            self.__sp = Point(args[0], args[1])
            self.__ep = Point(args[2], args[3])
        else:
            self.__sp = args[0]
            self.__ep = args[1]

    def set_coords(self, sp, ep):
        self.__sp = sp
        self.__ep = ep

    def get_coords(self):
        return self.__sp, self.__ep

    def draw(self):
        print(f'Прямоугольник с координатами: {self.__sp.get_coords()} {self.__ep.get_coords()}')


rect = Rectangle(0, 0, 20, 34)

# Второй вариант
class Point:
    def __init__(self, x, y):
        self.__x = x
        self.__y = y

    def get_coords(self):
        return self.__x, self.__y


class Rectangle:
    def __init__(self, *args):
        if len(args) == 2:
            self.set_coords(*args)
        elif len(args) == 4:
            x1, y1, x2, y2 = args
            self.set_coords(Point(x1, y1), Point(x2, y2))

    def set_coords(self, sp, ep):
        self.__sp = sp
        self.__ep = ep

    def get_coords(self):
        return self.__sp, self.__ep

    def draw(self):
        x1, y1, x2, y2 = self.__sp, self.__ep
        print(f'Прямоугольник с координатами: ({x1}, {y1}) ({x2}, {y2})')


rect = Rectangle(0, 0, 20, 34)



# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YJiPpHVguyE
# Теория по двусвязным спискам (при необходимости): https://youtu.be/0sTH9EwXT1I

# Большой подвиг 9. Необходимо реализовать связный список (не список языка Python и не хранить объекты в списке Python),
# когда объекты класса ObjList связаны с соседними через приватные свойства __next и __prev:

# Для этого объявите класс LinkedList, который будет представлять связный список в целом и иметь набор следующих
# методов:
#
# add_obj(self, obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(self) - удаление последнего объекта из связного списка;
# get_data(self) - получение списка из строк локального свойства __data всех объектов связного списка.
#
# И в каждом объекте этого класса должны создаваться локальные публичные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пустой, то head = None);
# tail - ссылка на последний объект связного списка (если список пустой, то tail = None).
#
# Объекты класса ObjList должны иметь следующий набор приватных локальных свойств:
#
# __next - ссылка на следующий объект связного списка (если следующего объекта нет, то __next = None);
# __prev - ссылка на предыдущий объект связного списка (если предыдущего объекта нет, то __prev = None);
# __data - строка с данными.
#
# Также в классе ObjList должны быть реализованы следующие сеттеры и геттеры:
#
# set_next(self, obj) - изменение приватного свойства __next на значение obj;
# set_prev(self, obj) - изменение приватного свойства __prev на значение obj;
# get_next(self) - получение значения приватного свойства __next;
# get_prev(self) - получение значения приватного свойства __prev;
# set_data(self, data) - изменение приватного свойства __data на значение data;
# get_data(self) - получение значения приватного свойства __data.
#
# Создавать объекты класса ObjList предполагается командой:
#
# ob = ObjList("данные 1")
# А использовать класс LinkedList следующим образом (пример, эти строчки писать в программе не нужно):
#
# lst = LinkedList()
# lst.add_obj(ObjList("данные 1"))
# lst.add_obj(ObjList("данные 2"))
# lst.add_obj(ObjList("данные 3"))
# res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']
# Объявите в программе классы LinkedList и ObjList в соответствии с заданием.
#
# P.S. На экран ничего выводить не нужно.

class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if self.tail:
            self.tail.set_next(obj)
        obj.set_prev(self.tail)
        self.tail = obj
        if not self.head:
            self.head = obj

    def remove_obj(self):
        if self.tail is None:
            return

        prev = self.tail.get_prev()
        if prev:
            prev.set_next(None)

        self.tail = prev
        if self.tail is None:
            self.head = None

    def get_data(self):
        l = []
        getter = self.head
        while getter:
            l.append(getter.get_data())
            getter = getter.get_next()
        return l



class ObjList:

    def __init__(self, data):
        self.__next = None
        self.__prev = None
        self.__data = data

    def set_next(self, obj):
        self.__next = obj

    def set_prev(self, obj):
        self.__prev = obj

    def set_data(self, data):
        self.__data = data

    def get_next(self):
        return self.__next

    def get_prev(self):
        return self.__prev

    def get_data(self):
        return self.__data


lst = LinkedList()
lst.add_obj(ObjList("данные 1"))
lst.add_obj(ObjList("данные 2"))
lst.add_obj(ObjList("данные 3"))
res = lst.get_data()    # ['данные 1', 'данные 2', 'данные 3']

print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/HPgJtLb2NV8
# Подвиг 10 (на повторение). Объявите класс EmailValidator для проверки корректности email-адреса. Необходимо запретить
# создание объектов этого класса: при создании экземпляров должно возвращаться значение None, например:
#
# em = EmailValidator() # None
# В самом классе реализовать следующие методы класса (@classmethod):
#
# get_random_email(cls) - для генерации случайного email-адреса по формату: xxxxxxx...xxx@gmail.com, где x - любой
# допустимый символ в email (латинский буквы, цифры, символ подчеркивания и точка);
# check_email(cls, email) - возвращает True, если email записан верно и False - в противном случае.
#
# Корректность строки email определяется по следующим критериям:
#
# - допустимые символы: латинский алфавит, цифры, символы подчеркивания, точки и собачка @ (одна);
# - длина email до символа @ не должна превышать 100 (сто включительно);
# - длина email после символа @ не должна быть больше 50 (включительно);
# - после символа @ обязательно должна идти хотя бы одна точка;
# - не должно быть двух точек подряд.
#
# Также в классе нужно реализовать приватный статический метод класса:
#
# is_email_str(email) - для проверки типа переменной email, если строка, то возвращается значение True, иначе - False.
#
# Метод is_email_str() следует использовать в методе check_email() перед проверкой корректности email. Если параметр
# email не является строкой, то check_email() возвращает False.
#
# Пример использования класса EmailValidator (эти строчки в программе писать не нужно):
#
# res = EmailValidator.check_email("sc_lib@list.ru") # True
# res = EmailValidator.check_email("sc_lib@list_ru") # False
# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.

import random
import string

class EmailValidator:
    __CHARS = string.ascii_letters + string.digits + '_.'

    def __new__(cls, *args, **kwargs):
        return None

    @classmethod
    def get_random_email(cls):
        res = ''
        for i in range(random.randint(1, 100)):
            res += random.choice(EmailValidator.__CHARS)
        res += '@gmail.com'
        if EmailValidator.check_email(res):
            return res
        else:
            EmailValidator.get_random_email()

    @classmethod
    def check_email(cls, email):
        if len(email[:email.index('@')]) > 100 or len(email[email.index('@'):]) > 50:
            return False
        if email[email.index('@'):].count('.') < 1:
            return False
        if email.count('..') > 0:
            return False
        for i in email:
            if i == '@':
                continue
            if i not in EmailValidator.__CHARS:
                return False
        return True

    @staticmethod
    def __is_email_str(email):
        if type(email) == str:
            return True
        else:
            return False


# ======================================================================================================================
# 2.2 Свойства property. Декоратор @property
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Пусть в программе объявлен следующий класс:
#
class Money:
    def __init__(self):
        self.__money = 0

    def set_money(self, value):
        self.__money = value

    def get_money(self):
        return self.__money

    money = property(get_money, set_money)
# И, затем, выполняются команды:
#
m = Money()
m.money = 10
# Выберите верные утверждения, связанные с этими программными строчками.

# - в строчке m.money = 10 происходит вызов метода set_money и локальной переменной __money присваивается значение 10
# - для считывания информации из локальной переменной __money достаточно записать res = m.money
# - в строчке money = property(get_money, set_money) создается объект-свойство с геттером get_money и сеттером set_money


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Пусть в некотором классе определены три метода:
#
# get_pr() - геттер;
# set_pr() - сеттер;
# del_pr() - делитер.
#
# Выберите все верные варианты использования класса property для создания объектов-свойств на основе этих методов.

# - pr = property(get_pr)
# - pr = property(); pr = pr.setter(set_pr); pr = pr.getter(get_pr); pr = pr.deleter(del_pr)
# - pr = property(get_pr, set_pr)
# - pr = property(); pr = pr.setter(set_pr); pr = pr.getter(get_pr)
# - pr = property(get_pr, set_pr, del_pr)

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. В каких случаях целесообразно использовать объекты-свойства?

# - для инициализации локальных свойств в момент создания объектов
# - для удобства доступа к приватным атрибутам класса или объектов
# - для реализации дополнительной логики (программы) в момент присваивания и считывания информации из атрибутов класса
# или объектов

# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PN3SjHz2ZG4
#
# Подвиг 4. Объявите в программе класс Car, в котором реализуйте объект-свойство с именем model для записи и считывания
# информации о модели автомобиля из локальной приватной переменной __model.
#
# Объект-свойство объявите с помощью декоратора @property. Также в объекте-свойстве model должны быть реализованы
# проверки:
#
# - модель автомобиля - это строка;
# - длина строки модели должна быть в диапазоне [2; 100].
#
# Если проверка не проходит, то локальное свойство __model остается без изменений.
#
# Объекты класса Car предполагается создавать командой:
#
# car = Car()
# и далее работа с объектом-свойством, например:
#
# car.model = "Toyota"
# P.S. В программе объявить только класс. На экран ничего выводить не нужно.


class Car:

    def __init__(self):
        self.__model = None

    @property
    def model(self):
        return self.__model

    @model.setter
    def model(self, model):
        if type(model) is str and 2 <= len(model) <= 100:
            self.__model = model


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/P0sI_Eb_i0c
#
# Подвиг 5. Объявите в программе класс WindowDlg, объекты которого предполагается создавать командой:
#
# wnd = WindowDlg(заголовок окна, ширина, высота)
# В каждом объекте класса WindowDlg должны создаваться приватные локальные атрибуты:
#
# __title - заголовок окна (строка);
# __width, __height - ширина и высота окна (числа).
#
# В классе WindowDlg необходимо реализовать метод:
#
# show() - для отображения окна на экране (выводит в консоль строку в формате: "<Заголовок>: <ширина>, <высота>",
# например "Диалог 1: 100, 50").
#
# Также в классе WindowDlg необходимо реализовать два объекта-свойства:
#
# width - для изменения и считывания ширины окна;
# height - для изменения и считывания высоты окна.
#
# При изменении размеров окна необходимо выполнять проверку:
#
# - переданное значение является целым числом в диапазоне [0; 10000].
#
# Если хотя бы один размер изменился (высота или ширина), то следует выполнить автоматическую перерисовку окна
# (вызвать метод show()). При начальной инициализации размеров width, height вызывать метод show() не нужно.
#
# P.S. В программе нужно объявить только класс с требуемой функциональностью.


class WindowDlg:

    def __init__(self, title, width, height):
        self.__title = title
        self.__width = width
        self.__height = height

    def get_title(self):
        return self.__title

    @property
    def width(self):
        return self.__width

    @width.setter
    def width(self, width):
        if type(width) is int and 0 <= width <= 10000:
            self.__width = width
            self.show()

    @property
    def height(self):
        return self.__height

    @height.setter
    def height(self, height):
        if type(height) is int and 0 <= height <= 10000:
            self.__height = height
            self.show()

    def show(self):
        print(f'{self.get_title()}: {self.width}, {self.height}')


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/mg4b8nhVDKY
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 6. Реализуйте односвязный список (не список Python, не использовать список Python для хранения объектов),
# когда один объект ссылается на следующий и так по цепочке до последнего:

# Для этого объявите в программе два класса:
#
# StackObj - для описания объектов односвязного списка;
# Stack - для управления односвязным списком.
#
# Объекты класса StackObj предполагается создавать командой:
#
# obj = StackObj(данные)
# Здесь данные - это строка с некоторым содержимым. Каждый объект класса StackObj должен иметь следующие локальные
# приватные атрибуты:
#
# __data - ссылка на строку с данными, указанными при создании объекта;
# __next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).
#
# Также в классе StackObj должны быть объявлены объекты-свойства:
#
# next - для записи и считывания информации из локального приватного свойства __next;
# data - для записи и считывания информации из локального приватного свойства __data.
#
# При записи необходимо реализовать проверку, что __next будет ссылаться на объект класса StackObj или значение None.
# Если проверка не проходит, то __next остается без изменений.
#
# Класс Stack предполагается использовать следующим образом:
#
# st = Stack() # создание объекта односвязного списка
# В объектах класса Stack должен быть локальный публичный атрибут:
#
# top - ссылка на первый добавленный объект односвязного списка (если список пуст, то top = None).
#
# А в самом классе Stack следующие методы:
#
# push(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
# pop(self) - извлечение последнего объекта с его удалением из односвязного списка;
# get_data(self) - получение списка из объектов односвязного списка (список из строк локального атрибута __data
# каждого объекта в порядке их добавления, или пустой список, если объектов нет).
#
# Пример использования классов Stack и StackObj (эти строчки в программе писать не нужно):
#
# st = Stack()
# st.push(StackObj("obj1"))
# st.push(StackObj("obj2"))
# st.push(StackObj("obj3"))
# st.pop()
# res = st.get_data()    # ['obj1', 'obj2']
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.


class StackObj:

    def __init__(self, data):
        self.__data = data
        self.__next = None

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, data):
        self.__data = data

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, next):
        if isinstance(next, StackObj) or next is None:
            self.__next = next


class Stack:

    def __init__(self):
        self.top = None
        self.last = None

    def push(self, obj):
        if self.last:
            self.last.next = obj
        self.last = obj

        if self.top is None:
            self.top = obj




    def pop(self):
        tail = self.top
        if tail is None:
            return

        while tail and tail.next != self.last:
            tail = tail.next
        if tail:
            tail.next = None
        last = self.last
        self.last = tail
        if self.last is None:
            self.top = None

        return last


    def get_data(self):
        res = []
        tail = self.top
        while tail:
            res.append(tail.data)
            tail = tail.next
        return res


st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st.pop()
res = st.get_data()  # ['obj1', 'obj2']
print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/q_8BdpVWbyE
#
# Подвиг 7. Объявите класс RadiusVector2D, объекты которого должны создаваться командами:
#
# v1 = RadiusVector2D()        # радиус-вектор с координатами (0; 0)
# v2 = RadiusVector2D(1)       # радиус-вектор с координатами (1; 0)
# v3 = RadiusVector2D(1, 2)    # радиус-вектор с координатами (1; 2)
# В каждом объекте класса RadiusVector2D должны формироваться локальные приватные атрибуты:
#
# __x, __y - координаты конца вектора (изначально значения равны 0, если не передано какое-либо другое).
#
# В классе RadiusVector2D необходимо объявить два объекта-свойства:
#
# x - для изменения и считывания локального атрибута __x;
# y - для изменения и считывания локального атрибута __y.
#
# При инициализации и изменении локальных атрибутов, необходимо проверять корректность передаваемых значений:
#
# - значение должно быть числом (целым или вещественным) в диапазоне [MIN_COORD; MAX_COORD].
#
# Если проверка не проходит, то координаты не меняются (напомню, что при инициализации они изначально равны 0).
# Величины MIN_COORD = -100, MAX_COORD = 1024 задаются как публичные атрибуты класса RadiusVector2D.
#
# Также в классе RadiusVector2D необходимо объявить статический метод:
#
# norm2(vector) - для вычисления квадратической нормы vector - переданного объекта класса RadiusVector2D
# (квадратическая норма вектора: x*x + y*y).
#
# P.S. В программе требуется объявить только класс. На экран ничего выводить не нужно.


class RadiusVector2D:
    MIN_COORD = -100
    MAX_COORD = 1024

    def __init__(self, x=0, y=0):
        self.__x = self.__y = 0
        if self.__is_verify(x):
            self.__x = x
        if self.__is_verify(y):
            self.__y = y

    @property
    def x_coord(self):
        return self.__x

    @x_coord.setter
    def x(self, x):
        if self.__is_verify(x):
            self.__x = x

    @property
    def y_coord(self):
        return self.__y

    @y_coord.setter
    def y(self, y):
        if self.__is_verify(y):
            self.__y = y

    @staticmethod
    def norm2(vector):
        return vector.x_coord ** 2 + vector.y_coord ** 2

    @classmethod
    def __is_verify(cls, value):
        if type(value) in (int, float) and cls.MIN_COORD <= value <= cls.MAX_COORD:
            return True
        else:
            return False


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5Y9qT5grunw
#
# Большой подвиг 8. Требуется реализовать программу по работе с решающими деревьями:
# Здесь в каждом узле дерева делается проверка (задается вопрос). Если проверка проходит, то осуществляется переход к
# следующему объекту по левой стрелке (с единицей), а иначе - по правой стрелке (с нулем). И так до тех пор, пока не
# дойдем до одного из листа дерева (вершины без потомков).
#
# В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет. Каждый элемент
# этого списка соответствует своему вопросу (своей вершине дерева), например:
# Далее, этот вектор применяется к решающему дереву, следующим образом. Корневая вершина "Любит Python" с ней связан
# первый элемент вектора x и содержит значение 1, следовательно, мы переходим по левой ветви. Попадаем в вершину
# "Понимает ООП". С ней связан второй элемент вектора x со значением 0, следовательно, мы переходим по правой ветви
# и попадаем в вершину "будет кодером". Так как эта вершина конечная (листовая), то получаем результат в виде строки
# "будет кодером". По аналогии выполняется обработка вектора x с другими наборами значений 0 и 1.
#
# Для реализации решающих деревьев в программе следует объявить два класса:
#
# TreeObj - для описания вершин и листьев решающего дерева;
# DecisionTree - для работы с решающим деревом в целом.
#
# В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):
#
# def predict(cls, root, x) - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла
# дерева root.
# def add_obj(cls, obj, node=None, left=True) - для добавления вершин в решающее дерево (метод должен возвращать
# добавленную вершину - объект класса TreeObj);
#
# В методе add_obj параметры имеют, следующие значения:
#
# obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);
# node - ссылка на объект дерева, к которому присоединяется вершина obj;
# left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви;
# False - к правой).
#
# В классе TreeObj следует объявить инициализатор:
#
# def __init__(self, indx, value=None): ...
#
# где indx - проверяемый в вершине дерева индекс вектора x; value - значение, хранящееся в вершине (принимает значение
# None для вершин, у которых есть потомки - промежуточных вершин).
#
# При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:
#
# indx - проверяемый индекс (целое число);
# value - значение с данными (строка);
# __left - ссылка на следующий объект дерева по левой ветви (изначально None);
# __right - ссылка на следующий объект дерева по правой ветви (изначально None).
#
# Для работы с локальными приватными атрибутами __left и __right необходимо объявить объекты-свойства с именами
# left и right.
#
# Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):
#
# root = DecisionTree.add_obj(TreeObj(0))
# v_11 = DecisionTree.add_obj(TreeObj(1), root)
# v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
# DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
# DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
# DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
# DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)
#
# x = [1, 1, 0]
# res = DecisionTree.predict(root, x) # будет программистом
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

class DecisionTree:

    @classmethod
    def predict(cls, root, x):
        obj = root
        while obj:
            obj_next = cls.get_next(obj, x)
            if obj_next is None:
                break
            obj = obj_next

        return obj.value

    @classmethod
    def get_next(cls, obj, x):
        if x[obj.index] == 1:
            return obj.left
        return obj.right


    @classmethod
    def add_obj(cls, obj, node=None, left=True):
        if node:
            if left:
                node.left = obj
            else:
                node.right = obj
        return obj


class TreeObj:

    def __init__(self, indx, value=None):
        self.index = indx
        self.value = value
        self.__left = None
        self.__right = None

    @property
    def left(self):
        return self.__left

    @left.setter
    def left(self, left):
        self.__left = left

    @property
    def right(self):
        return self.__right

    @right.setter
    def right(self, right):
        self.__right = right


root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)

x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/EAt0fgLNYGg
#
# Подвиг 9 (на закрепление). Вам требуется сформировать класс PathLines для описания маршрутов,
# состоящих из линейных
# сегментов. При этом каждый линейный сегмент предполагается задавать отдельным классом LineTo.
# Объекты этого класса
# будут формироваться командой:
#
# line = LineTo(x, y)
# где x, y - следующая координата линейного участка (начало маршрута из точки 0, 0).
#
# В каждом объекте класса LineTo должны формироваться локальные атрибуты:
#
# x, y - для хранения координат конца линии (начало определяется по координатам предыдущего
# объекта).
#
# Объекты класса PathLines должны создаваться командами:
#
# p = PathLines()                   # начало маршрута из точки 0, 0
# p = PathLines(line1, line2, ...)  # начало маршрута из точки 0, 0
# где line1, line2, ... - объекты класса LineTo.
#
# Сам же класс PathLines должен иметь следующие методы:
#
# get_path() - возвращает список из объектов класса LineTo (если объектов нет, то пустой список);
# get_length() - возвращает суммарную длину пути (сумма длин всех линейных сегментов);
# add_line(self, line) - добавление нового линейного сегмента (объекта класса LineTo) в конец
# маршрута.
#
# Пояснение: суммарный маршрут - это сумма длин всех линейных сегментов, а длина каждого
# линейного сегмента
# определяется как евклидовое расстояние по формуле:
#
# L = sqrt((x1-x0)^2 + (y1-y0)^2)
#
# где x0, y0 - предыдущая точка маршрута; x1, y1 - текущая точка маршрута.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# p = PathLines(LineTo(10, 20), LineTo(10, 30))
# p.add_line(LineTo(20, -10))
# dist = p.get_length()
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

class LineTo:
    def __init__(self, x, y):
        self.x = x
        self.y = y


class PathLines:

    def __init__(self, *args):
        self.lines = list((LineTo(0, 0), ) + args)

    def get_path(self):
        return self.lines[1:]

    def add_line(self, line):
        self.lines.append(line)

    def get_length(self):
        g = ((self.lines[i - 1], self.lines[i]) for i in range(1, len(self.lines)))
        return sum(map(lambda t: ((t[0].x - t[1].x) ** 2 + (t[0].y - t[1].y) ** 2) ** 0.5, g))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/TMPPmryMKD0
#
# Подвиг 10 (на закрепление). Вы создаете телефонную записную книжку. Она определяется классом
# PhoneBook. Объекты этого класса создаются командой:
#
# p = PhoneBook()
# А сам класс должен иметь следующий набор методов:
#
# add_phone(phone) - добавление нового номера телефона (в список);
# remove_phone(indx) - удаление номера телефона по индексу списка;
# get_phone_list() - получение списка из объектов всех телефонных номеров.
#
# Каждый номер телефона должен быть представлен классом PhoneNumber. Объекты этого класса должны
# создаваться командой:
#
# note = PhoneNumber(number, fio)
# где number - номер телефона (число) в формате XXXXXXXXXXX (одиннадцати цифр, X - цифра);
# fio - Ф.И.О. владельца номера (строка).
#
# В каждом объекте класса PhoneNumber должны формироваться локальные атрибуты:
#
# number - номер телефона (число);
# fio - ФИО владельца номера телефона.
#
# Необходимо объявить два класса PhoneBook и PhoneNumber в соответствии с заданием.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# p = PhoneBook()
# p.add_phone(PhoneNumber(12345678901, "Сергей Балакирев"))
# p.add_phone(PhoneNumber(21345678901, "Панда"))
# phones = p.get_phone_list()
# P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.

class PhoneBook:

    def __init__(self):
        self.phones = []

    def add_phone(self, phone):
        self.phones.append(phone)

    def remove_phone(self, indx):
        del self.phones[indx]

    def get_phone_list(self):
        return self.phones


class PhoneNumber:

    def __init__(self, number, fio):
        self.number = number
        self.fio = fio


# ======================================================================================================================
# 2.3. Дескрипторы (data descriptor и non-data descriptor)
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что из себя представляют дескрипторы?

# - это любой класс, в котором объявлены специальные методы __get__, __set__ и/или __del__
# - это любой класс, в котором объявлены специальные методы __get__ и __set__
# - это любой класс, в котором объявлен специальный метод __get__


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Чем дескрипторы концептуально отличаются от объектов-свойств (property)?

# - в одном классе дескриптора можно единожды описать логику взаимодействия с внутренними (приватными или защищенными)
# переменными
# - один класс дескриптора способен заменить множество однотипных объектов-свойств


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Какие виды дескрипторов существуют?

# - дескриптор не данных (non-data descriptor), когда в классе присутствует метод __get__, но отсутствует метод __set__
# - дескриптор данных (data descriptor), когда в классе присутствуют методы __get__ и __set__


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. В программе объявлен дескриптор RealValue и класс Point:

class RealValue:
    def __set_name__(self, owner, name):
        self.name = "_" + name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]


class Point:
    x = RealValue()
    y = RealValue()

    def __init__(self, x, y):
        self.x = x
        self.y = y

# А, затем, выполняются команды:
pt = Point(1.5, 2.3)
pt.__dict__['x'] = 10.0
print(pt.x)

# Какое значение будет выведено в консоль и почему?

# - Будет выведено 10.0, так как RealValue - это дескриптор не данных и в инициализаторе будут созданы локальные
# свойства x, y. Затем, в строчке pt.x идет обращение к локальному свойству x со значением 10.


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. В программе объявлен дескриптор StringField и класс DataBase:

class StringField:
    def __set_name__(self, owner, name):
        self.name = "_" + name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class DataBase:
    x = StringField()
    y = StringField()

    def __init__(self, x, y):
        self.x = x
        self.y = y

# А, затем, выполняются команды:

db = DataBase('hi', 'low')
db.__dict__['x'] = 'top'
print(db.x)

# Какое значение будет выведено в консоль и почему?

# - Будет выведено 'hi', так как StringField - это дескриптор данных и он имеет наибольший приоритет при обращении к
# атрибутам, поэтому в строчке db.x будет обращение к дескриптору, а не к локальному свойству.


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/xHINhSQJh5c
#
# Подвиг 6. Объявите дескриптор данных FloatValue, который бы устанавливал и возвращал вещественные значения. При
# записи вещественного числа должна выполняться проверка на вещественный тип данных. Если проверка не проходит, то
# генерировать исключение командой:
#
# raise TypeError("Присваивать можно только вещественный тип данных.")
# Объявите класс Cell, в котором создается объект value дескриптора FloatValue. А объекты класса Cell должны
# создаваться командой:
#
# cell = Cell(начальное значение ячейки)
# Объявите класс TableSheet, с помощью которого создается таблица из N строк и M столбцов следующим образом:
#
# table = TableSheet(N, M)
# Каждая ячейка этой таблицы должна быть представлена объектом класса Cell, работать с вещественными числами через
# объект value (начальное значение должно быть 0.0).
#
# В каждом объекте класса TableSheet должен формироваться локальный атрибут:
#
# cells - список (вложенный) размером N x M, содержащий ячейки таблицы (объекты класса Cell).
#
# Создайте объект table класса TableSheet с размером таблицы N = 5, M = 3. Запишите в эту таблицу числа от 1.0 до
# 15.0 (по порядку).
#
# P.S. На экран в программе выводить ничего не нужно.


class FloatValue:

    @classmethod
    def verify(cls, value):
        if type(value) != float:
            raise TypeError("Присваивать можно только вещественный тип данных.")

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        self.verify(value)
        instance.__dict__[self.name] = value


class Cell:
    value = FloatValue()

    def __init__(self, value=0.0):
        self.value = value

class TableSheet:

    def __init__(self, N, M):
        self.N = N
        self.M = M
        self.cells = [[Cell() for _ in range(self.M)] for _ in range(self.N)]


table = TableSheet(5, 3)
x = 1.0
for i in range(table.N):
    for j in range(table.M):
        table.cells[i][j].value = x
        x += 1


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/zCD5_APRzes
#
# Подвиг 7. Объявите класс ValidateString для проверки корректности переданной строки. Объекты этого класса создаются
# командой:
#
# validate = ValidateString(min_length=3, max_length=100)
# где min_length - минимальное число символов в строке; max_length - максимальное число символов в строке.
# В классе ValidateString должен быть реализован метод:
#
# validate(self, string) - возвращает True, если string является строкой (тип str) и длина строки в
# пределах [min_length; max_length]. Иначе возвращается False.
#
# Объявите дескриптор данных StringValue для работы со строками, объекты которого создаются командой:
#
# st = StringValue(validator=ValidateString(min_length, max_length))
# При каждом присвоении значения объекту st должен вызываться валидатор (объект класса ValidateString) и с помощью
# метода validate() проверяться корректность присваиваемых данных. Если данные некорректны, то присвоение не
# выполняется (игнорируется).
#
# Объявите класс RegisterForm с тремя объектами дескриптора StringValue:
#
# login = StringValue(...) - для ввода логина;
# password = StringValue(...)  - для ввода пароля;
# email = StringValue(...)  - для ввода Email.
#
# Объекты класса RegisterForm создаются командой:
#
# form = RegisterForm(логин, пароль, email)
# где логин, пароль, email - начальные значения логина, пароля и Email.
# В классе RegisterForm также должны быть объявлены методы:
#
# get_fields() - возвращает список из значений полей в порядке [login, password, email];
# show() - выводит в консоль многострочную строку в формате:
#
# <form>
# Логин: <login>
# Пароль: <password>
# Email: <email>
# </form>
#
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.


class StringValue:

    def __init__(self, validator):
        self.validator = validator

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if self.validator.validate(value):
            setattr(instance, self.name, value)


class ValidateString:

    def __init__(self, min_length=3, max_length=100):
        self.min_length = min_length
        self.max_length = max_length

    def validate(self, string):
        if type(string) == str and self.min_length <= len(string) <= self.max_length:
            return True
        return False


class RegisterForm:

    login = StringValue(validator=ValidateString())
    password = StringValue(validator=ValidateString())
    email = StringValue(validator=ValidateString())

    def __init__(self, login, password, email):
        self.login = login
        self.password = password
        self.email = email

    def get_fields(self):
        return [self.login, self.password, self.email]

    def show(self):
        print(f'<form>\nЛогин: {self.login}\nПароль: {self.password}\nEmail: {self.email}')


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/l0U_3dTJZyc
#
# Подвиг 8. Вы начинаете создавать интернет-магазин. Для этого в программе объявляется класс SuperShop, объекты
# которого создаются командой:
#
# myshop = SuperShop(название магазина)
# В каждом объекте класса SuperShop должны формироваться следующие локальные атрибуты:
#
# name - название магазина (строка);
# goods - список из товаров.
#
# Также в классе SuperShop должны быть методы:
#
# add_product(product) - добавление товара в магазин (в конец списка goods);
# remove_product(product) - удаление товара из магазина (из списка goods).
#
# Здесь product - это объект класса Product, описывающий конкретный товар. В этом классе следует объявить следующие
# дескрипторы:
#
# name = StringValue(min_length, max_length)    # min_length - минимально допустимая длина строки; max_length - максимально допустимая длина строки
# price = PriceValue(max_value)    # max_value - максимально допустимое значение
#
# Объекты класса Product будут создаваться командой:
#
# pr = Product(наименование, цена)
# Классы StringValue и PriceValue - это дескрипторы данных. Класс StringValue должен проверять, что присваивается
# строковый тип с длиной строки в диапазоне [2; 50], т.е. min_length = 2, max_length = 50. Класс PriceValue должен
# проверять, что присваивается вещественное или целочисленное значение в диапазоне [0; 10000], т.е. max_value = 10000.
# Если проверки не проходят, то соответствующие (прежние) значения меняться не должны.
#
# Пример использования класса SuperShop (эти строчки в программе писать не нужно):
#
# shop = SuperShop("У Балакирева")
# shop.add_product(Product("Курс по Python", 0))
# shop.add_product(Product("Курс по Python ООП", 2000))
# for p in shop.goods:
#     print(f"{p.name}: {p.price}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.

class StringValue:


    def __init__(self, min_length, max_length):
        self.min_length = min_length
        self.max_length = max_length

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if type(value) == str and self.min_length <= len(value) <= self.max_length:
            setattr(instance, self.name, value)


class PriceValue:

    def __init__(self, max_price):
        self.max_price = max_price

    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if type(value) in (int, float) and 0 <= value <= self.max_price:
            setattr(instance, self.name, value)


class SuperShop:

    def __init__(self, name):
        self.name = name
        self.goods = []

    def add_product(self, product):
        self.goods.append(product)

    def remove_product(self, product):
        if product in self.goods:
            self.goods.remove(product)


class Product:
    name = StringValue(2, 50)
    price = PriceValue(10000)

    def __init__(self, name, price):
        self.name = name
        self.price = price


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/S4CDXCG9nbA
#
# Подвиг 9 (на повторение). Необходимо объявить класс Bag (рюкзак), объекты которого будут создаваться командой:
#
# bag = Bag(max_weight)
# где max_weight - максимальный суммарный вес вещей, который выдерживает рюкзак (целое число).
#
# В каждом объекте этого класса должен создаваться локальный приватный атрибут:
#
# __things - список вещей в рюкзаке (изначально список пуст).
#
# Сам же класс Bag должен иметь объект-свойство:
#
# things - для доступа к локальному приватному атрибуту __things (только для считывания, не записи).
#
# Также в классе Bag должны быть реализованы следующие методы:
#
# add_thing(self, thing) - добавление нового предмета в рюкзак (добавление возможно, если суммарный вес (max_weight)
# не будет превышен, иначе добавление не происходит);
# remove_thing(self, indx) - удаление предмета по индексу списка __things;
# get_total_weight(self) - возвращает суммарный вес предметов в рюкзаке.
#
# Каждая вещь описывается как объект класса Thing и создается командой:
#
# t = Thing(название, вес)
# где название - наименование предмета (строка); вес - вес предмета (целое или вещественное число).
#
# В каждом объекте класса Thing должны формироваться локальные атрибуты:
#
# name - наименование предмета;
# weight - вес предмета.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# bag = Bag(1000)
# bag.add_thing(Thing("Книга по Python", 100))
# bag.add_thing(Thing("Котелок", 500))
# bag.add_thing(Thing("Спички", 20))
# bag.add_thing(Thing("Бумага", 100))
# w = bag.get_total_weight()
# for t in bag.things:
#     print(f"{t.name}: {t.weight}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.


class Bag:

    def __init__(self, max_weight):
        self.max_weight = max_weight
        self.weight_now = 0
        self.__things = []

    @property
    def things(self):
        return self.__things

    def add_thing(self, thing):
        if self.weight_now + thing.weight <= self.max_weight:
            self.__things.append(thing)
            self.weight_now += thing.weight

    def remove_thing(self, indx):
        self.weight_now -= self.__things[indx]
        del self.__things[indx]

    def get_total_weight(self):
        return self.weight_now


class Thing:
    def __init__(self, name, weight):
        self.name = name
        self.weight = weight


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/45q8BT03c_U
#
# Подвиг 10 (на повторение). Необходимо написать программу для представления и управления расписанием телевизионного
# вещания. Для этого нужно объявить класс TVProgram, объекты которого создаются командой:
#
# pr = TVProgram(название канала)
# где название канала - это строка с названием телеканала.
#
# В каждом объекте класса TVProgram должен формироваться локальный атрибут:
#
# items - список из телепередач (изначально список пуст).
#
# В самом классе TVProgram должны быть реализованы следующие методы:
#
# add_telecast(self, tl) - добавление новой телепередачи в список items;
# remove_telecast(self, indx) - удаление телепередачи по ее порядковому номеру (атрибуту __id, см. далее).
#
# Каждая телепередача должна описываться классом Telecast, объекты которого создаются командой:
#
# tl = Telecast(порядковый номер, название, длительность)
# где порядковый номер - номер телепередачи в сетке вещания (от 1 и далее); название - наименование телепередачи;
# длительность - время телепередачи (в секундах - целое число).
#
# Соответственно, в каждом объекте класса Telecast должны формироваться локальные приватные атрибуты:
#
# __id - порядковый номер (целое число);
# __name - наименование телепередачи (строка);
# __duration - длительность телепередачи в секундах (целое число).
#
# Для работы с этими приватными атрибутами в классе Telecast должны быть объявлены соответствующие
# объекты-свойства (property):
#
# uid - для записи и считывания из локального атрибута __id;
# name - для записи и считывания из локального атрибута __name;
# duration - для записи и считывания из локального атрибута __duration.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# pr = TVProgram("Первый канал")
# pr.add_telecast(Telecast(1, "Доброе утро", 10000))
# pr.add_telecast(Telecast(2, "Новости", 2000))
# pr.add_telecast(Telecast(3, "Интервью с Балакиревым", 20))
# for t in pr.items:
#     print(f"{t.name}: {t.duration}")
# P.S. В программе требуется объявить классы с описанным функционалом. На экран в программе выводить ничего не нужно.

class TVProgram:

    def __init__(self, name_channel):
        self.name_channel = name_channel
        self.items = []

    def add_telecast(self, tl):
        self.items.append(tl)

    def remove_telecast(self, indx):
        for i in self.items:
            if i.uid == indx:
                self.items.remove(i)
                return


class Telecast:

    def __init__(self, number, name, time):
        self.__id = number
        self.__name = name
        self.__duration = time

    @property
    def uid(self):
        return self.__id

    @uid.setter
    def uid(self, id):
        self.__id = id

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name

    @property
    def duration(self):
        return self.__duration

    @duration.setter
    def duration(self, dur):
        self.__duration = dur


# Второй вариант
class Value:
    def __set_name__(self, owner, name):
        self.name = f'__{name}'

    def __set__(self, instance, value):
        setattr(instance, self.name, value)

    def __get__(self, instance, owner):
        return property() if instance is None else getattr(instance, self.name)


class Telecast:
    uid = Value()
    name = Value()
    duration = Value()

    def __init__(self, uid: int, name: str, duration: int):
        self.uid, self.name, self.duration = uid, name, duration


class TVProgram:
    def __init__(self, name):
        self.name = name
        self.__items = {}

    @property
    def items(self):
        return [val for _, val in sorted(self.__items.items())]

    def add_telecast(self, tl: Telecast):
        self.__items[tl.uid] = tl

    def remove_telecast(self, ind):
        del self.__items[ind]


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================
# 3. Магические методы классов
# ======================================================================================================================

# ======================================================================================================================
# 3.1. Магические методы __setattr__, __getattribute__, __getattr__ и __delattr__
# ----------------------------------------------------------------------------------------------------------------------

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что в языке Python называют магическими (dunder) методами?
#  - методы с двумя нижними подчеркиваниями до и после имени метода, которые автоматически вызываются в определенных
#  для них ситуациях

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Установите соответствия между магическими методами и их описаниями.

# - __setattr__() - автоматически вызывается при изменении атрибута класса или объекта
# - __getattribute__() - автоматически вызывается при обращении к атрибуту класса или объекта
# - __getattr__() - автоматически вызывается при обращении к несуществующему атрибуту класса или объекта
# - __delattr__() - автоматически вызывается при удалении атрибута класса или объекта


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/lI99OdJt71w
#
# Подвиг 3. Объявите класс Book для представления информации о книге. Объекты этого класса должны создаваться
# командами:
#
# book = Book()
# book = Book(название, автор, число страниц, год издания)
# В каждом объекте класса Book автоматически должны формироваться следующие локальные свойства:
#
# title - заголовок книги (строка, по умолчанию пустая строка);
# author - автор книги (строка, по умолчанию пустая строка);
# pages - число страниц (целое число, по умолчанию 0);
# year - год издания (целое число, по умолчанию 0).
#
# Объявите в классе Book магический метод __setattr__ для проверки типов присваиваемых данных локальным свойствам
# title, author, pages и year. Если типы не соответствуют локальному атрибуту (например, title должна ссылаться на
# строку, а pages - на целое число), то генерировать исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# Создайте в программе объект book класса Book для книги:
#
# автор: Сергей Балакирев
# заголовок: Python ООП
# pages: 123
# year: 2022
#
# P.S. На экран ничего выводить не нужно.

class Book:

    def __init__(self, title='', author='', pages=0, year=0):
        self.title = title
        self.author = author
        self.pages = pages
        self.year = year

    def __setattr__(self, key, value):
        if key in ('title', 'author') and type(value) != str or key in ('pages', 'year') and type(value) != int:
            raise TypeError("Неверный тип присваиваемых данных.")
        object.__setattr__(self, key, value)

book = Book(title = 'Python ООП', author = 'Сергей Балакирев', pages=123, year=2022)


# ----------------------------------------------------------------------------------------------------------------------
class Shop:

    def __init__(self, name):
        self.name = name
        self.goods = []

    def add_product(self, product):
        self.goods.append(product)

    def remove_product(self, product):
        if product in self.goods:
            self.goods.remove(product)

class Product:
    id = 1
    attrs = {'name': (str, ), 'weight': (int, float), 'price': (int, float)}

    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price
        self.id = Product.id
        Product.id += 1

    def __setattr__(self, key, value):
        if key in self.attrs and type(value) in self.attrs[key]:
            if (key == 'price' or key == 'weight') and value <= 0:
                raise TypeError('Неверный тип присваиваемых данных.')
        elif key in self.attrs:
            raise TypeError('Неверный тип присваиваемых данных.')

        object.__setattr__(self, key, value)

    def __delattr__(self, item):
        if item == 'id':
            raise AttributeError("Атрибут id удалять запрещено.")
        object.__delattr__(self, item)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/7b8d5zqiiAM
#
# Подвиг 5. Необходимо создать программу для обучающего курса. Для этого объявляются три класса:
#
# Course - класс, отвечающий за управление курсом в целом;
# Module - класс, описывающий один модуль (раздел) курса;
# LessonItem - класс одного занятия (урока).
#
# Структура курса на уровне этих классов, приведена на рисунке ниже:

# Объекты класса LessonItem должны создаваться командой:
#
# lesson = LessonItem(название урока, число практических занятий, общая длительность урока)
# Соответственно, в каждом объекте класса LessonItem должны создаваться локальные атрибуты:
#
# title - название урока (строка);
# practices - число практических занятий (целое положительное число);
# duration - общая длительность урока (целое положительное число).
#
# Необходимо с помощью магических методов реализовать следующую логику взаимодействия с объектами класса LessonItem:
#
# 1. Проверять тип присваиваемых данных локальным атрибутам. Если типы не соответствуют требованиям, то генерировать
# исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# 2. При обращении к несуществующим атрибутам объектов класса LessonItem возвращать значение False.
# 3. Запретить удаление атрибутов title, practices и duration в объектах класса LessonItem.
#
# Объекты класса Module должны создаваться командой:
#
# module = Module(название модуля)
# Каждый объект класса Module должен содержать локальные атрибуты:
#
# name - название модуля;
# lessons - список из уроков (объектов класса LessonItem), входящих в модуль (изначально список пуст).
#
# Также в классе Module должны быть реализованы методы:
#
# add_lesson(self, lesson) - добавление в модуль (в конец списка lessons) нового урока (объекта класса LessonItem);
# remove_lesson(self, indx) - удаление урока по индексу в списке lessons.
#
# Наконец, объекты класса Course создаются командой:
#
# course = Course(название курса)
# И содержат следующие локальные атрибуты:
#
# name - название курса (строка);
# modules - список модулей в курсе (изначально список пуст).
#
# Также в классе Course должны присутствовать следующие методы:
#
# add_module(self, module) - добавление нового модуля в конце списка modules;
# remove_module(self, indx) - удаление модуля из списка modules по индексу в этом списке.
#
# Пример использования классов (в программе эти строчки не писать):
#
# course = Course("Python ООП")
# module_1 = Module("Часть первая")
# module_1.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_1.add_lesson(LessonItem("Урок 2", 10, 1200))
# module_1.add_lesson(LessonItem("Урок 3", 5, 800))
# course.add_module(module_1)
# module_2 = Module("Часть вторая")
# module_2.add_lesson(LessonItem("Урок 1", 7, 1000))
# module_2.add_lesson(LessonItem("Урок 2", 10, 1200))
# course.add_module(module_2)
# P.S. На экран ничего выводить не нужно.


class LessonItem:

    def __init__(self, title, practices, duration):
        self.title = title
        self.practices = practices
        self.duration = duration

    def __setattr__(self, key, value):
        if key == 'title' and type(value) != str or key in ('practices', 'duration') and type(value) != int and value <= 0:
            raise TypeError("Неверный тип присваиваемых данных.")
        object.__setattr__(self, key, value)

    def __getattr__(self, item):
        return False

    def __delattr__(self, item):
        if item in ('title', 'practices', 'duration'):
            raise AttributeError(f"Атрибут {item} удалять запрещено.")
        object.__delattr__(self, item)


class Module:

    def __init__(self, name):
        self.name = name
        self.lessons = []

    def add_lesson(self, lesson):
        self.lessons.append(lesson)

    def remove_lesson(self, indx):
        del self.lessons[indx]


class Course:

    def __init__(self, name):
        self.name = name
        self.modules = []

    def add_module(self, module):
        self.modules.append(module)

    def remove_module(self, indx):
        del self.modules[indx]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/oyeub94DCKw
#
# Подвиг 6. Вам необходимо написать программу описания музеев. Для этого нужно объявить класс Museum, объекты которого
# формируются командой:
#
# mus = Museum(название музея)
# В объектах этого класса должны формироваться следующие локальные атрибуты:
#
# name - название музея (строка);
# exhibits - список экспонатов (изначально пустой список).
#
# Сам класс Museum должен иметь методы:
#
# add_exhibit(self, obj) - добавление нового экспоната в музей (в конец списка exhibits);
# remove_exhibit(self, obj) - удаление экспоната из музея (из списка exhibits по ссылке obj - на экспонат)
# get_info_exhibit(self, indx) - получение информации об экспонате (строка) по индексу списка (нумерация с нуля).
#
# Экспонаты представляются объектами своих классов. Для примера объявите в программе следующие классы экспонатов:
#
# Picture - для картин;
# Mummies - для мумий;
# Papyri - для папирусов.
#
# Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):
#
# p = Picture(название, художник, описание)            # локальные атрибуты: name - название; author - художник;
# descr - описание

# m = Mummies(имя мумии, место находки, описание)      # локальные атрибуты: name - имя мумии;
# location - место находки; descr - описание

# pr = Papyri(название папируса, датировка, описание)  # локальные атрибуты: name - название папируса;
# date - датировка (строка); descr - описание
# Метод get_info_exhibit() класса Museum должен возвращать значение атрибута descr указанного экспоната в формате:
#
# "Описание экспоната {name}: {descr}"
#
# Например:
#
# "Описание экспоната Девятый вал: Айвазовский написал супер картину."
#
# Пример использования классов (в программе эти строчки писать не нужно - только для примера):
#
# mus = Museum("Эрмитаж")
# mus.add_exhibit(Picture("Балакирев с подписчиками пишет письмо иноземному султану", "Неизвестный автор",
# "Вдохновляющая, устрашающая, волнующая картина"))

# mus.add_exhibit(Mummies("Балакирев", "Древняя Россия", "Просветитель XXI века, удостоенный мумификации"))

# p = Papyri("Ученья для, не злата ради", "Древняя Россия", "Самое древнее найденное рукописное свидетельство
# о языках программирования")

# mus.add_exhibit(p)
# for x in mus.exhibits:
#     print(x.descr)

# P.S. На экран ничего выводить не нужно.


class Museum:

    def __init__(self, name):
        self.name = name
        self.exhibits = []

    def add_exhibit(self, obj):
        self.exhibits.append(obj)

    def remove_exhibit(self, obj):
        self.exhibits.remove(obj)

    def get_info_exhibit(self, indx):
        return f'Описание экспоната {self.exhibits[indx].name}: {self.exhibits[indx].descr}'


class Picture:

    def __init__(self, name, author, descr):
        self.name = name
        self.author = author
        self.descr = descr


class Mummies:

    def __init__(self, name, location, descr):
        self.name = name
        self.location = location
        self.descr = descr


class Papyri:

    def __init__(self, name, date, descr):
        self.name = name
        self.date = date
        self.descr = descr


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Xq19kCDRaag
#
# Подвиг 7 (на повторение). Объявите класс SmartPhone, объекты которого предполагается создавать командой:
#
# sm = SmartPhone(марка смартфона)
# Каждый объект должен содержать локальные атрибуты:
#
# model - марка смартфона (строка);
# apps - список из установленных приложений (изначально пустой).
#
# Также в классе SmartPhone должны быть объявлены следующие методы:
#
# add_app(self, app) - добавление нового приложения на смартфон (в конец списка apps);
# remove_app(self, app) - удаление приложения по ссылке на объект app.
#
# При добавлении нового приложения проверять, что оно отсутствует в списке apps (отсутствует объект соответствующего
# класса).
#
# Каждое приложение должно определяться своим классом. Для примера объявите следующие классы:
#
# AppVK - класс приложения ВКонтаке;
# AppYouTube - класс приложения YouTube;
# AppPhone - класс приложения телефона.
#
# Объекты этих классов должны создаваться следующим образом (с соответствующим набором локальных атрибутов):
#
# app_1 = AppVK() # name = "ВКонтакте"
# app_2 = AppYouTube(1024) # name = "YouTube", memory_max = 1024
# app_3 = AppPhone({"Балакирев": 1234567890, "Сергей": 98450647365, "Работа": 112}) # name = "Phone",
# phone_list = словарь с контактами

# Пример использования классов (в программе эти строчки не писать):
#
# sm = SmartPhone("Honor 1.0")
# sm.add_app(AppVK())
# sm.add_app(AppVK())  # второй раз добавляться не должно
# sm.add_app(AppYouTube(2048))
# for a in sm.apps:
#     print(a.name)
# P.S. На экран ничего выводить не нужно.


class SmartPhone:

    def __init__(self, model):
        self.model = model
        self.apps = []

    def add_app(self, app):
        if len(tuple(filter(lambda x: type(x) == type(app), self.apps))) == 0:
            self.apps.append(app)

    def remove_app(self, app):
        self.apps.remove(app)


class AppVK:

    def __init__(self):
        self.name = 'Вконтакте'


class AppYouTube:

    def __init__(self, memory_max):
        self.name = 'YouTube'
        self.memory_max = memory_max


class AppPhone:

    def __init__(self, phone_list):
        self.name = 'Phone'
        self.phone_list = phone_list


# Второе решение___________________________________________________

class SmartPhone:
    def __init__(self, model):
        self.model, self.apps = model, []
    def add_app(self, app):
        if app.__class__ not in (i.__class__ for i in self.apps):
            self.apps.append(app)
    def remove_app(self, app):
        self.apps.remove(app) if app in self.apps else ...

class AppVK:
    def __init__(self, name = "ВКонтакте"):
        self.name = name
class AppYouTube:
    def __init__(self, memory_max, name = "YouTube"):
        self.name, self.memory_max = name, memory_max
class AppPhone:
    def __init__(self, phone_list: dict, name = "Phone"):
        self.name, self.phone_list = name, phone_list


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/vOh4gzHnMWg
#
# Подвиг 8. Объявите класс Circle (окружность), объекты которого должны создаваться командой:
#
# circle = Circle(x, y, radius)   # x, y - координаты центра окружности; radius - радиус окружности
# В каждом объекте класса Circle должны формироваться локальные приватные атрибуты:
#
# __x, __y - координаты центра окружности (вещественные или целые числа);
# __radius - радиус окружности (вещественное или целое положительное число).
#
# Для доступа к этим приватным атрибутам в классе Circle следует объявить объекты-свойства (property):
#
# x, y - для изменения и доступа к значениям __x, __y, соответственно;
# radius - для изменения и доступа к значению __radius.
#
# При изменении значений приватных атрибутов через объекты-свойства нужно проверять, что присваиваемые
# значения - числа (целые или вещественные). Дополнительно у радиуса проверять, что число должно быть
# положительным (строго больше нуля). Сделать все эти проверки нужно через магические методы.
# При некорректных переданных числовых значениях, прежние значения меняться не должны (исключений
# никаких генерировать при этом не нужно).
#
# Если присваиваемое значение не числовое, то генерировать исключение командой:
#
# raise TypeError("Неверный тип присваиваемых данных.")
# При обращении к несуществующему атрибуту объектов класса Circle выдавать булево значение False.
#
# Пример использования класса (эти строчки в программе писать не нужно):
#
# circle = Circle(10.5, 7, 22)
# circle.radius = -10 # прежнее значение не должно меняться, т.к. отрицательный радиус недопустим
# x, y = circle.x, circle.y
# res = circle.name # False, т.к. атрибут name не существует
# P.S. На экран ничего выводить не нужно.


class Circle:
    attrs = {'x': (int, float), 'y': (int, float), 'radius': (int, float)}

    def __init__(self, x, y, radius):
        self.__x = self.__y = self.__radius = None
        self.x = x
        self.y = y
        self.radius = radius

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, x):
        self.__x = x

    @property
    def y(self):
        return self.__y

    @y.setter
    def y(self, y):
        self.__y = y

    @property
    def radius(self):
        return self.__radius

    @radius.setter
    def radius(self, radius):
        self.__radius = radius

    def __getattr__(self, item):
        return False

    def __setattr__(self, key, value):
        if key in self.attrs and type(value) not in self.attrs[key]:
            raise TypeError("Неверный тип присваиваемых данных.")
        if key == 'radius' and value < 0:
            return
        super().__setattr__(key, value)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/2iS8qnEK9to
#
# Подвиг 9. Объявите в программе класс Dimensions (габариты) с атрибутами:
#
# MIN_DIMENSION = 10
# MAX_DIMENSION = 1000
#
# Каждый объект класса Dimensions должен создаваться командой:
#
# d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
# и содержать локальные атрибуты:
#
# __a, __b, __c - габаритные размеры (целые или вещественные числа).
#
# Для работы с этими локальными атрибутами в классе Dimensions следует прописать следующие объекты-свойства:
#
# a, b, c - для изменения и считывания соответствующих локальных атрибутов __a, __b, __c.
#
# При изменении значений __a, __b, __c следует проверять, что присваиваемое значение число в диапазоне [MIN_DIMENSION; MAX_DIMENSION]. Если это не так, то новое значение не присваивается (игнорируется).
#
# С помощью магических методов данного занятия запретить создание локальных атрибутов MIN_DIMENSION и MAX_DIMENSION в объектах класса Dimensions. При попытке это сделать генерировать исключение:
#
# raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
# Пример использования класса  (эти строчки в программе писать не нужно):
#
# d = Dimensions(10.5, 20.1, 30)
# d.a = 8
# d.b = 15
# a, b, c = d.a, d.b, d.c  # a=10.5, b=15, c=30
# d.MAX_DIMENSION = 10  # исключение AttributeError
# P.S. В программе нужно объявить только класс Dimensions. На экран ничего выводить не нужно.


class Dimensions:
    MIN_DIMENSION = 10
    MAX_DIMENSION = 1000

    def __init__(self, a, b, c):
        self.__a = self.__b = self.__c = None
        self.a = a
        self.b = b
        self.c = c

    @property
    def a(self):
        return self.__a

    @a.setter
    def a(self, value):
        if self.__verify_value(value):
            self.__a = value

    @property
    def b(self):
        return self.__b

    @b.setter
    def b(self, value):
        if self.__verify_value(value):
            self.__b = value

    @property
    def c(self):
        return self.__c

    @c.setter
    def c(self, value):
        if self.__verify_value(value):
            self.__c = value

    @classmethod
    def __verify_value(cls, value):
        return type(value) in (int, float) and cls.MIN_DIMENSION <= value <= cls.MAX_DIMENSION


    def __setattr__(self, key, value):
        if key in ('MIN_DIMENSION', 'MAX_DIMENSION'):
            raise AttributeError("Менять атрибуты MIN_DIMENSION и MAX_DIMENSION запрещено.")
        super().__setattr__(key, value)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/FaHqn8Yr45o
#
# Подвиг 10. Объявите класс GeyserClassic - фильтр для очистки воды. В этом классе должно быть три слота для фильтров.
# Каждый слот строго для своего класса фильтра:
#
# Mechanical - для очистки от крупных механических частиц;
# Aragon - для последующей очистки воды;
# Calcium - для обработки воды на третьем этапе.
#
#
#
# Объекты классов фильтров должны создаваться командами:
#
# filter_1 = Mechanical(дата установки)
# filter_2 = Aragon(дата установки)
# filter_3 = Calcium(дата установки)
# Во всех объектах этих классов должен формироваться локальный атрибут:
#
# date - дата установки фильтров (для простоты - положительное вещественное число).
#
# Также нужно запретить изменение этого атрибута после создания объектов этих классов (только чтение). В случае
# присвоения нового значения, прежнее значение не менять. Ошибок никаких не генерировать.
#
# Объекты класса GeyserClassic должны создаваться командой:
#
# g = GeyserClassic()
# А сам класс иметь атрибут:
#
# MAX_DATE_FILTER = 100 - максимальное время работы фильтра (любого)
#
# и следующие методы:
#
# add_filter(self, slot_num, filter) - добавление фильтра filter в указанный слот slot_num (номер слота: 1, 2 и 3),
# если он (слот) пустой (без фильтра). Также здесь следует проверять, что в первый слот можно установить только
# объекты класса Mechanical, во второй - объекты класса Aragon и в третий - объекты класса Calcium. Иначе слот
# должен оставаться пустым.
#
# remove_filter(self, slot_num) - извлечение фильтра из указанного слота (slot_num: 1, 2, и 3);
#
# get_filters(self) - возвращает кортеж из набора трех фильтров в порядке их установки (по возрастанию номеров слотов);
#
# water_on(self) - включение воды: возвращает True, если вода течет и False - в противном случае.
#
# Метод water_on() должен возвращать значение True при выполнении следующих условий:
#
# - все три фильтра установлены в слотах;
# - все фильтры работают в пределах срока службы (значение (time.time() - date) должно быть
# в пределах [0; MAX_DATE_FILTER])
#
# Пример использования классов  (эти строчки в программе писать не нужно):
#
# my_water = GeyserClassic()
# my_water.add_filter(1, Mechanical(time.time()))
# my_water.add_filter(2, Aragon(time.time()))
# w = my_water.water_on() # False
# my_water.add_filter(3, Calcium(time.time()))
# w = my_water.water_on() # True
# f1, f2, f3 = my_water.get_filters()  # f1, f2, f3 - ссылки на соответствующие объекты классов фильтров
# my_water.add_filter(3, Calcium(time.time())) # повторное добавление в занятый слот невозможно
# my_water.add_filter(2, Calcium(time.time())) # добавление в "чужой" слот также невозможно
# P.S. На экран ничего выводить не нужно.
import time

class GeyserClassic:
    MAX_DATE_FILTER = 100

    def __init__(self):
        self.filter_class = ('Mechanical', 'Aragon', 'Calcium')
        # self.filters = {(1, self.filter_class[0]): None, (2, self.filter_class[1]): None,
        #                 (3, self.filter_class[2]): None}
        self.filters = {(key + 1, self.filter_class[key]): None for key in range(3)}

    def add_filter(self, slot_num, filter):
        key = (slot_num, filter.__class__.__name__)
        if key in self.filters and not self.filters[key]:
            self.filters[key] = filter

    def remove_filter(self, slot_num):
        if type(slot_num) == int and 1 <= slot_num <= 3:
            key = (slot_num, self.filter_class[slot_num - 1])
            if key in self.filters:
                self.filters[key] = None

    def get_filters(self):
        return tuple(self.filters.values())

    def water_on(self):
        end = time.time()
        for f in self.filters.values():
            if f is None:
                return False
            start = f.date
            if end - start > self.MAX_DATE_FILTER:
                return False
        return True



class Mechanical:

    def __init__(self, date):
        self.date = date

    def __setattr__(self, key, value):
        if key == 'date' and key in self.__dict__:
            return
        super().__setattr__(key, value)


class Aragon:

    def __init__(self, date):
        self.date = date

    def __setattr__(self, key, value):
        if key == 'date' and key in self.__dict__:
            return
        super().__setattr__(key, value)


class Calcium:

    def __init__(self, date):
        self.date = date

    def __setattr__(self, key, value):
        if key == 'date' and key in self.__dict__:
            return
        super().__setattr__(key, value)


# Второе решение _____________________________________________
import time


class Filter:
    def __init__(self, date) -> None:
        self.date = date

    def __setattr__(self, key, value) -> None:
        if key == 'date' and hasattr(self, key):
            pass
        else:
            object.__setattr__(self, key, value)


class Mechanical(Filter):
    pass


class Aragon(Filter):
    pass


class Calcium(Filter):
    pass


class GeyserClassic:
    MAX_DATE_FILTER = 100
    d = {1: Mechanical, 2: Aragon, 3: Calcium}

    def __init__(self) -> None:
        self.slots = [None] * 3

    def add_filter(self, slot_num, filter):
        if self.d[slot_num] == type(filter):
            self.slots[slot_num - 1] = filter

    def remove_filter(self, slot_num):
        self.slots[slot_num - 1] = None

    def get_filters(self):
        return tuple(self.slots)

    def water_on(self):
        return all([i != None and 0 <= time.time() - i.date <= self.MAX_DATE_FILTER for i in self.slots])


# ======================================================================================================================
# 3.2 Метод __call__. Функторы и классы-декораторы
# ======================================================================================================================


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Что делает магический метод __call__()?
# - позволяет вызывать объекты класса подобно функциям, в котором определен метод __call__()


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/fiYiJWXv-5I
#
# Подвиг 2. Объявите класс RandomPassword для генерации случайных паролей. Объекты этого класса должны создаваться
# командой:
#
# rnd = RandomPassword(psw_chars, min_length, max_length)
# где psw_chars - строка из разрешенных в пароле символов; min_length, max_length - минимальная и максимальная длина
# генерируемых паролей.
#
# Непосредственная генерация одного пароля должна выполняться командой:
#
# psw = rnd()
# где psw - ссылка на строку длиной в диапазоне [min_length; max_length] из случайно выбранных символов
# строки psw_chars.
#
# С помощью генератора списка (list comprehension) создайте список lst_pass из трех сгенерированных паролей объектом rnd
# класса RandomPassword, созданного с параметрами:
#
# min_length = 5
# max_length = 20
# psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"
# P.S. Выводить на экран ничего не нужно, только создать список из паролей.
#
# P.P.S. Дополнительное домашнее задание: попробуйте реализовать этот же функционал с использованием замыканий функций.


from random import randint, choice # функция для генерации целых случайных значений в диапазоне [a; b]

# здесь объявляйте класс RandomPassword
class RandomPassword:

    def __init__(self, psw_chars, min_length, max_length):
        self.psw_chars = psw_chars
        self.min_length = min_length
        self.max_length = max_length

    def __call__(self, *args, **kwargs):
        psw = ''
        len_psw = randint(self.min_length, self.max_length)
        while len(psw) != len_psw:
            psw += choice(self.psw_chars)
        return psw


min_length = 5
max_length = 20
psw_chars = "qwertyuiopasdfghjklzxcvbnm0123456789!@#$%&*"

rnd = RandomPassword(psw_chars, min_length, max_length)

lst_pass = [rnd() for _ in range(3)]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/JIQhCEqb4rU
#
# Подвиг 3. Для последовательной обработки файлов из некоторого списка, например:
#
# filenames = ["boat.jpg", "web.png", "text.txt", "python.doc", "ava.8.jpg", "forest.jpeg", "eq_1.png",
# "eq_2.png", "my.html", "data.shtml"]

# Необходимо объявить класс ImageFileAcceptor, который бы выделял только файлы с указанными расширениями.
#
# Для этого предполагается создавать объекты класса командой:
#
# acceptor = ImageFileAcceptor(extensions)
# где extensions - кортеж с допустимыми расширениями файлов, например: extensions = ('jpg', 'bmp', 'jpeg').
#
# А, затем, использовать объект acceptor в стандартной функции filter языка Python следующим образом:
#
# image_filenames = filter(acceptor, filenames)
# Пример использования класса (эти строчки в программе писать не нужно):
#
# filenames = ["boat.jpg", "web.png", "text.txt", "python.doc", "ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.png"]
# acceptor = ImageFileAcceptor(('jpg', 'bmp', 'jpeg'))
# image_filenames = filter(acceptor, filenames)
# print(list(image_filenames))  # ["boat.jpg", "ava.jpg", "forest.jpeg"]
# P.S. Ваша задача только объявить класс ImageFileAcceptor. На экран ничего выводить не нужно.

class ImageFileAcceptor:

    def __init__(self, extensions):
        self.extensions = extensions

    def __call__(self, name, *args, **kwargs):
        start = name.rfind('.')
        ext = '' if start == -1 else name[start + 1:]
        return ext in self.extensions


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/e1U6SoX1ChI
#
# Подвиг 4. Предположим, мы разрабатываем класс для обработки формы авторизации на стороне сервера. Для этого был создан
# следующий класс с именем LoginForm:

# class LoginForm:
#     def __init__(self, name, validators=None):
#         self.name = name
#         self.validators = validators
#         self.login = ""
#         self.password = ""
#
#     def post(self, request):
#         self.login = request.get('login', "")
#         self.password = request.get('password', "")
#
#     def is_validate(self):
#         if not self.validators:
#             return True
#
#         for v in self.validators:
#             if not v(self.login) or not v(self.password):
#                 return False
#
#         return True

# Здесь name - это заголовок формы (строка); validators - список из валидаторов для проверки корректности поля. В методе
# post параметр request - это словарь с ключами 'login' и 'password' и значениями (строками) для логина и пароля
# соответственно.
#
# Пример использования класса LoginForm (в программе не писать):

# from string import ascii_lowercase, digits
#
# lg = LoginForm("Вход на сайт", validators=[LengthValidator(3, 50), CharsValidator(ascii_lowercase + digits)])
# lg.post({"login": "root", "password": "panda"})
# if lg.is_validate():
#     print("Дальнейшая обработка данных формы")

# Вам необходимо в программе объявить классы валидаторов:
#
# LengthValidator - для проверки длины данных в диапазоне [min_length; max_length];
# CharsValidator - для проверки допустимых символов в строке.
#
# Объекты этих классов должны создаваться командами:
#
# lv = LengthValidator(min_length, max_length) # min_length - минимально допустимая длина; max_length - максимально
# допустимая длина
# cv = CharsValidator(chars) # chars - строка из допустимых символов
# Для проверки корректности данных каждый валидатор должен вызываться как функция:
#
# res = lv(string)
# res = cv(string)
# и возвращать True, если string удовлетворяет условиям валидатора и False - в противном случае.
#
# P.S. В программе следует только объявить два класса валидаторов, на экран выводить ничего не нужно.


class LoginForm:
    def __init__(self, name, validators=None):
        self.name = name
        self.validators = validators
        self.login = ""
        self.password = ""

    def post(self, request):
        self.login = request.get('login', "")
        self.password = request.get('password', "")

    def is_validate(self):
        if not self.validators:
            return True

        for v in self.validators:
            if not v(self.login) or not v(self.password):
                return False

        return True


class LengthValidator:

    def __init__(self, min_length, max_length):
        self.min_length = min_length
        self.max_length = max_length

    def __call__(self, value, *args, **kwargs):
        return self.min_length <= len(value) <= self.max_length

class CharsValidator:

    def __init__(self, chars):
        self.chars = chars

    def __call__(self, value, *args, **kwargs):
        for i in value:
            if i not in self.chars:
                return False
        return True


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/YYUPa-0IeQU
#
# Подвиг 5. Объявите класс DigitRetrieve для преобразования данных из строки в числа. Объекты этого класса создаются
# командой:
#
# dg = DigitRetrieve()
# Затем, их предполагается использовать, например следующим образом:
#
# d1 = dg("123")   # 123 (целое число)
# d2 = dg("45.54")   # None (не целое число)
# d3 = dg("-56")   # -56 (целое число)
# d4 = dg("12fg")  # None (не целое число)
# d5 = dg("abc")   # None (не целое число)
# То есть, целые числа в строке следует приводить к целочисленному типу данных, а все остальные - к значению None.
#
# С помощью объектов класса DigitRetrieve должно выполняться преобразование чисел из списка строк следующим образом:
#
# st = ["123", "abc", "-56.4", "0", "-5"]
# digits = list(map(dg, st))  # [123, None, None, 0, -5]
# P.S. На экран ничего выводить не нужно.

class DigitRetrieve:

    def __call__(self, value, *args, **kwargs):
        try:
            return int(value)
        except ValueError:
            return None


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/wp4CyhdXcbY
#
# Подвиг 6. Предположим, вам необходимо создать программу по преобразованию списка строк, например:
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# в следующий фрагмент HTML-разметки (многострочной строки, кавычки выводить не нужно):
#
# '''<ul>
# <li>Пункт меню 1</li>
# <li>Пункт меню 2</li>
# <li>Пункт меню 3</li>
# </ul>'''
#
# Для этого необходимо объявить класс RenderList, объекты которого создаются командой:
#
# render = RenderList(type_list)
# где type_list - тип списка (принимает значения: "ul" - для списка с тегом <ul> и "ol" - для списка с тегом <ol>).
# Если значение параметра type_list другое (не "ul" и не "ol"), то формируется список с тегом <ul>.
#
# Затем, предполагается использовать объект render следующим образом:
#
# html = render(lst) # возвращается многострочная строка с соответствующей HTML-разметкой
# Пример использования класса (эти строчки в программе писать не нужно):
#
# lst = ["Пункт меню 1", "Пункт меню 2", "Пункт меню 3"]
# render = RenderList("ol")
# html = render(lst)
# P.S. На экран ничего выводить не нужно.


class RenderList:

    def __init__(self, type_list = 'ul'):
        self.type_list = type_list


    def __call__(self, lst, *args, **kwargs):
        res = f'<{self.type_list}>\n'
        for i in lst:
            res += f'<li>{i}</li>\n'
        res += f'</{self.type_list}>'
        return res


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Ac0s64-XEdE
#
# Подвиг 7. Необходимо объявить класс-декоратор с именем HandlerGET, который будет имитировать обработку GET-запросов
# на стороне сервера. Для этого сам класс HandlerGET нужно оформить так, чтобы его можно было применять к любой функции
# как декоратор. Например:
#
# @HandlerGET
# def contact(request):
#     return "Сергей Балакирев"
# Здесь request - это произвольный словарь с данными текущего запроса, например,
# такой: {"method": "GET", "url": "contact.html"}. А функция должна возвращать строку.
#
# Затем, при вызове декорированной функции:
#
# res = contact({"method": "GET", "url": "contact.html"})
# должна возвращаться строка в формате:
#
# "GET: <данные из функции>"
#
# В нашем примере - это будет:
#
# "GET: Сергей Балакирев"
#
# Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если же ключ method
# принимает другое значение, например, "POST", то декорированная функция contact должна возвращать значение None.
#
# Для реализации имитации GET-запроса в классе HandlerGET следует объявить вспомогательный метод со следующей сигнатурой:
#
# def get(self, func, request, *args, **kwargs): ...
# Здесь func - ссылка на декорируемую функцию; request - словарь с переданными данными при вызове декорированной
# функции. Именно в этом методе следует формировать возвращаемую строку в указанном формате:
#
# "GET: Сергей Балакирев"
#
# P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.


class HandlerGET:

    def __init__(self, func):
        self.func = func

    def __call__(self, request, *args, **kwargs):
        m = request.get('method', 'GET')
        if m == 'GET':
            return self.get(self.func, request)
        return None

    def get(self, func, request, *args, **kwargs):
        return f'GET:{func(request)}'


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/FyL9RyFGGCo
#
# Подвиг 8 (развитие подвига 7). Необходимо объявить класс-декоратор с именем Handler, который можно было бы применять
# к функциям следующим образом:
#
# @Handler(methods=('GET', 'POST')) # по умолчанию methods = ('GET',)
# def contact(request):
#     return "Сергей Балакирев"
# Здесь аргумент methods декоратора Handler содержит список разрешенных запросов для обработки. Сама декорированная
# функция вызывается по аналогии с предыдущим подвигом:
#
# res = contact({"method": "POST", "url": "contact.html"})
# В результате функция contact должна возвращать строку в формате:
#
# "<метод>: <данные из функции>"
#
# В нашем примере - это будет:
#
# "POST: Сергей Балакирев"
#
# Если ключ method в словаре request отсутствует, то по умолчанию подразумевается GET-запрос. Если ключ method
# принимает значение отсутствующее в списке methods декоратора Handler, например, "PUT", то декорированная функция
# contact должна возвращать значение None.
#
# Для имитации GET и POST-запросов в классе Handler необходимо объявить два вспомогательных метода с сигнатурами:
#
# def get(self, func, request, *args, **kwargs) - для имитации обработки GET-запроса
# def post(self, func, request, *args, **kwargs) - для имитации обработки POST-запроса
#
# В зависимости от типа запроса должен вызываться соответствующий метод (его выбор в классе можно реализовать
# методом __getattribute__()). На выходе эти методы должны формировать строки в заданном формате.
#
# P.S. В программе достаточно объявить только класс. Ничего на экран выводить не нужно.
#
# Небольшая справка
# Для реализации декоратора с параметрами на уровне класса в инициализаторе __init__(self, methods) прописываем
# параметр для декоратора, а магический метод __call__() объявляем как полноценный декоратор на уровне функции,
# например:
#
# class Handler:
#     def __init__(self, methods):
#         # здесь нужные строчки
#
#     def __call__(self, func):
#         def wrapper(request, *args, **kwargs):
#             # здесь нужные строчки
#         return wrapper


class Handler:

    def __init__(self, methods = ('GET',)):
        self.__methods = methods

    def __call__(self, func, *args, **kwargs):
        def wrapper(request):
            m = request.get('method', 'GET')
            if m in self.__methods:
                method = m.lower()
                return self.__getattribute__(method)(func, request)
        return wrapper


    def get(self, func, request, *args, **kwargs):
        return f'GET: {func(request)}'

    def post(self, func, request, *args, **kwargs):
        return f'POST: {func(request)}'


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/EEzEodYvoXc
#
# Подвиг 9. Объявите класс-декоратор InputDigits для декорирования стандартной функции input так, чтобы при вводе
# строки из целых чисел, записанных через пробел, например:
#
# "12 -5 10 83"
#
# на выходе возвращался список из целых чисел:
#
# [12, -5, 10, 83]
#
# Назовите декорированную функцию input_dg и вызовите ее командой:
#
# res = input_dg()
# P.S. На экран ничего выводить не нужно.

class InputDigits:

    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        return list(map(int, self.func.split()))

input_dg = InputDigits(input())
res = input_dg()


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/H4cJ0fBVHpc
#
# Подвиг 10 (развитие подвига 9). Объявите класс-декоратор InputValues с параметром render - функция или объект для
# преобразования данных из строк в другой тип данных. Чтобы реализовать такой декоратор в инициализаторе __init__() следует указать параметр render, а магический метод __call__() определяется как функция-декоратор:
#
# class InputValues:
#     def __init__(self, render):     # render - ссылка на функцию или объект для преобразования
#         # здесь строчки программы
#
#     def __call__(self, func):     # func - ссылка на декорируемую функцию
#         def wrapper(*args, **kwargs):
#             # здесь строчки программы
#         return wrapper
# В качестве рендера объявите класс с именем RenderDigit, который бы преобразовывал строковые данные в целые числа.
# Объекты этого класса создаются командой:
#
# render = RenderDigit()
# и применяются следующим образом:
#
# d1 = render("123")   # 123 (целое число)
# d2 = render("45.54")   # None (не целое число)
# d3 = render("-56")   # -56 (целое число)
# d4 = render("12fg")  # None (не целое число)
# d5 = render("abc")   # None (не целое число)
# Декорируйте стандартную функцию input декоратором InputValues и объектом рендера класса RenderDigit так, чтобы на
# выходе при вводе целых чисел через пробел возвращался список из введенных значений. А на месте не целочисленных
# данных - значение None.
#
# Например, при вводе строки:
#
# "1 -5.3 0.34 abc 45f -5"
#
# должен возвращаться список:
#
# [1, None, None, None, None, -5]
#
# Назовите декорированную функцию input_dg и вызовите ее командой:
#
# res = input_dg()
# Выведите результат res на экран.


class InputValues:

    def __init__(self, render):
        self.render = render

    def __call__(self, func, *args, **kwargs):
        def wrapper(*args, **kwargs):
            res = [self.render()(i) for i in func().split()]
            return res

        return wrapper


class RenderDigit:

    def __call__(self, value, *args, **kwargs):
        try:
            if '.' in value:
                return None
            return int(value)
        except:
            return None


input_dg = InputValues(RenderDigit)(input)
res = input_dg()
print(res)


# Второй вариант ______________________________________________________
class InputValues:
    def __init__(self, render):
        self.render = render

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            return list(map(self.render, func().split()))
        return wrapper


class RenderDigit:
    def __call__(self, string):
        if string[0] == '-' and string[1:].isdigit() or string.isdigit():
            return int(string)


@InputValues(RenderDigit())
def input_dg():
    return input()


print(input_dg())


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.3 Магические методы __str__, __repr__, __len__, __abs__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Каково назначение магических методов __str__ и __repr__?

# - метод __str__ вызывается (если он определен в классе) для вывода информации об объекте класса в консоль с помощью
# функций print() и str()

# - метод __repr__ возвращает строковую информацию об объекте класса для служебного пользования
# (например, в командную строку), а также может использоваться, если не определен метод __str__


# ----------------------------------------------------------------------------------------------------------------------

# Подвиг 2. Объявите класс с именем Book (книга), объекты которого создаются командой:
#
# book = Book(title, author, pages)
# где title - название книги (строка); author - автор книги (строка); pages - число страниц в книге (целое число).
#
# Также при выводе информации об объекте на экран командой:
#
# print(book)
# должна отображаться строчка в формате:
#
# "Книга: {title}; {author}; {pages}"
#
# Например:
#
# "Книга: Муму; Тургенев; 123"
#
# Прочитайте из входного потока строки с информацией по книге командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# (строки идут в порядке: title, author, pages). Создайте объект класса Book и выведите его строковое представление
# в консоль.
#
# Sample Input:
#
# Python ООП
# Балакирев С.М.
# 1024
# Sample Output:
#
# Книга: Python ООП; Балакирев С.М.; 1024
import sys


class Book:

    def __init__(self, *args):
        self.title = args[0]
        self.author = args[1]
        self.pages = args[2]

    def __str__(self):
        return f'Книга: {self.title}; {self.author}; {self.pages}'


lst_in = list(map(str.strip, sys.stdin.readlines()))

book = Book(*lst_in)
print(book)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Объявите класс с именем Model, объекты которого создаются командой:
#
# model = Model()
# Объявите в этом классе метод query() для формирования записи базы данных. Использоваться этот метод должен следующим
# образом:
#
# model.query(field_1=value_1, field_2=value_2, ..., field_N=value_N)
#
# Например:
#
# model.query(id=1, fio='Sergey', old=33)
# Все эти переданные данные должны сохраняться внутри объекта model класса Model. Затем, при выполнении команды:
#
# print(model)
# В консоль должна выводиться информация об объекте в формате:
#
# "Model: field_1 = value_1, field_2 = value_2, ..., field_N = value_N"
#
# Например:
#
# "Model: id = 1, fio = Sergey, old = 33"
#
# Если метод query() не вызывался, то в консоль выводится строка:
#
# "Model"
#
# P.S. В программе нужно только объявить класс, выводить в консоль ничего не нужно.


class Model:

    def __init__(self):
        self.d = {}

    def query(self, **kwargs):
        self.d.update(kwargs)

    def __str__(self):
        if self.d:
            res = 'Model: ' + ', '.join([f'{x[0]} = {x[1]}' for x in self.d.items()])
            return res
        return 'Model'


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите класс WordString, объекты которого создаются командами:
#
# w1 = WordString()
# w2 = WordString(string)
# где string - передаваемая строка. Например:
#
# words = WordString("Курс по Python ООП")
# Реализовать следующий функционал для объектов этого класса:
#
# len(words) - должно возвращаться число слов в переданной строке (слова разделяются одним или несколькими пробелами);
# words(indx) - должно возвращаться слово по его индексу (indx - порядковый номер слова в строке, начиная с 0).
#
# Также в классе WordString реализовать объект-свойство (property):
#
# string - для передачи и считывания строки.
#
# Пример пользования классом WordString (эти строчки в программе писать не нужно):
#
# words = WordString()
# words.string = "Курс по Python ООП"
# n = len(words)
# first = "" if n == 0 else words(0)
# print(words.string)
# print(f"Число слов: {n}; первое слово: {first}")
# P.S. В программе нужно только объявить класс, выводить в консоль ничего не нужно.

class WordString:

    def __init__(self, string=''):
        self.__string = string

    def __len__(self):
        return len(self.string.split())

    def __call__(self, indx, *args, **kwargs):
        return self.string.split()[indx]

    @property
    def string(self):
        return self.__string

    @string.setter
    def string(self, value):
        self.__string = value


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/6-xKuQp9b7Y
#
# Теория по двусвязным спискам (при необходимости): https://youtu.be/0sTH9EwXT1I
#
# Подвиг 5. Объявите класс LinkedList (связный список) для работы со следующей структурой данных:

# Здесь создается список из связанных между собой объектов класса ObjList. Объекты этого класса создаются командой:
#
# obj = ObjList(data)
# где data - строка с некоторой информацией. Также в каждом объекте obj класса ObjList должны создаваться следующие
# локальные атрибуты:
#
# __data - ссылка на строку с данными;
# __prev - ссылка на предыдущий объект связного списка (если объекта нет, то __prev = None);
# __next - ссылка на следующий объект связного списка (если объекта нет, то __next = None).
#
# В свою очередь, объекты класса LinkedList должны создаваться командой:
#
# linked_lst = LinkedList()
# и содержать локальные атрибуты:
#
# head - ссылка на первый объект связного списка (если список пуст, то head = None);
# tail - ссылка на последний объект связного списка (если список пуст, то tail = None).
#
# А сам класс содержать следующие методы:
#
# add_obj(obj) - добавление нового объекта obj класса ObjList в конец связного списка;
# remove_obj(indx) - удаление объекта класса ObjList из связного списка по его порядковому номеру (индексу); индекс
# отсчитывается с нуля.
#
# Также с объектами класса LinkedList должны поддерживаться следующие операции:
#
# len(linked_lst) - возвращает число объектов в связном списке;
# linked_lst(indx) - возвращает строку __data, хранящуюся в объекте класса ObjList, расположенного под
# индексом indx (в связном списке).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# linked_lst = LinkedList()
# linked_lst.add_obj(ObjList("Sergey"))
# linked_lst.add_obj(ObjList("Balakirev"))
# linked_lst.add_obj(ObjList("Python"))
# linked_lst.remove_obj(2)
# linked_lst.add_obj(ObjList("Python ООП"))
# n = len(linked_lst)  # n = 3
# s = linked_lst(1) # s = Balakirev
# P.S. На экран в программе ничего выводить не нужно.


# class ObjValue:
#
#     def __set_name__(self, owner, name):
#         self.name = '_' + name
#
#     def __get__(self, instance, owner):
#         return getattr(instance, self.name)
#
#     def __set__(self, instance, value):
#         setattr(instance, self.name, value)


class ObjList:

    def __init__(self, data):
        self.__data = data
        self.__prev = None
        self.__next = None

    # Setters
    def set_data(self, data):
        self.__data = data

    def set_prev(self, obj):
        self.__prev = obj

    def set_next(self, obj):
        self.__next = obj

    # Getters
    def get_data(self):
        return self.__data

    def get_prev(self):
        return self.__prev

    def get_next(self):
        return self.__next


class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if self.head is None:
            self.head = obj
        if self.tail is None:
            self.tail = obj
            self.tail.set_prev(self.head)
            self.head.set_next(obj)
        self.tail.set_next(obj)
        obj.set_prev(self.tail)
        self.tail = obj

    def remove_obj(self, indx):
        if self.head is None:
            return
        if self.tail is None:
            self.head = None
        counter = 0
        ex = self.head
        while counter != indx:
            ex = ex.get_next()
            counter += 1
        if ex == self.tail:
            ex.get_prev().set_next(None)
            self.tail = ex.get_prev()
            return
        ex.get_prev().set_next(ex.get_next())
        ex.get_next().set_prev(ex.get_prev())

    def __len__(self):
        if self.head is None:
            return 0
        res = 1
        ex = self.head
        while ex.get_next() is not None:
            ex = ex.get_next()
            res += 1
        return res

    def __call__(self, indx, *args, **kwargs):
        counter = 0
        ex = self.head
        while counter != indx:
            counter += 1
            ex = ex.get_next()
        return ex.get_data()


# Второй вариант
class ObjList:
    def __init__(self, data):
        self.__data = ''
        self.data = data
        self.__next = self.__prev = None

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, value):
        if type(value) == str:
            self.__data = value

    @property
    def prev(self):
        return self.__prev

    @prev.setter
    def prev(self, obj):
        if type(obj) in (ObjList, type(None)):
            self.__prev = obj

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, obj):
        if type(obj) in (ObjList, type(None)):
            self.__next = obj

class LinkedList:
    def __init__(self):
        self.head = self.tail = None

    def add_obj(self, obj):
        obj.prev = self.tail

        if self.tail:
            self.tail.next = obj
        self.tail = obj

        if not self.head:
            self.head = obj

    def __get_obj_by_index(self, indx):
        h = self.head
        n = 0
        while h and n < indx:
            h = h.next
            n += 1
        return h

    def remove_obj(self, indx):
        obj = self.__get_obj_by_index(indx)
        if obj is None:
            return

        p, n = obj.prev, obj.next
        if p:
            p.next = n
        if n:
            n.prev = p

        if self.head == obj:
            self.head = n
        if self.tail == obj:
            self.tail = p


    def __len__(self):
        n = 0
        h = self.head
        while h:
            n += 1
            h = h.next
        return n

    def __call__(self, indx, *args, **kwargs):
        obj = self.__get_obj_by_index(indx)
        return obj.data if obj else None


# Третий вариант (с дескриптором)
class Desc:
    def __set_name__(self, owner, name):
        self.name = f'_{owner.__name__}__{name}'

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        instance.__dict__[self.name] = value


class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def add_obj(self, obj):
        if not self.head:
            self.head = obj
            self.tail = obj
        else:
            self.tail.next = obj
            obj.prev = self.tail
            self.tail = obj

    def remove_obj(self, indx):
        c = 0
        tmp = self.head
        while c != indx:
            c += 1
            tmp = tmp.next

        if tmp.next and tmp.prev:
            tmp.next.prev = tmp.prev
            tmp.prev = tmp.next

        elif tmp == self.head == self.tail:
            self.head = self.tail = None

        elif tmp == self.head:
            tmp.next.prev = None
            self.head = tmp.next

        elif tmp == self.tail:
            tmp.prev.next = None
            self.tail = tmp.prev

    def __len__(self):
        c = 1 if self.head else 0
        tmp = self.head
        while tmp.next:
            c += 1
            tmp = tmp.next
        return c

    def __call__(self, indx):
        c = 0
        tmp = self.head
        while c != indx:
            c += 1
            tmp = tmp.next
        return tmp.data


class ObjList:
    data = Desc()
    prev = Desc()
    next = Desc()

    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/t8KuHjY71-o
#
# Подвиг 6. Объявите класс с именем Complex для представления и работы с комплексными числами. Объекты этого класса
# должны создаваться командой:
#
# cm = Complex(real, img)
# где real - действительная часть комплексного числа (целое или вещественное значение); img - мнимая часть комплексного
# числа (целое или вещественное значение).
#
# Объявите в этом классе следующие объекты-свойства (property):
#
# real - для записи и считывания действительного значения;
# img - для записи и считывания мнимого значения.
#
# При записи новых значений необходимо проверять тип передаваемых данных. Если тип не соответствует целому или
# вещественному числу, то генерировать исключение командой:
#
# raise ValueError("Неверный тип данных.")
# Также с объектами класса Complex должна поддерживаться функция:
#
# res = abs(cm)
# возвращающая модуль комплексного числа (вычисляется по формуле: sqrt(real*real + img*img) - корень квадратный от
# суммы квадратов действительной и мнимой частей комплексного числа).
#
# Создайте объект cmp класса Complex для комплексного числа с real = 7 и img = 8. Затем, через объекты-свойства real и
# img измените эти значения на real = 3 и img = 4. Вычислите модуль полученного комплексного числа (сохраните результат
# в переменной c_abs).
#
# P.S. На экран ничего выводить не нужно.
from math import sqrt

class Complex:
    def __init__(self, real, img):
        self.__real = real
        self.__img = img

    @property
    def real(self):
        return self.__real

    @real.setter
    def real(self, real):
        if type(real) not in (int, float):
            raise ValueError('Неверный тип данных')
        self.__real = real

    @property
    def img(self):
        return self.__img

    @img.setter
    def img(self, img):
        if type(img) not in (int, float):
            raise ValueError('Неверный тип данных')
        self.__img = img

    def __abs__(self):
        return sqrt(self.real ** 2 + self.img ** 2)

cmp = Complex(real=7, img=8)
cmp.real = 3
cmp.img = 4
c_abs = abs(cmp)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/lCYllyv9nVM
#
# Подвиг 7. Объявите класс с именем RadiusVector для описания и работы с n-мерным вектором (у которого n координат).
# Объекты этого класса должны создаваться командами:
#
# # создание 5-мерного радиус-вектора с нулевыми значениями координат (аргумент - целое число больше 1)
# vector = RadiusVector(5)  # координаты: 0, 0, 0, 0, 0
#
# # создание 4-мерного радиус-вектора с координатами: 1, -5, 3.4, 10 (координаты - любые целые или вещественные числа)
# vector = RadiusVector(1, -5, 3.4, 10)
# То есть, при передаче одного значения, оно интерпретируется, как размерность нулевого радиус-вектора. Если же
# передается более одного числового аргумента, то они интерпретируются, как координаты радиус-вектора.
#
# Класс RadiusVector должен содержать методы:
#
# set_coords(coord_1, coord_2, ..., coord_N) - для изменения координат радиус-вектора;
# get_coords() - для получения текущих координат радиус-вектора (в виде кортежа).
#
# Также с объектами класса RadiusVector должны поддерживаться следующие функции:
#
# len(vector) - возвращает число координат радиус-вектора (его размерность);
# abs(vector) - возвращает длину радиус-вектора (вычисляется как:
# sqrt(coord_1*coord_1 + coord_2*coord_2 + ... + coord_N*coord_N) - корень квадратный из суммы квадратов координат).
#
# Пример использования класса RadiusVector (эти строчки в программе писать не нужно):
#
# vector3D = RadiusVector(3)
# vector3D.set_coords(3, -5.6, 8)
# a, b, c = vector3D.get_coords()
# vector3D.set_coords(3, -5.6, 8, 10, 11) # ошибки быть не должно, последние две координаты игнорируются
# vector3D.set_coords(1, 2) # ошибки быть не должно, меняются только первые две координаты
# res_len = len(vector3D) # res_len = 3
# res_abs = abs(vector3D)
# P.S. На экран ничего выводить не нужно, только объявить класс RadiusVector.

from math import sqrt


class RadiusVector:
    def __init__(self, *args):
        if len(args) == 1:
            self.__coords = [0] * args[0]
        else:
            self.__coords = list(args)

    def set_coords(self, *args):
        self.__coords[:len(args)] = args[:]

    def get_coords(self):
        return tuple(self.__coords)

    def __len__(self):
        return len(self.__coords)

    def __abs__(self):
        if self.__len__() == 0:
            return 0
        return sqrt(sum([x ** 2 for x in self.get_coords()]))


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/V7SV1pOWyEY
#
# Подвиг 8. Объявите класс DeltaClock для вычисления разницы времен. Объекты этого класса должны создаваться командой:
#
# dt = DeltaClock(clock1, clock2)
# где clock1, clock2 - объекты другого класса Clock для хранения текущего времени. Эти объекты должны создаваться
# командой:
#
# clock = Clock(hours, minutes, seconds)
# где hours, minutes, seconds - часы, минуты, секунды (целые неотрицательные числа).
#
# В классе Clock также должен быть (по крайней мере) один метод (возможны и другие):
#
# get_time() - возвращает текущее время в секундах (то есть, значение hours * 3600 + minutes * 60 + seconds).
#
# После создания объекта dt класса DeltaClock, с ним должны выполняться команды:
#
# str_dt = str(dt)   # возвращает строку разницы времен clock1 - clock2 в формате: часы: минуты: секунды
# len_dt = len(dt)   # разницу времен clock1 - clock2 в секундах (целое число)
# print(dt)   # отображает строку разницы времен clock1 - clock2 в формате: часы: минуты: секунды
# Если разность получается отрицательной, то разницу времен считать нулевой.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# dt = DeltaClock(Clock(2, 45, 0), Clock(1, 15, 0))
# print(dt) # 01: 30: 00
# len_dt = len(dt) # 5400
# Обратите внимание, добавляется незначащий ноль, если число меньше 10.
#
# P.S. На экран ничего выводить не нужно, только объявить классы.


class Clock:

    def __init__(self, hours, minutes, seconds):
        self.hours = hours
        self.minutes = minutes
        self.seconds = seconds

    def get_time(self):
        return self.hours * 3600 + self.minutes * 60 + self.seconds


class DeltaClock:

    def __init__(self, clock1, clock2):
        self.clock1 = clock1
        self.clock2 = clock2

    def diff_time(self):
        res = self.clock1.get_time() - self.clock2.get_time()
        if res <= 0:
            return 0
        return res

    def __str__(self):
        h = self.diff_time() // 3600
        m = (self.diff_time() - h * 3600) // 60
        s = (self.diff_time() - h * 3600 - m * 60)
        return f'{h if h >= 10 else "0" + str(h)}: {m if m >= 10 else "0" + str(m)}: {s if s >= 10 else "0" + str(s)}'

    def __len__(self):
        return self.diff_time()


# Второй вариант
import time


class Clock:
    def __init__(self, hours, minutes, seconds):
        self.__hours = hours
        self.__minutes = minutes
        self.__seconds = seconds

    def get_time(self):
        return self.__hours * 3600 + self.__minutes * 60 + self.__seconds


class DeltaClock:
    def __init__(self, clock1: Clock, clock2: Clock):
        self.clock1 = clock1
        self.clock2 = clock2

    def __len__(self):
        diff = self.clock1.get_time() - self.clock2.get_time()
        if diff > 0:
            return diff
        return 0

    def __str__(self):
        return time.strftime("%H: %M: %S", time.gmtime(len(self)))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9. Объявите класс Recipe для представления рецептов. Отдельные ингредиенты рецепта должны определяться
# классом Ingredient. Объекты этих классов должны создаваться командами:
#
# ing = Ingredient(name, volume, measure)
# recipe = Recipe()
# recipe = Recipe(ing_1, ing_2,..., ing_N)
# где ing_1, ing_2,..., ing_N - объекты класса Ingredient.
#
# В каждом объекте класса Ingredient должны создаваться локальные атрибуты:
#
# name - название ингредиента (строка);
# volume - объем ингредиента в рецепте (вещественное число);
# measure - единица измерения объема ингредиента (строка), например, литр, чайная ложка, грамм, штук и т.д.;
#
# С объектами класса Ingredient должна работать функция:
#
# str(ing)  # название: объем, ед. изм.
# и возвращать строковое представление объекта в формате:
#
# "название: объем, ед. изм."
#
# Например:
#
# ing = Ingredient("Соль", 1, "столовая ложка")
# s = str(ing) # Соль: 1, столовая ложка
# Класс Recipe должен иметь следующие методы:
#
# add_ingredient(ing) - добавление нового ингредиента ing (объект класса Ingredient) в рецепт (в конец);
# remove_ingredient(ing) - удаление ингредиента по объекту ing (объект класса Ingredient) из рецепта;
# get_ingredients() - получение кортежа из объектов класса Ingredient текущего рецепта.
#
# Также с объектами класса Recipe должна поддерживаться функция:
#
# len(recipe) - возвращает число ингредиентов в рецепте.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# recipe = Recipe()
# recipe.add_ingredient(Ingredient("Соль", 1, "столовая ложка"))
# recipe.add_ingredient(Ingredient("Мука", 1, "кг"))
# recipe.add_ingredient(Ingredient("Мясо баранины", 10, "кг"))
# ings = recipe.get_ingredients()
# n = len(recipe) # n = 3
# P.S. На экран ничего выводить не нужно, только объявить классы.


class Recipe:

    def __init__(self, *args):
        self.ings = []
        if args:
            for i in args:
                self.ings.append(i)

    def add_ingredient(self, ing):
        self.ings.append(ing)

    def remove_ingredient(self, ing):
        self.ings.remove(ing)

    def get_ingredients(self):
        return tuple(self.ings)

    def __len__(self):
        return len(self.ings)


class Ingredient:

    def __init__(self, name, volume, measure):
        self.name = name
        self.volume = volume
        self.measure = measure

    def __str__(self):
        return f"{self.name}: {self.volume}, {self.measure}"


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение). Объявите класс PolyLine (полилиния) для представления линии из последовательности
# прямолинейных сегментов. Объекты этого класса должны создаваться командой:
#
# poly = PolyLine(start_coord, coord_2, coord_3, ..., coord_N)
# Здесь start_coord - координата начала полилинии (кортеж из двух чисел x, y); coord_2, coord_3, ... - последующие
# координаты точек на плоскости (представленные кортежами), соединенных прямыми линиями.
#
# Например:
#
# poly = PolyLine((1, 2), (3, 5), (0, 10), (-1, 8))

# В классе PolyLine должны быть объявлены следующие методы:
#
# add_coord(x, y) - добавление новой координаты (в конец);
# remove_coord(indx) - удаление координаты по индексу (порядковому номеру, начинается с нуля);
# get_coords() - получение списка координат (в виде списка из кортежей).
#
# P.S. На экран ничего выводить не нужно, только объявить класс.


class PolyLine:

    def __init__(self, *args):
        self.coords = list(args)

    def add_coord(self, x, y):
        self.coords.append((x, y))

    def remove_coord(self, indx):
        del self.coords[indx]

    def get_coords(self):
        return self.coords


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.4 Методы __add__, __sub__, __mul__, __truediv__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствие между магическими методами классов и их описаниями.

# - __add__() - для реализации оператора сложения +
# - __sub__() - для реализации оператора вычитания -
# - __mul__() - для реализации оператора умножения *
# - __truediv__() - для реализации оператора деления /
# - __floordiv__() - для реализации оператора целочисленного деления //
# - __mod__() - для реализации оператора вычисления целого остатка от деления %


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. В программе определен следующий класс:
#
# class Way:
#     def __init__(self, length):
#         self.length = length
#
#     def __add__(self, other):
#         return Way(self.length + other.length)
# И создаются два объекта:
#
# w1 = Way(5)
# w2 = Way(10)
# Выберите все верные строчки программы при работе с объектами w1 и w2 (те, что не приводят к ошибкам во время
# выполнения).

# - w = w1 + w2
# - w = w1 + w2 + w1
# - w1 += w2


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен класс Way с магическими методами __add__(), __radd__() и __iadd__() и два его
# объекта:
#
# w1 = Way(5)
# w2 = Way(10)
# Причем магические методы реализованы так, что эти объекты можно складывать и между собой и с числами:
#
# w1 + w2
# w1 + 10

# Выберите верные формулировки, описывающие магические методы __add__(), __radd__() и __iadd__().

# - метод __add__() используется для оператора += (пример: w1 += w2), если отсутствует метод __iadd__()
# - метод __add__() служит для реализации бинарного оператора сложения (пример: w1 + w2)
# - метод __iadd__() используется для оператора += (пример: w1 += w2) и не может быть использован
# для оператора + (пример: w1 + w2)
# - метод __radd__() используется для реализации оператора +, относительно правого
# операнда (объекта класса Way); пример: w = 10 + w1


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/tkjqkiCSnqM
#
# Подвиг 4. Известно, что в Python мы можем соединять два списка между собой с помощью оператора +:
#
# lst = [1, 2, 3] + [4.5, -3.6, 0.78]
# Но нет реализации оператора -, который бы убирал из списка соответствующие значения вычитаемого списка, как это
# показано в примере:
#
# lst = [1, 2, 3, 4, 5, 6] - [5, 6, 7, 8, 1] # [2, 3, 4] (порядок следования оставшихся элементов списка должен
# сохраняться)
# Давайте это поправим и создадим такой функционал. Для этого нужно объявить класс с именем NewList, объекты
# которого создаются командами:
#
# lst = NewList() # пустой список
# lst = NewList([-1, 0, 7.56, True]) # список с начальными значениями
# Реализуйте для этого класса работу с оператором вычитания, чтобы над объектами класса NewList можно было выполнять
# следующие действия:
#
# lst1 = NewList([1, 2, -4, 6, 10, 11, 15, False, True])
# lst2 = NewList([0, 1, 2, 3, True])
# res_1 = lst1 - lst2 # NewList: [-4, 6, 10, 11, 15, False]
# lst1 -= lst2 # NewList: [-4, 6, 10, 11, 15, False]
# res_2 = lst2 - [0, True] # NewList: [1, 2, 3]
# res_3 = [1, 2, 3, 4.5] - res_2 # NewList: [4.5]
# a = NewList([2, 3])
# res_4 = [1, 2, 2, 3] - a # NewList: [1, 2]
# Также в классе NewList необходимо объявить метод:
#
# get_list() - для возвращения результирующего списка объекта класса NewList
#
# Например:
#
# lst = res_2.get_list() # [1, 2, 3]
# P.S. В программе требуется только объявить класс. На экран ничего выводить не нужно.


class NewList:

    def __init__(self, lst=None):
        self._lst = lst[:] if lst and type(lst) == list else []

    def get_list(self):
        return self._lst

    def __sub__(self, other):
        if type(other) not in (list, NewList):
            raise ArithmeticError('Правый операнд должен иметь тип жшые или NewList')
        other_list = other if type(other) == list else other.get_list()
        return NewList(self.__diff_list(self._lst, other_list))

    def __rsub__(self, other):
        if type(other) != list:
            raise ArithmeticError('Правый операнд должен иметь тип List')
        return NewList(self.__diff_list(other, self._lst))

    @staticmethod
    def __diff_list(lst1, lst2):
        if len(lst2) == 0:
            return lst1
        sub = lst2[:]
        return [x for x in lst1 if not NewList.__is_elem(x, sub)]

    @staticmethod
    def __is_elem(x, sub):
        res = any(map(lambda xx: type(x) == type(xx) and x == xx, sub))
        if res:
            sub.remove(x)
        return res


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0Poea079PSs
#
# Подвиг 5. Объявите класс с именем ListMath, объекты которого можно создавать командами:
#
# lst1 = ListMath() # пустой список
# lst2 = ListMath([1, 2, -5, 7.68]) # список с начальными значениями
# В качестве значений элементов списка объекты класса ListMath должны отбирать только целые и вещественные числа,
# остальные игнорировать (если указываются в списке). Например:
#
# lst = ListMath([1, "abc", -5, 7.68, True]) # ListMath: [1, -5, 7.68]
# В каждом объекте класса ListMath должен быть публичный атрибут:
#
# lst_math - ссылка на текущий список объекта (для каждого объекта создается свой список).
#
# Также с объектами класса ListMath должны работать следующие операторы:
#
# lst = lst + 76 # сложение каждого числа списка с определенным числом
# lst = 6.5 + lst # сложение каждого числа списка с определенным числом
# lst += 76.7  # сложение каждого числа списка с определенным числом
# lst = lst - 76 # вычитание из каждого числа списка определенного числа
# lst = 7.0 - lst # вычитание из числа каждого числа списка
# lst -= 76.3
# lst = lst * 5 # умножение каждого числа списка на указанное число (в данном случае на 5)
# lst = 5 * lst # умножение каждого числа списка на указанное число (в данном случае на 5)
# lst *= 5.54
# lst = lst / 13 # деление каждого числа списка на указанное число (в данном случае на 13)
# lst = 3 / lst # деление числа на каждый элемент списка
# lst /= 13.0
# При использовании бинарных операторов +, -, *, / должны формироваться новые объекты класса ListMath с новыми
# списками, прежние списки не меняются.
#
# При использовании операторов +=, -=, *=, /= значения должны меняться внутри списка текущего объекта (новый
# объект не создается).
#
# P.S. В программе достаточно только объявить класс. На экран ничего выводить не нужно.


class ListMath:

    def __init__(self, lst=None):
        self.lst_math = lst if lst and type(lst) == list else []
        self.lst_math = list(filter(lambda x: type(x) in (int, float), self.lst_math))

    @staticmethod
    def __check_type(value):
        if type(value) not in (int, float):
            raise ('Операнд должен быть числом')

    def __add__(self, other):
        self.__check_type(other)
        return ListMath([i + other for i in self.lst_math])

    def __radd__(self, other):
        return self + other

    def __iadd__(self, other):
        self.__check_type(other)
        self.lst_math = [i + other for i in self.lst_math]
        return self

    def __sub__(self, other):
        self.__check_type(other)
        return ListMath([i - other for i in self.lst_math])

    def __rsub__(self, other):
        return ListMath([other - i for i in self.lst_math])

    def __isub__(self, other):
        self.__check_type(other)
        self.lst_math = [i - other for i in self.lst_math]
        return self

    def __mul__(self, other):
        self.__check_type(other)
        return ListMath([i * other for i in self.lst_math])

    def __rmul__(self, other):
        return self * other

    def __imul__(self, other):
        self.__check_type(other)
        self.lst_math = [i * other for i in self.lst_math]
        return self

    def __truediv__(self, other):
        self.__check_type(other)
        return ListMath([i / other for i in self.lst_math])

    def __rtruediv__(self, other):
        return ListMath([other / i for i in self.lst_math])

    def __itruediv__(self, other):
        self.__check_type(other)
        self.lst_math = [i / other for i in self.lst_math]
        return self


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PY-E4OSh1gM
#
# Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
#
# Подвиг 6. Ранее, в одном из подвигов мы с вами создавали односвязный список с объектами класса StackObj (когда один
# объект ссылается на следующий и так далее):


# Давайте снова создадим такую структуру данных. Для этого объявим два класса:
#
# Stack - для управления односвязным списком в целом;
# StackObj - для представления отдельных объектов в односвязным списком.
#
# Объекты класса StackObj должны создаваться командой:
#
# obj = StackObj(data)
# где data - строка с некоторыми данными.
#
# Каждый объект класса StackObj должен иметь локальные приватные атрибуты:
#
# __data - ссылка на строку с переданными данными;
# __next - ссылка на следующий объект односвязного списка (если следующего нет, то __next = None).
#
# Объекты класса Stack создаются командой:
#
# st = Stack()
# и каждый из них должен содержать локальный атрибут:
#
# top - ссылка на первый объект односвязного списка (если объектов нет, то top = None).
#
# Также в классе Stack следует объявить следующие методы:
#
# push_back(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
# pop_back(self) - удаление последнего объекта из односвязного списка.
#
# Дополнительно нужно реализовать следующий функционал (в этих операциях копии односвязного списка создавать не нужно):
#
# # добавление нового объекта класса StackObj в конец односвязного списка st
# st = st + obj
# st += obj
#
# # добавление нескольких объектов в конец односвязного списка
# st = st * ['data_1', 'data_2', ..., 'data_N']
# st *= ['data_1', 'data_2', ..., 'data_N']
# В последних двух строчках должны автоматически создаваться N объектов класса StackObj с данными, взятыми из
# списка (каждый элемент списка для очередного добавляемого объекта).
#
# P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.


class StackObj:

    def __init__(self, data):
        self.__data = data
        self.__next = None

    @property
    def next(self):
        return self.__next

    @next.setter
    def next(self, obj):
        self.__next = obj

    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, data):
        self.__data = data


class Stack:

    def __init__(self):
        self.top = None
        self.__last = None

    def push_back(self, obj):
        if self.__last:
            self.__last.next = obj
        self.__last = obj

        if self.top is None:
            self.top = obj

    def pop_back(self):
        ex = self.top
        if ex is None:
            return

        while ex.next and ex.next != self.__last:
            ex = ex.next

        if self.top == self.__last:
            self.top = self.__last = None
        else:
            ex.next = None
            self.__last = ex

    def __add__(self, other):
        self.push_back(other)
        return self

    def __iadd__(self, other):
        return self.__add__(other)

    def __mul__(self, other):
        for i in other:
            self.push_back(StackObj(i))
        return self

    def __imul__(self, other):
        return self.__mul__(other)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. Вам поручается создать программу по учету книг (библиотеку). Для этого необходимо в программе объявить
# два класса:
#
# Lib - для представления библиотеки в целом;
# Book - для описания отдельной книги.
#
# Объекты класса Book должны создаваться командой:
#
# book = Book(title, author, year)
# где title - заголовок книги (строка); author - автор книги (строка); year - год издания (целое число).
#
# Объекты класса Lib создаются командой:
#
# lib = Lib()
# Каждый объект должен содержать локальный публичный атрибут:
#
# book_list - ссылка на список из книг (объектов класса Book). Изначально список пустой.
#
# Также объекты класса Lib должны работать со следующими операторами:
#
# lib = lib + book # добавление новой книги в библиотеку
# lib += book
#
# lib = lib - book # удаление книги book из библиотеки (удаление происходит по ранее созданному
# объекту book класса Book)
# lib -= book
#
# lib = lib - indx # удаление книги по ее порядковому номеру (индексу: отсчет начинается с нуля)
# lib -= indx
# При реализации бинарных операторов + и - создавать копии библиотек (объекты класса Lib) не нужно.
#
# Также с объектами класса Lib должна работать функция:
#
# n = len(lib) # n - число книг
# которая возвращает число книг в библиотеке.
#
# P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.

class Lib:
    def __init__(self):
        self.book_list = []

    def __len__(self):
        return len(self.book_list)

    def __add__(self, other):
        if not isinstance(other, Book):
            raise TypeError('Операнд справа должен быть экземпляром класса Book')
        self.book_list.append(other)
        return self

    def __sub__(self, other):
        if not isinstance(other, (int, Book)):
            raise TypeError('Операнд справа должен быть int или экземпляром класса Book')
        if isinstance(other, Book):
            self.book_list.remove(other)
        else:
            if other < len(self.book_list):
                del self.book_list[other]
        return self

class Book:
    def __init__(self, title, author, year):
        self.title = title
        self.author = author
        self.year = year


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Вам необходимо создать простую программу по учету семейного бюджета. Для этого в программе объявите два
# класса с именами:
#
# Budget - для управления семейным бюджетом;
# Item - пункт расходов бюджета.
#
# Объекты класса Item должны создаваться командой:
#
# it = Item(name, money)
# где name - название статьи расхода; money - сумма расходов (вещественное или целое число).
#
# Соответственно, в каждом объекте класса Item должны формироваться локальные атрибуты name и money с переданными
# значениями. Также с объектами класса Item должны выполняться следующие операторы:
#
# s = it1 + it2 # сумма для двух статей расходов
# и в общем случае:
#
# s = it1 + it2 + ... + itN # сумма N статей расходов
# При суммировании оператор + должен возвращать число - вычисленную сумму по атрибутам money соответствующих объектов
# класса Item.
#
# Объекты класса Budget создаются командой:
#
# my_budget = Budget()
# А сам класс Budget должен иметь следующие методы:
#
# add_item(self, it) - добавление статьи расхода в бюджет (it - объект класса Item);
# remove_item(self, indx) - удаление статьи расхода из бюджета по его порядковому номеру indx (индексу: отсчитывается
# с нуля);
# get_items(self) - возвращает список всех статей расходов (список из объектов класса Item).
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# my_budget = Budget()
# my_budget.add_item(Item("Курс по Python ООП", 2000))
# my_budget.add_item(Item("Курс по Django", 5000.01))
# my_budget.add_item(Item("Курс по NumPy", 0))
# my_budget.add_item(Item("Курс по C++", 1500.10))
#
# # вычисление общих расходов
# s = 0
# for x in my_budget.get_items():
#     s = s + x
# P.S. В программе требуется только объявить класс. На экран ничего выводить не нужно.

class Item:
    def __init__(self, name, money):
        self.name = name
        self.money = money

    def __add__(self, it):
        if isinstance(it, Item):
            return self.money + it.money
        if isinstance(it, (float, int)):
            return self.money + it

    def __radd__(self, it):
        return self + it

class Budget:
    def __init__(self):
        self.items = list()

    def add_item(self, it):
        if isinstance(it, Item):
            self.items.append(it)

    def remove_item(self, indx):
        if indx < len(self.items):
            del self.items[indx]

    def get_items(self):
        return self.items

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9. Объявите класс Box3D для представления прямоугольного параллелепипеда (бруска), объекты которого создаются
# командой:
#
# box = Box3D(width, height, depth)
# где width, height, depth - ширина, высота и глубина соответственно (числа: целые или вещественные)
#
# В каждом объекте класса Box3D должны создаваться публичные атрибуты:
#
# width, height, depth - ширина, высота и глубина соответственно.
#
# С объектами класса Box3D должны выполняться следующие операторы:
#
# box1 = Box3D(1, 2, 3)
# box2 = Box3D(2, 4, 6)
#
# box = box1 + box2 # Box3D: width=3, height=6, depth=9 (соответствующие размерности складываются)
# box = box1 * 2    # Box3D: width=2, height=4, depth=6 (каждая размерность умножается на 2)
# box = 3 * box2    # Box3D: width=6, height=12, depth=18
# box = box2 - box1 # Box3D: width=1, height=2, depth=3 (соответствующие размерности вычитаются)
# box = box1 // 2   # Box3D: width=0, height=1, depth=1 (соответствующие размерности целочисленно делятся на 2)
# box = box2 % 3    # Box3D: width=2, height=1, depth=0
# При каждой арифметической операции следует создавать новый объект класса Box3D с соответствующими значениями
# локальных атрибутов.
#
# P.S. В программе достаточно только объявить класс Box3D. На экран ничего выводить не нужно.



class Box3D:

    def __init__(self, width, height, depth):
        self.width = width
        self.height = height
        self.depth = depth

    def __add__(self, other):
        if isinstance(other, Box3D):
            width = self.width + other.width
            height = self.height + other.height
            dept = self.depth + other.depth
            return Box3D(width, height, dept)

    def __mul__(self, other):
        if isinstance(other, int):
            return Box3D(self.width * other, self.height * other, self.depth * other)

    def __rmul__(self, other):
        if isinstance(other, int):
            return Box3D(self.width * other, self.height * other, self.depth * other)

    def __sub__(self, other):
        if isinstance(other, Box3D):
            width = self.width - other.width
            height = self.height - other.height
            dept = self.depth - other.depth
            return Box3D(width, height, dept)

    def __floordiv__(self, other):
        if isinstance(other, int):
            return Box3D(self.width // other, self.height // other, self.depth // other)

    def __mod__(self, other):
        if isinstance(other, int):
            return Box3D(self.width % other, self.height % other, self.depth % other)



# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10 (на повторение). В нейронных сетях использую операцию под названием Max Pooling. Суть ее состоит в
# сканировании прямоугольной таблицы чисел (матрицы) окном определенного размера (обычно, 2x2 элемента) и выбора
# наибольшего значения в пределах этого окна:

# PHOTO 1

#  Или, если окна выходят за пределы матрицы, то они пропускаются (игнорируются):

# Мы повторим эту процедуру. Для этого в программе нужно объявить класс с именем MaxPooling, объекты которого создаются
# командой:
#
# mp = MaxPooling(step=(2, 2), size=(2,2))
# где step - шаг смещения окна по горизонтали и вертикали; size - размер окна по горизонтали и вертикали.
#
# Параметры step и size по умолчанию должны принимать кортеж со значениями (2, 2).
#
# Для выполнения операции Max Pooling используется команда:
#
# res = mp(matrix)
# где matrix - прямоугольная таблица чисел; res - ссылка на результат обработки таблицы matrix (должна создаваться
# новая таблица чисел.
#
# Прямоугольную таблицу чисел следует описывать вложенными списками. Если при сканировании таблицы часть окна выходит
# за ее пределы, то эти данные отбрасывать (не учитывать все окно).
#
# Если matrix не является прямоугольной таблицей или содержит хотя бы одно не числовое значение, то должно
# генерироваться исключение командой:
#
# raise ValueError("Неверный формат для первого параметра matrix.")
# Пример использования класса (эти строчки в программе писать не нужно):
#
# mp = MaxPooling(step=(2, 2), size=(2,2))
# res = mp([[1, 2, 3, 4], [5, 6, 7, 8], [9, 8, 7, 6], [5, 4, 3, 2]])    # [[6, 8], [9, 7]]
# Результатом будет таблица чисел:
#
# 6 8
# 9 7
#
# P.S. В программе достаточно объявить только класс. Выводить на экран ничего не нужно.

class MaxPooling:

    def __init__(self, step = (2, 2), size = (2, 2)):
        self.__step = step
        self.__size = size

    def __call__(self, matrix):
        rows = len(matrix)
        cols = len(matrix[0]) if rows > 0 else 0

        if rows == 0:
            return [[]]

        if not all(map(lambda x: len(x) == cols, matrix)) or \
                not all(map(lambda row: all(map(lambda x: type(x) in (int, float), row)), matrix)):
            raise ValueError("Неверный формат для параметра matrix")
        h, w = self.__size[0], self.__size[1]
        sh, sw = self.__step[0], self.__step[1]

        rows_range = (rows - h) // sh + 1
        cols_range = (cols - w) // sw + 1

        res = [[0] * cols_range for _ in range(rows_range)]

        for i in range(rows_range):
            for j in range(cols_range):
                s = (x for r in matrix[i * sh : i * sh + h] for x in r[j * sw : j * sw + w])
                res[i][j] = max(s)

        return res



# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.5 Сравнения __eq__, __ne__, __lt__, __gt__ и другие
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Установите соответствия между магическими методами и операторами.

# __eq__() - оператор равенства ==
# __ne__() - оператор неравенства !=
# __lt__() - оператор меньше <
# __le__() - оператор меньше или равно <=
# __gt__() - оператор больше >
# __ge__() - оператор больше или равно >=


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Пусть в программе объявлен следующий класс:
#
# class Vector:
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def __eq__(self, other):
#         return self.x == other.x and self.y == other.y
# И создаются его экземпляры:
#
# v1 = Vector(1, 2)
# v2 = Vector(2, 1)
# Для каких операций сравнения будет вызван магический метод __eq__() класса Vector?


# - v1 == v2
# - v1 != v2


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/cHV-yuNFavg
#
# Подвиг 3. Объявите класс Track (маршрут), объекты которого создаются командой:
#
# track = Track(start_x, start_y)
# где start_x, start_y - координаты начала маршрута (целые или вещественные числа).
#
# Каждый линейный сегмент маршрута определяется классом TrackLine, объекты которого создаются командой:
#
# line = TrackLine(to_x, to_y, max_speed)
# где to_x, to_y - координаты следующей точки маршрута (целые или вещественные числа); max_speed - максимальная
# скорость на данном участке (целое число).
#
# Для формирования и работы с маршрутом в классе Track должны быть объявлены следующие методы:
#
# add_track(self, tr) - добавление линейного сегмента маршрута (следующей точки);
# get_tracks(self) - получение кортежа из объектов класса TrackLine.
#
# Также для объектов класса Track должны быть реализованные следующие операции сравнения:
#
# track1 == track2  # маршруты равны, если равны их длины
# track1 != track2  # маршруты не равны, если не равны их длины
# track1 > track2  # True, если длина пути для track1 больше, чем для track2
# track1 < track2  # True, если длина пути для track1 меньше, чем для track2
# И функция:
#
# n = len(track) # возвращает целочисленную длину маршрута (привести к типу int) для объекта track
# Создайте два маршрута track1 и track2 с координатами:
#
# 1-й маршрут: (0; 0), (2; 4), (5; -4) и max_speed = 100
# 2-й маршрут: (0; 1), (3; 2), (10; 8) и max_speed = 90
#
# Сравните их между собой на равенство. Результат сравнения сохраните в переменной res_eq.
#
# P.S. На экран в программе ничего выводить не нужно.


class Track:

    def __init__(self, start_x, start_y):
        self._start_x = start_x
        self._start_y = start_y
        self._tracks = []

    def add_track(self, tr):
        self._tracks.append(tr)

    def get_tracks(self):
        return tuple(self._tracks)

    def __get_length(self, i):
        return ((self._tracks[i - 1].x - self._tracks[i].x) ** 2 + (self._tracks[i - 1].y - self._tracks[i].y) ** 2) ** 0.5


    def __len__(self):
        len_1 = ((self._start_x - self._tracks[0].x) ** 2 + (self._start_y - self._tracks[0].y) ** 2) ** 0.5
        return int(len_1 + sum(self.__get_length(i) for i in range(1, len(self._tracks))))

    def __eq__(self, other):
        return len(self) == len(other)

    def __lt__(self, other):
        return len(self) < len(other)






class TrackLine:

    def __init__(self, to_x, to_y, max_speed):
        self._to_x = to_x
        self._to_y = to_y
        self._max_speed = max_speed

    @property
    def x(self):
        return self._to_x

    @property
    def y(self):
        return self._to_y

    @property
    def max_speed(self):
        return self._max_speed


track1 = Track(0, 0)
track2 = Track(0, 1)

track1.add_track(TrackLine(2, 4, 100))
track1.add_track(TrackLine(5, -4, 100))

track2.add_track(TrackLine(3, 2, 90))
track2.add_track(TrackLine(10, 8, 90))

res_eq = track1 == track2

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите класс Dimensions (габариты) с атрибутами:
#
# MIN_DIMENSION = 10
# MAX_DIMENSION = 10000
# Каждый объект класса Dimensions должен создаваться командой:
#
# d3 = Dimensions(a, b, c)   # a, b, c - габаритные размеры
# Значения a, b, c должны сохраняться в локальных приватных атрибутах __a, __b, __c объектах этого класса.
#
# Для изменения и доступа к приватным атрибутам в классе Dimensions должны быть объявлены объекты-свойства (property)
# с именами: a, b, c. Причем, в момент присваивания нового значения должна выполняться проверка попадания числа в
# диапазон [MIN_DIMENSION; MAX_DIMENSION]. Если число не попадает, то оно игнорируется и существующее значение не
# меняется.
#
# С объектами класса Dimensions должны выполняться следующие операторы сравнения:
#
# dim1 >= dim2   # True, если объем dim1 больше или равен объему dim2
# dim1 > dim2    # True, если объем dim1 больше объема dim2
# dim1 <= dim2   # True, если объем dim1 меньше или равен объему dim2
# dim1 < dim2    # True, если объем dim1 меньше объема dim2
# Объявите в программе еще один класс с именем ShopItem (товар), объекты которого создаются командой:
#
# item = ShopItem(name, price, dim)
# где name - название товара (строка); price - цена товара (целое или вещественное число); dim - габариты
# товара (объект класса Dimensions).
#
# В каждом объекте класса ShopItem должны создаваться локальные атрибуты:
#
# name - название товара;
# price - цена товара;
# dim - габариты товара (объект класса Dimensions).
#
# Создайте список с именем lst_shop из четырех товаров со следующими данными:
#
# - кеды; 1024; (40, 30, 120)
# - зонт; 500.24; (10, 20, 50)
# - холодильник; 40000; (2000, 600, 500)
# - табуретка; 2000.99; (500, 200, 200)
#
# Сформируйте новый список lst_shop_sorted с упорядоченными по возрастанию объема (габаритов) товаров списка
# lst_shop, используя стандартную функцию sorted() языка Python и ее параметр key для настройки сортировки.
# Прежний список lst_shop должен оставаться без изменений.
#
# P.S. На экран в программе ничего выводить не нужно.


class Dimensions:
    MIN_DIMENSION = 10
    MAX_DIMENSION = 10000

    def __init__(self, params):
        self.__a, self.__b, self.__c = params

    # Getters

    @property
    def a(self):
        return self.__a

    @property
    def b(self):
        return self.__b

    @property
    def c(self):
        return self.__c

    # Setters
    @a.setter
    def a(self, a):
        if self.check_value(a):
            self.__a = a

    @b.setter
    def b(self, b):
        if self.check_value(b):
            self.__b = b

    @c.setter
    def c(self, c):
        if self.check_value(c):
            self.__c = c

    def check_value(self, val):
        return True if self.MIN_DIMENSION <= val <= self.MAX_DIMENSION else False

    def give_volume(self):
        return self.a * self.b * self.c

    def __ge__(self, other):
        return self.give_volume() >= other.give_volume()

    def __le__(self, other):
        return self.give_volume() <= other.give_volume()

    def __gt__(self, other):
        return self.give_volume() > other.give_volume()

    def __lt__(self, other):
        return self.give_volume() < other.give_volume()


class ShopItem:

    def __init__(self, name, price, dim):
        self.name = name
        self.price = price
        self.dim = Dimensions(dim)

lst_shop = [ShopItem('кеды', 1024, (40, 30, 120)), ShopItem('зонт', 500.24, (10, 20, 50)),
            ShopItem('холодильник', 40000, (2000, 600, 500)), ShopItem('табуретка', 2000.99, (500, 200, 200))]

lst_shop_sorted = sorted(lst_shop, key=lambda x: x.dim.give_volume())
print({x.name: x.dim.give_volume() for x in lst_shop_sorted})


# Второй вариант
class DimensionsDescriptors:

    def __set_name__(self, owner, name):
        self.name = '_' + owner.__name__ + '__' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name)

    def __set__(self, instance, value):
        if self.__validate(instance, value):
            setattr(instance, self.name, value)

    @staticmethod
    def __validate(instance, value):
        return instance.MIN_DIMENSION <= value <= instance.MAX_DIMENSION


class Dimensions:
    MIN_DIMENSION = 10
    MAX_DIMENSION = 10000
    a = DimensionsDescriptors()
    b = DimensionsDescriptors()
    c = DimensionsDescriptors()

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @property
    def volume(self):
        return self.a * self.b * self.c

    def __gt__(self, other):
        return self.volume > other.volume

    def __ge__(self, other):
        return self.volume >= other.volume

    def __repr__(self):
        return f"{self.volume}"


class ShopItem:

    def __init__(self, name: str, price: (int, float), dim: Dimensions):
        self.name = name
        self.price = price
        self.dim = dim
        self.dim_volume = self.dim.volume

    def __repr__(self):
        fields = [f'{f}={v}' for f, v in self.__dict__.items()]
        return f"{type(self).__name__}" + str(tuple(fields)).replace("\'", '')


lst_shop = [ShopItem('кеды', 1024, Dimensions(40, 30, 120)),
            ShopItem('зонт', 500.24, Dimensions(10, 20, 50)),
            ShopItem('холодильник', 40000, Dimensions(2000, 600, 500)),
            ShopItem('табуретка', 2000.99, Dimensions(500, 200, 200))]

lst_shop_sorted = sorted(lst_shop, key=lambda x: x.dim_volume)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/k7PSxUf0w6g
#
# Подвиг 5. Имеется стихотворение, представленное следующим списком строк:
#
# stich = ["Я к вам пишу – чего же боле?",
#         "Что я могу еще сказать?",
#         "Теперь, я знаю, в вашей воле",
#         "Меня презреньем наказать.",
#         "Но вы, к моей несчастной доле",
#         "Хоть каплю жалости храня,",
#         "Вы не оставите меня."]
# Необходимо в каждой строчке этого стиха убрать символы "–?!,.;" в начале и в конце каждого слова и разбить строку
# по словам (слова разделяются одним или несколькими пробелами). На основе полученного списка слов, создать объект
# класса StringText командой:
#
# st = StringText(lst_words)
# где lst_words - список из слов одной строчки стихотворения.
#
# С объектами класса StringText должны быть реализованы операторы сравнения:
#
# st1 > st2   # True, если число слов в st1 больше, чем в st2
# st1 >= st2  # True, если число слов в st1 больше или равно st2
# st1 < st2   # True, если число слов в st1 меньше, чем в st2
# st1 <= st2  # True, если число слов в st1 меньше или равно st2
# Все объекты класса StringText (для каждой строчки стихотворения) сохранить в списке lst_text. Затем, сформировать
# новый список lst_text_sorted из отсортированных объектов класса StringText по убыванию числа слов. Для сортировки
# использовать стандартную функцию sorted() языка Python. После этого преобразовать данный список (lst_text_sorted)
# в список из строк (объекты заменяются на соответствующие строки, между словами ставится пробел).
#
# P.S. На экран в программе ничего выводить не нужно.

# эти строчки не менять
stich = ["Я к вам пишу – чего же боле?",
        "Что я могу еще сказать?",
        "Теперь, я знаю, в вашей воле",
        "Меня презреньем наказать.",
        "Но вы, к моей несчастной доле",
        "Хоть каплю жалости храня,",
        "Вы не оставите меня."]


# здесь продолжайте программу

class RemoveChars:

    def __init__(self, chars):
        self.chars = chars

    def __call__(self, arg, *args, **kwargs):
        if isinstance(arg, str):
            for char in self.chars:
                arg = arg.replace(char, '')

            return arg.split()


class StringText:

    def __init__(self, lst):
        self.lst = lst

    def __eq__(self, other):
        if isinstance(other, StringText):
            return len(self) == len(other)
        raise AttributeError

    def __gt__(self, other):
        if isinstance(other, StringText):
            return len(self) > len(other)
        raise AttributeError

    def __ge__(self, other):
        if isinstance(other, StringText):
            return len(self) >= len(other)
        raise AttributeError

    def __len__(self):
        return len(self.lst)


parce = RemoveChars("-?!,.;")
lst_text = [StringText(parce(sentence)) for sentence in stich]
lst_text_sorted = sorted(lst_text, reverse=True)
lst_text_sorted = [' '.join(i.lst) for i in lst_text_sorted]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PJsJOIxZOdM
#
# Подвиг 6. Ваша задача написать программу поиска слова в строке. Задача усложняется тем, что слово должно определяться
# в разных его формах. Например, слово:
#
# программирование
#
# может иметь следующие формы:
#
# программирование, программированию, программированием, программировании, программирования, программированиям,
# программированиями, программированиях
#
# Для решения этой задачи необходимо объявить класс Morph (морфология), объекты которого создаются командой:
#
# mw = Morph(word1, word2, ..., wordN)
# где word1, word2, ..., wordN - возможные формы слова.
#
# В классе Morph реализовать методы:
#
# add_word(self, word) - добавление нового слова (если его нет в списке слов объекта класса Morph);
# get_words(self) - получение кортежа форм слов.
#
# Также с объектами класса Morph должны выполняться следующие операторы сравнения:
#
# mw1 == "word"  # True, если объект mv1 содержит слово "word" (без учета регистра)
# mw1 != "word"  # True, если объект mv1 не содержит слово "word" (без учета регистра)
# И аналогичная пара сравнений:
#
# "word" == mw1
# "word" != mw1
# После создания класса Morph, формируется список dict_words из объектов этого класса, для следующих слов с их
# словоформами:
#
# - связь, связи, связью, связей, связям, связями, связях
# - формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
# - вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
# - эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
# - день, дня, дню, днем, дне, дни, дням, днями, днях
#
# Затем, прочитайте строку из входного потока командой:
#
# text = input()
# Найдите все вхождения слов из списка dict_words (используя операторы сравнения) в строке text (без учета
# регистра, знаков пунктуаций и их словоформы). Выведите на экран полученное число.
#
# Sample Input:
#
# Мы будем устанавливать связь завтра днем.
# Sample Output:
#
# 2


class Morph:

    def __init__(self, *args):
        self.words = []
        if args:
            self.words = [word.lower() for word in args]

    def add_word(self, word):
        if word not in self.words:
            self.words.append(word.lower())
        return

    def get_words(self):
        return tuple(self.words)

    def __eq__(self, other):
        if isinstance(other, str):
            return other.lower() in self.get_words()

    def __ne__(self, other):
        if isinstance(other, str):
            return other.lower() not in self.get_words()


s = """- связь, связи, связью, связи, связей, связям, связями, связях
- формула, формулы, формуле, формулу, формулой, формул, формулам, формулами, формулах
- вектор, вектора, вектору, вектором, векторе, векторы, векторов, векторам, векторами, векторах
- эффект, эффекта, эффекту, эффектом, эффекте, эффекты, эффектов, эффектам, эффектами, эффектах
- день, дня, дню, днем, дне, дни, дням, днями, днях
"""

dict_words = [Morph(*line.lstrip('- ').split(', ')) for line in s.splitlines()]

text = input()

res = 0
for i in text.split():
    if i.lower().replace('.', '') in dict_words:
        res += 1

print(res)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7 (на повторение). Перед вами стоит задача выделения файлов с определенными расширениями из списка файлов,
# например:
#
# filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg", "forest.jpeg", "eq_1.png", "eq_2.xls"]
# Для этого необходимо объявить класс FileAcceptor, объекты которого создаются командой:
#
# acceptor = FileAcceptor(ext1, ..., extN)
# где ext1, ..., extN - строки с допустимыми расширениями файлов, например: 'jpg', 'bmp', 'jpeg'.
#
# После этого предполагается использовать объект acceptor в стандартной функции filter языка Python следующим образом:
#
# filenames = list(filter(acceptor, filenames))
# То есть, объект acceptor должен вызываться как функция:
#
# acceptor(filename)
# и возвращать True, если файл с именем filename содержит расширения, указанные при создании acceptor, и False - в
# противном случае. Кроме того, с объектами класса FileAcceptor должен выполняться оператор:
#
# acceptor12 = acceptor1 + acceptor2
# Здесь формируется новый объект acceptor12 с уникальными расширениями первого и второго объектов. Например:
#
# acceptor1 = FileAcceptor("jpg", "jpeg", "png")
# acceptor2 = FileAcceptor("png", "bmp")
# acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
# Пример использования класса (эти строчки в программе писать не нужно):
#
# acceptor_images = FileAcceptor("jpg", "jpeg", "png")
# acceptor_docs = FileAcceptor("txt", "doc", "xls")
# filenames = list(filter(acceptor_images + acceptor_docs, filenames))
# P.S. На экран в программе ничего выводить не нужно.


class FileAcceptor:

    def __init__(self, *args):
        self.exts = []
        if args:
            self.exts = list(args)

    def __call__(self, filename, *args, **kwargs):
        return filename[filename.rfind('.') + 1:] in self.exts

    def __add__(self, other):
        if isinstance(other, FileAcceptor):
            return FileAcceptor(*set(self.exts + other.exts))


# acceptor1 = FileAcceptor("jpg", "jpeg", "png")
# acceptor2 = FileAcceptor("png", "bmp")
# acceptor12 = acceptor1 + acceptor2    # ("jpg", "jpeg", "png", "bmp")
#
# filenames = ["boat.jpg", "ans.web.png", "text.txt", "www.python.doc", "my.ava.jpg",
# "forest.jpeg", "eq_1.png", "eq_2.xls"]
#
# acceptor_images = FileAcceptor("jpg", "jpeg", "png")
# acceptor_docs = FileAcceptor("txt", "doc", "xls")
# res = acceptor_images + acceptor_docs
# print(res.exts)
# filenames = list(filter(acceptor_images + acceptor_docs, filenames))
#
# print(filenames)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/qKTQLo-plpc
#
# Подвиг 8. В программе необходимо объявить классы для работы с кошельками в разных валютах:
#
# MoneyR - для рублевых кошельков
# MoneyD - для долларовых кошельков
# MoneyE - для евро-кошельков

# PHOTO

# Объекты этих классов могут создаваться командами:
#
# rub = MoneyR()   # с нулевым балансом
# dl = MoneyD(1501.25) # с балансом в 1501.25 долларов
# euro = MoneyE(100)  # с балансом в 100 евро
# В каждом объекте этих классов должны формироваться локальные атрибуты:
#
# __cb - ссылка на класс CentralBank (центральный банк, изначально None);
# __volume - объем денежных средств в кошельке (если не указано, то 0).
#
# Также в классах MoneyR, MoneyD и MoneyE должны быть объекты-свойства (property) для работы с локальными атрибутами:
#
# cb - для изменения и считывания данных из переменной __cb;
# volume - для изменения и считывания данных из переменной __volume.
#
# Объекты классов должны поддерживать следующие операторы сравнения:
#
# rub < dl
# dl >= euro
# rub == euro  # значения сравниваются по текущему курсу центрального банка с погрешностью 0.1 (плюс-минус)
# euro > rub
# При реализации операторов сравнения считываются соответствующие значения __volume из сравниваемых объектов и
# приводятся к рублевому эквиваленту в соответствии с курсом валют центрального банка.
#
# Чтобы каждый объект классов MoneyR, MoneyD и MoneyE "знал" текущие котировки, необходимо в программе объявить
# еще один класс CentralBank. Объекты класса CentralBank создаваться не должны (запретить), при выполнении команды:
#
# cb = CentralBank()
#
# должно просто возвращаться значение None. А в самом классе должен присутствовать атрибут:
#
# rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
# Здесь числа (в значениях словаря) - курс валюты по отношению к доллару.
#
# Также в CentralBank должен быть метод уровня класса:
#
# register(cls, money) - для регистрации объектов классов MoneyR, MoneyD и MoneyE.
#
# При регистрации значение __cb объекта money должно ссылаться на класс CentralBank. Через эту переменную объект
# имеет возможность обращаться к атрибуту rates класса CentralBank и брать нужные котировки.
#
# Если кошелек не зарегистрирован, то при операциях сравнения должно генерироваться исключение:
#
# raise ValueError("Неизвестен курс валют.")
# Пример использования классов (эти строчки в программе писать не нужно):
#
# CentralBank.rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}
#
# r = MoneyR(45000)
# d = MoneyD(500)
#
# CentralBank.register(r)
# CentralBank.register(d)
#
# if r > d:
#     print("неплохо")
# else:
#     print("нужно поднажать")
# P.S. В программе на экран ничего выводить не нужно, только объявить классы.


class MoneyR:

    def __init__(self, volume=0, cb=None):
        self.name = 'rub'
        self.__volume = volume
        self.__cb = cb

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, cb):
        self.__cb = cb

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, volume):
        self.__volume = volume

    def __lt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] < other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __gt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] > other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __ge__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] >= other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __eq__(self, other):
        if self.cb is not None or other.cb is not None:
            money1 = self.volume / self.cb.rates[self.name]
            money2 = other.volume / other.cb.rates[self.name]
            res = sorted([money1, money2])
            return res[1] - res[0] <= 0.1
        raise ValueError("Неизвестен курс валют.")


class MoneyD:

    def __init__(self, volume=0, cb=None):
        self.name = 'dollar'
        self.__volume = volume
        self.__cb = cb

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, cb):
        self.__cb = cb

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, volume):
        self.__volume = volume

    def __lt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] < other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __gt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] > other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __ge__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] >= other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __eq__(self, other):
        if self.cb is not None or other.cb is not None:
            money1 = self.volume / self.cb.rates[self.name]
            money2 = other.volume / other.cb.rates[self.name]
            res = sorted([money1, money2])
            return res[1] - res[0] <= 0.1
        raise ValueError("Неизвестен курс валют.")


class MoneyE:

    def __init__(self, volume=0, cb=None):
        self.name = 'euro'
        self.__volume = volume
        self.__cb = cb

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, cb):
        self.__cb = cb

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, volume):
        self.__volume = volume

    def __lt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] < other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __gt__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] > other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __ge__(self, other):
        if self.cb is not None or other.cb is not None:
            return self.volume / self.cb.rates[self.name] >= other.volume / other.cb.rates[other.name]
        raise ValueError("Неизвестен курс валют.")

    def __eq__(self, other):
        if self.cb is not None or other.cb is not None:
            money1 = self.volume / self.cb.rates[self.name]
            money2 = other.volume / other.cb.rates[self.name]
            res = sorted([money1, money2])
            return res[1] - res[0] <= 0.1
        raise ValueError("Неизвестен курс валют.")



class CentralBank:

    def __new__(cls, *args, **kwargs):
        return None

    rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

    @classmethod
    def register(cls, money):
        money.cb = cls


# Второй вариант с наследованием!!!!!

class CentralBank:
    rates = {'rub': 72.5, 'dollar': 1.0, 'euro': 1.15}

    def __new__(cls):
        return None

    @classmethod
    def register(cls, money):
        if isinstance(money, Money):
            money.cb = cls


class Money:
    def __init__(self, volume=0):
        self.__cb = None
        self.__volume = volume

    def __eq__(self, other):
        if isinstance(other, Money):
            return self.valuate() == other.valuate()

    def __lt__(self, other):
        if isinstance(other, Money):
            return self.valuate() < other.valuate()

    def __le__(self, other):
        if isinstance(other, Money):
            return self.valuate() <= other.valuate()

    @property
    def cb(self):
        return self.__cb

    @cb.setter
    def cb(self, value):
        if value is CentralBank:
            self.__cb = value

    @property
    def volume(self):
        return self.__volume

    @volume.setter
    def volume(self, value):
        if type(value) in (int, float):
            self.__volume = value

    def valuate(self):
        if self.cb:
            return round(self.volume / self.cb.rates[self.currency_name], 1)
        raise ValueError("Неизвестен курс валют.")


class MoneyR(Money):
    currency_name = 'rub'


class MoneyD(Money):
    currency_name = 'dollar'


class MoneyE(Money):
    currency_name = 'euro'


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (релакс). Необходимо объявить класс Body (тело), объекты которого создаются командой:
#
# body = Body(name, ro, volume)
# где name - название тела (строка); ro - плотность тела (число: вещественное или целочисленное); volume - объем тела
# (число: вещественное или целочисленное).
#
# Для объектов класса Body должны быть реализованы операторы сравнения:
#
# body1 > body2  # True, если масса тела body1 больше массы тела body2
# body1 == body2 # True, если масса тела body1 равна массе тела body2
# body1 < 10     # True, если масса тела body1 меньше 10
# body2 == 5     # True, если масса тела body2 равна 5
# Масса тела вычисляется по формуле:
#
# m = ro * volume
#
# P.S. В программе только объявить класс, выводить на экран ничего не нужно.

class Body:

    def __init__(self, name, ro, volume):
        self.name = name
        self.ro = ro
        self.volume = volume

    def give_mass(self):
        return self.ro * self.volume

    def __gt__(self, other):
        if isinstance(other, Body):
            return self.give_mass() > other.give_mass()
        if type(other) in (float, int):
            return self.give_mass() > other

    def __eq__(self, other):
        if isinstance(other, Body):
            return self.give_mass() == other.give_mass()
        if type(other) in (float, int):
            return self.give_mass() == other

    def __lt__(self, other):
        if isinstance(other, Body):
            return self.give_mass() < other.give_mass()
        if type(other) in (float, int):
            return self.give_mass() < other


# Второй вариант с замыканием

def mass_arg(func):
    def wrapper(instance, other, *args):
        if isinstance(other, Body):
            return func(instance, other.mass)
        elif isinstance(other, (int, float)):
            return func(instance, other)
        else:
            raise TypeError(f"Not supported type {type(other)} in {func}")

    return wrapper


class Body:
    def __init__(self, name, ro, volume):
        self.name = name
        self.ro = ro
        self.volume = volume

    @property
    def mass(self):
        return (self.ro * self.volume)

    @mass_arg
    def __lt__(self, other):
        return (self.mass < other)

    @mass_arg
    def __le__(self, other):
        return self.mass <= other

    @mass_arg
    def __eq__(self, other):
        return self.mass == other

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 10. Объявите в программе класс с именем Box (ящик), объекты которого должны создаваться командой:
#
# box = Box()
# А сам класс иметь следующие методы:
#
# add_thing(self, obj) - добавление предмета obj (объект другого класса Thing) в ящик;
# get_things(self) - получение списка объектов ящика.
#
# Для описания предметов необходимо объявить еще один класс Thing. Объекты этого класса должны создаваться командой:
#
# obj = Thing(name, mass)
# где name - название предмета (строка); mass - масса предмета (число: целое или вещественное).
# Объекты класса Thing должны поддерживать операторы сравнения:
#
# obj1 == obj2
# obj1 != obj2
# Предметы считаются равными, если у них одинаковые названия name (без учета регистра) и массы mass.
#
# Также объекты класса Box должны поддерживать аналогичные операторы сравнения:
#
# box1 == box2
# box1 != box2
# Ящики считаются равными, если одинаковы их содержимое (для каждого объекта класса Thing одного ящика и можно найти
# ровно один равный объект из второго ящика).
#
# Пример использования классов:
#
# b1 = Box()
# b2 = Box()
#
# b1.add_thing(Thing('мел', 100))
# b1.add_thing(Thing('тряпка', 200))
# b1.add_thing(Thing('доска', 2000))
#
# b2.add_thing(Thing('тряпка', 200))
# b2.add_thing(Thing('мел', 100))
# b2.add_thing(Thing('доска', 2000))
#
# res = b1 == b2 # True
# P.S. В программе только объявить классы, выводить на экран ничего не нужно.

class Box:

    def __init__(self):
        self.box = []

    def add_thing(self, obj):
        self.box.append(obj)

    def get_things(self):
        return self.box

    def __eq__(self, other):
        if isinstance(other, Box):
            return all([self.box.count(i) == other.box.count(i) for i in self.box])

    def __ne__(self, other):
        return not self.__eq__(other)



class Thing:

    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __eq__(self, other):
        if isinstance(other, Thing):
            if self.name.lower() == other.name.lower() and self.mass == other.mass:
                return True
            else:
                return False
        return

    def __ne__(self, other):
        if isinstance(other, Thing):
            if self.name.lower() != other.name.lower() or self.mass != other.mass:
                return True
            else:
                return False
        return


# b1 = Box()
# b2 = Box()
#
# b1.add_thing(Thing('мел', 100))
# b1.add_thing(Thing('тряпка', 200))
# b1.add_thing(Thing('доска', 2000))
#
# b2.add_thing(Thing('тряпка', 200))
# b2.add_thing(Thing('мел', 100))
# b2.add_thing(Thing('доска', 2000))
#
# res = b1 == b2 # True
# print(res)


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.6 Методы __eq__ и __hash__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Выберите все верные утверждения, связанные с работой функции hash() для двух хешируемых
# объектов a и b языка Python.

# - если объекты a == b, то hash(a) == hash(b)
# - если hash(a) != hash(b), то a != b


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Отметьте команды, которые будут выполняться без ошибок.

# - hash((5, 4, 3.5))
# - hash("Balakirev")
# - hash(1024.56)
# - hash(True)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен следующий класс:
#
# class PathLine:
#     def __init__(self, dist, angle):
#         self.dist = dist
#         self.angle = angle
#
#     def __eq__(self, other):
#         return abs(self.dist) == abs(other.dist)
# И создаются два его объекта:
#
# p1 = PathLine(10, 1.57)
# p2 = PathLine(-10, 0.49)
# Затем, вычисляются хэши этих объектов:
#
# h1, h2 = hash(p1), hash(p2)
# Что произойдет в последней строчке программы?


# - будет ошибка, что объекты p1 и p2 не хешируемые


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите в программе класс с именем Rect (прямоугольник), объекты которого создаются командой:
#
# rect = Rect(x, y, width, height)
# где x, y - координата верхнего левого угла (числа: целые или вещественные); width, height - ширина и высота
# прямоугольника (числа: целые или вещественные).
#
# В этом классе определите магический метод, чтобы хэши объектов класса Rect с равными width, height были равны.
# Например:
#
# r1 = Rect(10, 5, 100, 50)
# r2 = Rect(-10, 4, 100, 50)
#
# h1, h2 = hash(r1), hash(r2)   # h1 == h2
# P.S. На экран ничего выводить не нужно, только объявить класс.


class Rect:

    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height

    def __hash__(self):
        return hash((self.width, self.height))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Пусть в программе определен следующий класс:
#
# class Index:
#     START_INDEX = 0
#
#     def __init__(self):
#         self.id = Index.START_INDEX
#         Index.START_INDEX += 1
#
#     def __hash__(self):
#         return hash(str(self.id))
# И делается попытка создать словарь с ключами из объектов этого класса:
#
# id1 = Index()
# id2 = Index()
# d = {id1: id1, id2: id2}
# Выберите верное утверждение, связанное с этой программой.


# - словарь будет успешно создан и к его значениям можно обращаться, например, командой: d[id1].id


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6. Объявите класс с именем ShopItem (товар), объекты которого создаются командой:
#
# item = ShopItem(name, weight, price)
# где name - название товара (строка); weight - вес товара (число: целое или вещественное); price - цена товара
# (число: целое или вещественное).
#
# Определите в этом классе магические методы:
#
# __hash__() - чтобы товары с одинаковым названием (без учета регистра), весом и ценой имели бы равные хэши;
# __eq__() - чтобы объекты с одинаковыми хэшами были равны.
#
# Затем, из входного потока прочитайте строки командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Строки имеют следующий формат:
#
# название товара 1: вес_1 цена_1
# ...
# название товара N: вес_N цена_N
#
# Например:
#
# Системный блок: 1500 75890.56
# Монитор Samsung: 2000 34000
# Клавиатура: 200.44 545
# Монитор Samsung: 2000 34000
#
# Как видите, товары в этом списке могут совпадать.
#
# Необходимо для всех этих строчек сформировать соответствующие объекты класса ShopItem и добавить в словарь с именем
# shop_items. Ключами словаря должны выступать сами объекты, а значениями - список в формате:
#
# [item, total]
#
# где item - объект класса ShopItem; total - общее количество одинаковых объектов (с одинаковыми хэшами).
# Подумайте, как эффективно программно наполнять такой словарь, проходя по списку lst_in один раз.
#
# P.S. На экран ничего выводить не нужно, только объявить класс и сформировать словарь.
#
# Sample Input:
#
# Системный блок: 1500 75890.56
# Монитор Samsung: 2000 34000
# Клавиатура: 200.44 545
# Монитор Samsung: 2000 34000
# Sample Output:

import sys

class ShopItem:
    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price

    def __hash__(self):
        return hash((self.name.lower(), self.weight, self.price))

    def __eq__(self, other):
        return hash(self) == hash(other)

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in в программе не менять!
shop_items = dict()

for item in lst_in:
    name, etc = item.split(': ')
    weight, price = map(float, etc.split())
    item = ShopItem(name, weight, price)
    total = shop_items.get(item, [None, 0])[-1] + 1
    shop_items[item] = [item, total]


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rqCqhjtl6Lw
#
# Подвиг 7. Объявите класс с именем DataBase (база данных - БД), объекты которого создаются командой:
#
# db = DataBase(path)
# где path - путь к файлу с данными БД (строка).
#
# Также в классе DataBase нужно объявить следующие методы:
#
# write(self, record) - для добавления новой записи в БД, представленной объектом record;
# read(self, pk) - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk (уникальное
# целое положительное число); запись ищется в значениях словаря (см. ниже)
#
# Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:
#
# record = Record(fio, descr, old)
# где fio - ФИО некоторого человека (строка); descr - характеристика человека (строка); old - возраст
# человека (целое число).
#
# В каждом объекте класса Record должны формироваться следующие локальные атрибуты:
#
# pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого
# нового объекта;
# fio - ФИО человека (строка);
# descr - характеристика человека (строка);
# old - возраст человека (целое число).
#
# Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра). Если они
# одинаковы для разных записей, то и хэши должны получаться равными. Также для объектов класса Record  с одинаковыми
# хэшами оператор == должен выдавать значение True, а с разными хэшами - False.
#
# Хранить записи в БД следует в виде словаря dict_db (атрибут объекта db класса DataBase), ключами которого являются
# объекты класса Record, а значениями список из объектов с равными хэшами:
#
# dict_db[rec1] = [rec1, rec2, ..., recN]
#
# где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.
#
# Для наполнения БД прочитайте строки из входного потока с помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# где каждая строка представлена в формате:
#
# "ФИО; характеристика; возраст"
#
# Например:
#
# Балакирев С.М.; программист; 33
# Кузнецов А.В.; разведчик-нелегал; 35
# Суворов А.В.; полководец; 42
# Иванов И.И.; фигурант всех подобных списков; 26
# Балакирев С.М.; преподаватель; 37
#
# Каждая строка должна быть представлена объектом класса Record и записана в БД db (в словарь db.dict_db).
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# Балакирев С.М.; программист; 33
# Кузнецов Н.И.; разведчик-нелегал; 35
# Суворов А.В.; полководец; 42
# Иванов И.И.; фигурант всех подобных списков; 26
# Балакирев С.М.; преподаватель; 33
# Sample Output:


import sys

class DataBase:

    def __init__(self, path):
        self.path = path
        self.dict_db = {}

    def write(self, record):
        self.dict_db.setdefault(record, [])
        self.dict_db[record].append(record)

    def read(self, pk):
        r = (x for row in self.dict_db.values() for x in row)
        obj = tuple(filter(lambda x: x.pk == pk, r))
        return obj[0] if len(obj) > 0 else None


class Record:
    pk = 0

    def __new__(cls, *args, **kwargs):
        cls.pk += 1
        return super().__new__(cls)

    def __init__(self,fio, descr, old):
        self.fio = fio
        self.descr = descr
        self.old = int(old)
        self.pk = Record.pk

    def __hash__(self):
        return hash((self.fio.lower(), self.old))

    def __eq__(self, other):
        return hash(self) == hash(other)


# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines())) # список lst_in не менять!

# здесь продолжайте программу (используйте список строк lst_in)
db = DataBase('abc')

for i in lst_in:
    sentence = i.split('; ')
    name, descr, old = sentence
    p = Record(name, descr, old)
    db.write(p)


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 8. Из входного потока необходимо прочитать список строк командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# Каждая строка содержит информацию об учебном пособии в формате:
#
# "Название; автор; год издания"
#
# Например:
#
# Python; Балакирев С.М.; 2020
# Python ООП; Балакирев С.М.; 2021
# Python ООП; Балакирев С.М.; 2022
# Python; Балакирев С.М.; 2021
#
# Необходимо каждую из этих строк представить объектом класса BookStudy, которые создаются командой:
#
# bs = BookStudy(name, author, year)
# где name - название пособия (строка); author - автор пособия (строка); year - год издания (целое число). Такие же
# публичные локальные атрибуты должны быть в объектах класса BookStudy.
#
# Для каждого объекта реализовать вычисление хэша по двум атрибутам: name и author (без учета регистра).
#
# Сформировать список lst_bs из объектов класса BookStudy на основе прочитанных строк (списка lst_in). После этого
# определить число книг с уникальными хэшами. Это число сохранить через переменную unique_books (целое число).
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# Python; Балакирев С.М.; 2020
# Python ООП; Балакирев С.М.; 2021
# Python ООП; Балакирев С.М.; 2022
# Python; Балакирев С.М.; 2021
# Sample Output:


import sys

# здесь объявляйте класс

class BookStudy:

    def __init__(self, name, author, year):
        self.name = name
        self.author = author
        self.year = year

    def __hash__(self):
        return hash((self.name, self.author))

    def __eq__(self, other):
        return hash(self) == hash(other)

# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in не менять!

# здесь продолжайте программу (используйте список строк lst_in)

lst_bs = []

for i in lst_in:
    params = tuple((x.strip() for x in i.split(';')))
    lst_bs.append(BookStudy(*params))

unique_books = len(set(lst_bs))


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (релакс). Объявите класс с именем Dimensions, объекты которого создаются командой:
#
# d = Dimensions(a, b, c)
# где a, b, c - положительные числа (целые или вещественные), описывающие габариты некоторого тела: высота, ширина и
# глубина.
#
# Каждый объект класса Dimensions должен иметь аналогичные публичные атрибуты a, b, c (с соответствующими числовыми
# значениями). Также для каждого объекта должен вычисляться хэш на основе всех трех габаритов: a, b, c.
#
# С помощью функции input() прочитайте из входного потока строку, записанную в формате:
#
# "a1 b1 c1; a2 b2 c2; ... ;aN bN cN"
#
# Например:
#
# "1 2 3; 4 5 6.78; 1 2 3; 0 1 2.5"
#
# Если какой-либо габарит оказывается отрицательным значением или равен нулю, то при создании объектов должна
# генерироваться ошибка командой:
#
# raise ValueError("габаритные размеры должны быть положительными числами")
# Сформируйте на основе прочитанной строки список lst_dims из объектов класса Dimensions. После этого отсортируйте
# этот список по возрастанию (неубыванию) хэшей этих объектов так, чтобы объекты с равными хэшами стояли друг за другом.
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# 1 2 3; 4 5 6.78; 1 2 3; 3 1 2.5
# Sample Output:


class Dimensions:

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __hash__(self):
        return hash((self.a, self.b, self.c))

    def __setattr__(self, key, value):
        if key in ('a', 'b', 'c'):
            if type(value) not in (float, int) or type(value) in (float, int) and value <= 0:
                raise ValueError("габаритные размеры должны быть положительными числами")
        super().__setattr__(key, value)

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __ne__(self, other):
        return hash(self) != hash(other)

    def __lt__(self, other):
        return hash(self) < hash(other)

    def __gt__(self, other):
        return hash(self) > hash(other)


s_inp = input().strip()

lst = [[float(x) for x in i.strip().split()] for i in s_inp.split(';')]
lst_dims = sorted([Dimensions(*[float(i) for i in x]) for x in lst], key=lambda x: hash(x))


# Второй вариант
class Dimensions:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __setattr__(self, name, value):
        if value <= 0:
            raise ValueError("габаритные размеры должны быть положительными числами")
        object.__setattr__(self, name, value)

    def __hash__(self):
        return hash((self.a, self.b, self.c))


s_inp = input()
lst_dims = sorted([Dimensions(*map(float, elem.split())) for elem in s_inp.split('; ')], key=hash)


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/0EYz8-qG2iU
#
# Подвиг 10 (на повторение). Объявите класс с именем Triangle, объекты которого создаются командой:
#
# tr = Triangle(a, b, c)
# где a, b, c - длины сторон треугольника (числа: целые или вещественные). В классе Triangle объявите следующие
# дескрипторы данных:
#
# a, b, c - для записи и считывания длин сторон треугольника.
#
# При записи нового значения нужно проверять, что присваивается положительное число (целое или вещественное).
# Иначе, генерируется исключение командой:
#
# raise ValueError("длины сторон треугольника должны быть положительными числами")
# Также нужно проверять, что все три стороны a, b, c могут образовывать стороны треугольника. То есть, должны
# выполняться условия:
#
# a < b+c; b < a+c; c < a+b
#
# Иначе генерируется исключение командой:
#
# raise ValueError("с указанными длинами нельзя образовать треугольник")
# Наконец, с объектами класса Triangle должны выполняться функции:
#
# len(tr) - возвращает периметр треугольника, приведенный к целому значению с помощью функции int();
# tr() - возвращает площадь треугольника (можно вычислить по формуле Герона: s = sqrt(p * (p-a) * (p-b) * (p-c)),
# где p - полупериметр треугольника).
#
# P.S. На экран ничего выводить не нужно, только объявить класс Triangle.


class PositiveValue:
    def __set_name__(self, owner, name):
        self.name = '_' + name

    def __get__(self, instance, owner):
        return getattr(instance, self.name, None)

    def __set__(self, instance, value):
        if type(value) not in (int, float) or value <= 0:
            raise ValueError("длины сторон треугольника должны быть положительными числами")
        setattr(instance, self.name, value)


class Triangle:
    a = PositiveValue()
    b = PositiveValue()
    c = PositiveValue()

    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    def __setattr__(self, key, value):
        if (key == 'a' and not self.__is_triangle(value, self.b, self.c)) or \
            (key == 'b' and not self.__is_triangle(value, self.a, self.c)) or \
            (key == 'c' and not self.__is_triangle(value, self.a, self.b)):
            raise ValueError("с указанными длинами нельзя образовать треугольник")
        super().__setattr__(key, value)

    @staticmethod
    def __is_triangle(a, b, c):
        if a and b and c:
            return a < b + c and b < a + c and c < a + b
        return True

    def __len__(self):
        return self.a + self.b + self.c if self.a and self.b and self.c else None

    def __call__(self, *args, **kwargs):
        a, b, c = self.a, self.b, self.c
        if not(a and b and c):
            return

        p = 0.5 * (a + b + c)
        return (p * (p - a) * (p - b) * (p - c)) ** 0.5


# ----------------------------------------------------------------------------------------------------------------------

# ======================================================================================================================
# 3.7 Метод __bool__
# ======================================================================================================================

# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 1. Пусть в программе объявлен следующий класс:
#
# class User:
#     def __init__(self, name, old):
#         self.name = name
#         self.old = old
#
#     def __len__(self):
#         return self.old
# И создаются два его экземпляра:
#
# user1 = User('Sergey', 45)
# user2 = User('Петр', 0)
# Отметьте все верные пункты выполнения функции bool().


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 2. Пусть в программе объявлен следующий класс:
#
# class User:
#     def __init__(self, name, old):
#         self.name = name
#         self.old = old
#
#     def __len__(self):
#         return self.old + 1
#
#     def __bool__(self):
#         return bool(self.old)
# И определены два его объекта:
#
# user1 = User('Sergey', 45)
# user2 = User('Петр', 0)
# Отметьте все верные пункты, связанные с использованием функции bool().


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 3. Пусть в программе объявлен некоторый класс Book, в котором определен магический метод __bool__(). И создан
# объект book класса Book. Выберите все варианты команд, в которых будет происходить вызов
# магического метода __bool__().


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 4. Объявите в программе класс Player (игрок), объекты которого создаются командой:
#
# player = Player(name, old, score)
# где name - имя игрока (строка); old - возраст игрока (целое число); score - набранные очки в игре (целое число). В каждом объекте класса Player должны создаваться аналогичные локальные атрибуты: name, old, score.
#
# С объектами класса Player должна работать функция:
#
# bool(player)
# которая возвращает True, если число очков больше нуля, и False - в противном случае.
#
# С помощью команды:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# считываются строки из входного потока в список строк lst_in. Каждая строка записана в формате:
#
# "имя; возраст; очки"
#
# Например:
#
# Балакирев; 34; 2048
# Mediel; 27; 0
# Влад; 18; 9012
# Nina P; 33; 0
#
# Каждую строку списка lst_in необходимо представить в виде объекта класса Player с соответствующими данными. И из
# этих объектов сформировать список players.
#
# Отфильтруйте этот список (создайте новый: players_filtered), оставив всех игроков с числом очков больше нуля.
# Используйте для этого стандартную функцию filter() совместно с функцией bool() языка Python.
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# Балакирев; 34; 2048
# Mediel; 27; 0
# Влад; 18; 9012
# Nina P; 33; 0
# Sample Output:


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 5. Объявите в программе класс MailBox (почтовый ящик), объекты которого создаются командой:
#
# mail = MailBox()
# Каждый объект этого класса должен содержать локальный публичный атрибут:
#
# inbox_list - список из принятых писем.
#
# Также в классе MailBox должен присутствовать метод:
#
# receive(self) - прием новых писем
#
# Этот метод должен читать данные из входного потока командой:
#
# lst_in = list(map(str.strip, sys.stdin.readlines()))
# В результате формируется список lst_in из строк. Каждая строка записана в формате:
#
# "от кого; заголовок; текст письма"
#
# Например:
#
# sc_lib@list.ru; От Балакирева; Успехов в IT!
# mail@list.ru; Выгодное предложение; Вам одобрен кредит.
# mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
#
# Каждая строчка списка lst_in должна быть представлена объектом класса MailItem, объекты которого создаются командой:
#
# item = MailItem(mail_from, title, content)
# где mail_from - email отправителя (строка); title - заголовок письма (строка), content - содержимое письма (строка).
# В каждом объекте класса MailItem должны формироваться соответствующие локальные
# атрибуты (с именами: mail_from, title, content). И дополнительно атрибут is_read (прочитано ли) с начальным
# значением False.
#
# В классе MailItem должен быть реализован метод:
#
# set_read(self, fl_read) - для отметки, что письмо прочитано (метод должен устанавливать
# атрибут is_read = fl_read, если True, то письмо прочитано, если False, то не прочитано).
#
# С каждым объектом класса MailItem должна работать функция:
#
# bool(item)
# которая возвращает True для прочитанного письма и False для непрочитанного.
#
# Вызовите метод:
#
# mail.receive()
# Отметьте первое и последнее письмо в списке mail.inbox_list, как прочитанное (используйте для этого метод set_read).
# Затем, сформируйте в программе список (глобальный) с именем inbox_list_filtered из прочитанных писем, используя
# стандартную функцию filter() совместно с функцией bool() языка Python.
#
# P.S. На экран ничего выводить не нужно.
#
# Sample Input:
#
# sc_lib@list.ru; От Балакирева; Успехов в IT!
# mail@list.ru; Выгодное предложение; Вам одобрен кредит.
# mail123@list.ru; Розыгрыш; Вы выиграли 1 млн. руб. Переведите 30 тыс. руб., чтобы его получить.
# Sample Output:


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 6 (релакс). Объявите класс Line, объекты которого создаются командой:
#
# line = Line(x1, y1, x2, y2)
# где x1, y1, x2, y2 - координаты начала линии (x1, y1) и координаты конца линии (x2, y2). Могут быть произвольными
# числами. В объектах класса Line должны создаваться соответствующие локальные атрибуты с именами x1, y1, x2, y2.
#
# В классе Line определить магический метод __len__() так, чтобы функция:
#
# bool(line)
# возвращала False, если длина линии меньше 1.
#
# P.S. На экран ничего выводить не нужно. Только объявить класс.


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 7. Объявите класс Ellipse (эллипс), объекты которого создаются командами:
#
# el1 = Ellipse()  # без создания локальных атрибутов x1, y1, x2, y2
# el2 = Ellipse(x1, y1, x2, y2)
# где x1, y1 - координаты (числа) левого верхнего угла; x2, y2 - координаты (числа) нижнего правого угла. Первая
# команда создает объект класса Ellipse без локальных атрибутов x1, y1, x2, y2. Вторая команда создает объект с локальными атрибутами x1, y1, x2, y2 и соответствующими переданными значениями.
#
# В классе Ellipse объявите магический метод __bool__(), который бы возвращал True, если все локальные
# атрибуты x1, y1, x2, y2 существуют и False - в противном случае.
#
# Также в классе Ellipse нужно реализовать метод:
#
# get_coords() - для получения кортежа текущих координат объекта.
#
# Если координаты отсутствуют (нет локальных атрибутов x1, y1, x2, y2), то метод get_coords() должен генерировать
# исключение командой:
#
# raise AttributeError('нет координат для извлечения')
# Сформируйте в программе список с именем lst_geom, содержащий четыре объекта класса Ellipse. Два объекта должны быть
# созданы командой
#
# Ellipse()
# и еще два - командой:
#
# Ellipse(x1, y1, x2, y2)
# Переберите список в цикле и вызовите метод get_coords() только для объектов, имеющих координаты x1, y1, x2, y2.
# (Помните, что для этого был определен магический метод __bool__()).
#
# P.S. На экран ничего выводить не нужно.


# -


# ----------------------------------------------------------------------------------------------------------------------
# Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/2lnbu3n7Y_w

# Большой подвиг 8. Вы начинаете разрабатывать игру "Сапер". Для этого вам нужно уметь представлять и управлять игровым
# полем. Будем полагать, что оно имеет размеры N x M клеток. Каждая клетка будет представлена объектом класса Cell и
# содержать либо число мин вокруг этой клетки, либо саму мину.

# Для начала в программе объявите класс GamePole, который будет создавать и управлять игровым полем. Объект этого класса должен формироваться командой:
#
# pole = GamePole(N, M, total_mines)
# И, так как поле в игре одно, то нужно контролировать создание только одного объекта класса GamePole (используйте паттерн Singleton, о котором мы с вами говорили, когда рассматривали магический метод __new__()).
#
# Объект pole должен иметь локальный приватный атрибут:
#
# __pole_cells - двумерный (вложенный) кортеж, размерами N x M элементов (N строк и M столбцов), состоящий из объектов класса Cell.
#
# Для доступа к этой коллекции объявите в классе GamePole объект-свойство (property):
#
# pole - только для чтения (получения) ссылки на коллекцию __pole_cells.
#
# Далее, в самом классе GamePole объявите следующие методы:
#
# init_pole() - для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми);
# open_cell(i, j) - открывает ячейку с индексами (i, j); нумерация индексов начинается с нуля; метод меняет значение
# атрибута __is_open объекта Cell в ячейке (i, j) на True;
# show_pole() - отображает игровое поле в консоли (как именно сделать - на ваше усмотрение, этот метод - домашнее
# задание).
#
# Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией randint
# модуля random). После расстановки всех total_mines мин, вычислите их количество вокруг остальных
# клеток (где нет мин). Область охвата - соседние (прилегающие) клетки (8 штук).
#
# В методе open_cell() необходимо проверять корректность индексов (i, j). Если индексы указаны некорректно, то
# генерируется исключение командой:
#
# raise IndexError('некорректные индексы i, j клетки игрового поля')
# Следующий класс Cell описывает состояние одной ячейки игрового поля. Объекты этого класса создаются командой:
#
# cell = Cell()
# При этом в самом объекте создаются следующие локальные приватные свойства:
#
# __is_mine - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
# __number - число мин вокруг клетки (целое число от 0 до 8);
# __is_open - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.
#
# Для работы с этими приватными атрибутами объявите в классе Cell следующие объекты-свойства с именами:
#
# is_mine - для записи и чтения информации из атрибута __is_mine;
# number - для записи и чтения информации из атрибута __number;
# is_open - для записи и чтения информации из атрибута __is_open.
#
# В этих свойствах необходимо выполнять проверку на корректность переданных значений (либо булево значение True/False,
# либо целое число от 0 до 8). Если передаваемое значение некорректно, то генерировать исключение командой:
#
# raise ValueError("недопустимое значение атрибута")
# С объектами класса Cell должна работать функция:
#
# bool(cell)
# которая возвращает True, если клетка закрыта и False - если открыта.
#
# Пример использования классов (эти строчки в программе писать не нужно):
#
# pole = GamePole(10, 20, 10)  # создается поле размерами 10x20 с общим числом мин 10
# pole.init_pole()
# if pole.pole[0][1]:
#     pole.open_cell(0, 1)
# if pole.pole[3][5]:
#     pole.open_cell(3, 5)
# pole.open_cell(30, 100)  # генерируется исключение IndexError
# pole.show_pole()
# P.S. В программе на экран выводить ничего не нужно, только объявить классы.


# -


# ----------------------------------------------------------------------------------------------------------------------
# Подвиг 9 (на повторение). Объявите в программе класс Vector, объекты которого создаются командой:
#
# v = Vector(x1, x2, x3,..., xN)
# где x1, x2, x3,..., xN - координаты вектора (числа: целые или вещественные).
#
# С каждым объектом класса Vector должны выполняться операторы:
#
# v1 + v2 # суммирование соответствующих координат векторов
# v1 - v2 # вычитание соответствующих координат векторов
# v1 * v2 # умножение соответствующих координат векторов
#
# v1 += 10 # прибавление ко всем координатам вектора числа 10
# v1 -= 10 # вычитание из всех координат вектора числа 10
# v1 += v2
# v2 -= v1
#
# v1 == v2 # True, если соответствующие координаты векторов равны
# v1 != v2 # True, если хотя бы одна пара координат векторов не совпадает
# При реализации бинарных операторов +, -, * следует создавать новые объекты класса Vector с новыми (вычисленными)
# координатами. При реализации операторов +=, -= координаты меняются в текущем объекте, не создавая новый.
#
# Если число координат (размерность) векторов v1 и v2 не совпадает, то при операторах +, -, * должно генерироваться
# исключение командой:
#
# raise ArithmeticError('размерности векторов не совпадают')
# P.S. В программе на экран выводить ничего не нужно, только объявить класс.


# -


# ----------------------------------------------------------------------------------------------------------------------


# ======================================================================================================================