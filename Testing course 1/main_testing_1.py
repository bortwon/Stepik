# ========================== Начало =========================

# Программная ошибка (жарг. баг) — означает ошибку в программе или в системе, из-за которой программа выдает
# неожиданное поведение и, как следствие, результат. Большинство программных ошибок возникают из-за ошибок команды
# разработки.



# Тестирование программного обеспечения — процесс исследования, испытания программного продукта, имеющий своей целью
# проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе
# тестов, выбранных определённым образом. Тестировщик, в свою очередь, моделирует различные ситуации (тесты), которые
# могут возникнуть в процессе использования программы, чтобы разработчики смогли исправить обнаруженные баги.



# Мы воспользуемся популярной техникой тест-дизайна, позволяющей быстро и качественно проверить что-либо:
#
# - Техника выделения классов эквивалентности и граничных значений позволяет уйти от дублирующих проверок.
# Следовательно, мы сократим количество однотипных тестов.
#
# - Классы эквивалентности — это разбиение функционала на наборы данных, которые ведут себя в пределах этих наборов
# одинаково. Например, дети, взрослые и пенсионеры - это все классы эквивалентности.
#
# - Анализ граничных значений — это метод, который улучшает разделение классов эквивалентности. В нашем случае, самые
# близкие значения — это 17 и 66.



# Чек-лист– это список, содержащий ряд необходимых проверок во время тестирования программного продукта. Отмечая пункты
# списка, команда или один тестировщик могут узнать о текущем состоянии выполненной работы и о качестве продукта.

# ===================================================================



# ========================== Теория ==============================


# ------------------------ 2.2. Тестирование и качество ------------------------

# Качество программного обеспечения — способность программного продукта при заданных условиях удовлетворять
# установленным или предполагаемым потребностям.



# Quality assurance, Quality control и Testing. Who is who?

# 1. Testing (тестирование) — самый первый уровень. Это проверка программного продукта на соответствие требованиям
# этого продукта.

# То есть ожидаемый результат и фактический результат совпадают, и это тот минимум, без которого нельзя выпускать
# продукт. Возьмем для примера тестирование в интернет—магазине кнопки «Купить».
# В процесс тестирования будет входить проверка функционала и сверка с макетом. Кнопка нажимается, открывается нужное
# окно, кнопка находится в правом нижнем углу, окрашена в зеленый цвет и т.д.


# 2. QC (Quality Control, контроль качества) — второй уровень, включает в себя тестирование и контроль за соответствием
# заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшн.

# Основная задача контроля качества — предоставить объективную картину того, что происходит с качеством продукта на
# разных этапах разработки. Управление качеством (Quality control) — часть менеджмента качества, направленная на
# выполнение требований к качеству. Это означает, что необходимо выполнять требования, а как это будет
# происходить, зависит от корпоративной культуры.
# Вернемся к интернет-магазину. QC даст отмашку на релиз, если не заполнена страница благодарностей, на которую можно
# перейти из футера (подвала) сайта. Или, например, не даст добро, если страница благодарностей заполнена, а каталог
# пустой.


# 3. QA (Quality Assurance, обеспечение качества) — часть обеспечения согласованного уровня качества продукта. Это уже
# проактивная работа, т.к. основная задача обеспечения качества — это выстроить систему, которая будет работать на
# качество продукта, чтобы при тестировании количество дефектов было минимальным.
#
# В зависимости от специфики проекта сюда может входить тестирование документации, ревью кода на соответствие
# стандартам, внедрение каких-то методик по работе с качеством.
# Обеспечение качества (Quality Assurance) — часть менеджмента качества, направленная на создание уверенности, что
# требования к качеству будут выполнены.

# При более полном понимании можно обратиться к ГОСТ Р ИСО 9000-2015

# -------------------------------------------------------------------------------


# ---------------------------- 2.3. Принципы тестирования ---------------------------------

# Принципов тестирования всего 7. Как и большинство принципов, они редко напрямую используются на практике, но при
# этом любое тестирование предполагает их соблюдение:

# 1) Тестирование не может доказать отсутствие багов(только их наличие);
# 2) Исчерпывающее тестирование невозможно по определению;
# 3) Раннее тестирование позволяет сэкономить ресурсы;
# 4) Парадокс пестицидов;
# 5) Кластеризация багов;
# 6) Тестирование зависит от контекста;
# 7) Заблуждение об отсутствии багов;



# 1) Тестирование не может доказать отсутствие багов(только их наличие);

# Отсутствие багов во время проверки не может гарантировать отсутствия багов при подобных действиях в другое время. Из
# этого делаем вывод, что тестирование не может доказать отсутствие багов.

# Но с другой стороны, мы точно знаем, что баг может возникнуть у пользователя, раз он возник у нас. А раз баг есть,
# значит, что-то его вызывает. Следовательно, нужно найти причину этого бага и устранить ее.
#
# Исходя из этого, мы получаем вторую часть принципа — тестирование может доказать наличие багов.
#
# Здесь может показаться, что тестирование не так уж и нужно, раз не может ничего гарантировать. Да и тестировщик ни
# за что ответственности не несет — пропустил баг и ладно, отсутствие багов никто и не гарантировал. Все совсем не так.
# Как правило, для любого разрабатываемого ПО подразумеваются (и напрямую указываются) некие «нормальные условия», при
# которых оно должно работать, и именно в этих условиях проводятся проверки.

# P.S.
# Довольно хорошо иллюстрирует условия разработка мобильных приложений для устройств на iOS. Есть достаточно
# ограниченный список моделей айфонов и версий их операционной системы. Можно запланировать, что для запуска
# приложения нужна модель не старше определенной и версия iOS также не ниже определенной. При соблюдении этих условий
# приложение будет работать как задумано, в остальных случаях за результат никто не отвечает. И, соответственно,
# тестирование не проводится. С андроидом ситуация похожая, но там все чуть сложнее, т.к. у каждого производителя
# своя линейка моделей. Или вот еще пример: если вы напишете в техподдержку популярного баг-трекера Jira, что он
# некорректно работает на вашем макбуке, то получите ответ, что устройства от Apple официально не поддерживаются. В
# общем, это ваши проблемы, что у вас там не работает. Никто не будет разбираться до тех пор, пока не запустите на
# поддерживаемой конфигурации.



# 2) Исчерпывающее тестирование невозможно по определению;

# Тестировать можно бесконечно, проверяя различные сценарии поведения, но придется потратить оень много времени и
# ресурсов.

# На практике тестировщики выбирают наиболее эффективные проверки, руководствуясь знаниями о тестируемом ПО и здравым
# смыслом. Например, если у нашего поля в коде задано ограничение на ввод только цифр, то с ввода цифр и следует
# начать (положительные проверки всегда идут первыми!). Для негативных проверок достаточно будет несколько раз ударить
# по клавишам в русской раскладке. Ну и на английской, для успокоения совести. Ничего не появилось — ок, буквы не
# принимает. Теперь спецсимволы — как правило, в таком случае просто копируется и вставляется строка в
# духе `~@#$%^&*()_+|-=\{}[]:»;’<>?,./®©£¥¢¦§«»€. Если что-то из этого не заблокировано, оно появится в поле. Плюс надо
# быть особенно внимательным к точкам и запятым, ведь ими может отделяться дробная часть, поэтому попробовать
# ввести «2,» и «5.» тоже стоит. Вот и все, мы ужали годы проверок в пять минут и отправились тестировать следующее
# поле, спасибо второму принципу тестирования.



# 3) Раннее тестирование позволяет сэкономить ресурсы;

# Пожалуй, самый осязаемый, самый материальный принцип. Как вы позже узнаете, процесс тестирования программного
# обеспечения включает в себя не только работу с уже готовым или скорее полуготовым продуктом. По сути
# своей, тестирование сопровождает процесс разработки где-то с момента зарождения идеи. Когда на каждую мысль «Вот
# так будет очень хорошо!» появляется критическая оценка «А правда ли будет?» — это уже можно назвать тестированием.

# Но, возвращаясь к тестированию ПО, чем раньше была найдена ошибка (она же баг, она же дефект и т.д.), тем больше
# ресурсов будет сэкономлено. Ну или меньше потрачено, разницы нет. Под ресурсами мы понимаем, в первую очередь, время
# и деньги.

# Современные подходы говорят о том, что тестирование должно участвовать во всех этапах разработки ПО, а не просто
# получать на руки новую версию и протыкивать ее на предмет багов. Эффективность подобных практик доказана реальными
# результатами, поэтому в идеале команда тестирования должна быть на проекте уже на стадии первых обсуждений и планов.



# 4) Парадокс пестицидов;

# На практике возможна ситуация, когда программист, исправляя неоднократно найденный баг, изменит код таким образом, что
# баг на тех же самых данных перестанет повторяться, а на других продолжит. Предположим, в калькуляторе вместо
# умножения происходит сложение. Тестировщик всегда проверяет умножение, вводя 5х5 и получая 10 вместо 25. Тогда
# разработчик напишет код примерно такого содержания: если А=5 и В=5, то АхВ=25, во всех остальных случаях АхВ=А+В. В
# очередной раз введя 5х5, тестировщик наконец увидит 25 и подтвердит исправление бага. А если бы каждый раз вводил
# разное…
#
# Разумеется, ни один вменяемый разработчик никогда не поступит подобным образом. Но на этом тривиальном примере
# очевидна нелогичность решения. В большой сложной системе может быть непонятно, что новый код не исправляет реальную
# проблему, а лишь делает ее менее заметной.

# Итог:
# если одни и те же тесты повторяются снова и снова, в конечном итоге один и тот же набор тестов больше не обнаружит
# никаких новых дефектов. Чтобы преодолеть этот “парадокс пестицидов”, необходимо регулярно пересматривать и
# пересматривать тестовые примеры, а также писать новые и различные тесты для проверки различных частей программного
# обеспечения или системы на наличие потенциально большего количества дефектов.



# 5) Кластеризация багов;

# Закон Парето справедлив и для дефектов ПО. Это тот, который про 20% одного дает 80% другого. В нашем случае одним
# является функционал, а другим — баги. Ошибки при проверках имеют свойство складываться вместе, образовывая кластер.
# Или кучковаться в одном кластере разрабатываемого ПО — суть не меняется.
#
# Почему так получается? Причин может быть много, одно тянет за собой другое, а каждый случай индивидуален. Например,
# за «проблемный» модуль продукта отвечает программист, который ранее с подобными задачами не сталкивался. Учится по
# ходу дела и допускает много ошибок при выполнении задач. Или у заказчика нет четкого понимания как эта часть
# программы должна работать, он пытается менять решения на ходу, что сильно сказывается на уже сделанных частях. Или
# модуль плохо описан в документации, из-за чего возникает множество разночтений при выполнении.
#
# Докопаться до первопричины, устранить сразу множество имеющихся багов или хотя бы предотвратить появление
# будущих — это очень здорово. Но редко когда удается это сделать. Если разработчик только набирается опыта, он не
# наберется его моментально. На заказчика не снизойдет ясное видение готового продукта. А документация не изменится
# в одночасье.
#
# Для нас, как тестировщиков, важен один вывод из пятого принципа: нашел баг — поищи другой поблизости.
#
# P.S.
# Немного о другом, но все же важном на практике моменте. Согласно принципам программирования, похожие элементы не
# создаются каждый по отдельности. Вместо этого общая часть кода пишется в одном месте и используется уже в коде
# однотипных элементов в виде ссылки, а разнящиеся части дописываются после нее. Таким образом, если баг вызван ошибкой
# в общей части кода, сломаются все использующие общий код элементы. И, будучи найденным в одном элементе, этот баг
# может быть пропущен в другом. Об этом тоже надо помнить и сразу оценивать, что еще мог зацепить найденный баг.



# 6) Тестирование зависит от контекста;

# Это значит, что способ, которым вы тестируете сайт для e-commerce, будет отличаться от способа тестирования
# мобильного приложения. Софт бывает самый разный и подход к его тестированию тоже бывает самый разный. Необходимо
# применять разные подходы, методологии, техники и типы тестирования в зависимости от приложения.

# PS
# Уместна такая аналогия: спортсмен, готовящийся к соревнованиям, занимается спортом 6 часов в день. Офисный работник,
# заботящийся о своем здоровье, занимается спортом 6 часов в неделю.
# Все решают приоритеты, определяемые глобальными и текущими задачами, т.е. тот самый контекст.




# 7) Заблуждение об отсутствии багов;

# Отсутствие багов невозможно, но это мы знали и раньше, так о чем же седьмой принцип? Он о том, что отсутствие багов
# не смогло бы обеспечить серьезных преимуществ. Не надо бояться самого факта наличия багов в системе, баги — это
# нормально.
#
# P.S.
# И это опять-таки не значит, что тестировщик не несет ответственности за пропущенный баг, а на любые претензии может
# ответить «Баги — это нормально». Действительно, пропущенный краш приложения, повторяющийся при смене языка у 0,001%
# пользователей, это не так уж и страшно. Пропущенный краш приложения при запуске, повторяющийся у 99%
# пользователей — свидетельство того, что приложение никто не тестировал. Если хорошо поискать, баги найдутся в любом
# ПО, но очень важно, чтобы эти баги не мешали (ну хотя бы несильно) большинству пользователей.



# Task.
# Известно, что основной поток посетителей приходит по результатам запроса “.......”, сделанного с
# мобильного телефона. Используя сервис https://gs.statcounter.com/, необходимо выбрать три самых популярных браузера;
# на них будем осуществлять проверку.

# - Google Chrome
# - Safari
# - Samsung Internet



# Task.
# Предположим, мы в 1963 году тестируем поле ввода, которое может принимать только символы ASCII. Какое количество
# позитивных проверок будет исчерпывающим для поля, если известно, что ввести возможно только 3 символа?

# - 2 097 152
# (Согласно википедии, изначально (1963 год) ASCII была разработана для кодирования символов, коды которых
# помещались в 7 бит (128 символов; 2^7=128). Количество сочетаний из трёх символов вычисляется с помощью возведения
# общего количества возможных символов в третью степень. 128^3=2 097 152)



# Task.
# Что нужно делать, чтобы избежать парадокса пестицида?

# - Добавлять новые тесты
# - Пересматривать и улучшать тесты
# - Использовать разные тестовые данные



# Task.
# Предположим, у нашего сайта на 5 разных страницах встречаются селекты. Это такие выпадающие списки, вы их точно видели
# и не раз. При этом на 2 страницах селект представляет собой выпадающий список из нескольких вариантов. Назовем этот
# тип Селект 1.

# На 2 страницах список длинный и есть возможность искать по нему, вводя что-либо в поле селекта. Он будет - Селект 2.

# На последней странице при клике по селекту вместо выпадающего списка появляется подсказка «Введите не менее 3
# символов для поиска» и только после ввода появляется соответствующий поиску список возможных вариантов. А он будет
# Селект 3.

# При клике по Селекту 3 он не раскрылся. Какое предположение будет наиболее логичным для поиска аналогичной ошибки:

# - Имеет смысл проверить Селекты 1 и 2, т.к. выпадающий список при клике - общая функциональность всех селектов.



# Task.
# Отметьте виды тестирования, которые следует провести для мобильной игры с аудиторией 1 млн пользователей (в целях
# задачи считать, что ресурсов достаточно для любого объема тестирования):

# - тестирование безопасности
# - тестирование установки
# - тестирование удобства использования
# - функциональное тестирование
# - тестирование производительности
# - нагрузочное тестирование
# - тестирование совместимости



# Task.
# Перед вами требования заказчиков на разных проектах. Используя знание принципов тестирования отметьте те из них,
# которые, скорее всего, НЕ получится выполнить.

# - Да какая документация, приложение маленькое, его можно и так проверить;
# - Приложение должно соответствовать дизайну на любом устройстве;
# - Не выпустимся пока не выловим все баги;
# - Наше ПО рассчитано прежде всего на домохозяек, у них оно баговать не должно;
# - За пару часов до релиза передаём новую версию в тестирование, выпускаемся на всех возможных платформах.


# ====================================================================================



# ========================= 2.4 Методологии разработки =======================================

# SDLC, Waterfall, Agile и CI/CD. Who is who?

# Мы уже понимаем, что любое программное обеспечение создается по определенным правилам или «канонам», если хотите. В
# силу этого обстоятельства существует такое понятие как «жизненный цикл ПО».
#
# Жизненный цикл ПО (SDLC) – это период времени, который начинается с возникновения идеи продукта до прекращения его
# использования — вывода из эксплуатации.
#
# Жизненный цикл программного обеспечения состоит из последовательных этапов:
#
# - Анализ требований. На этом этапе составляется ТЗ(Техническое задание – это документ, содержащий информацию для
# постановки задач на разработку), обозначаются сроки по каждой задаче и план работ. Здесь также нужно учитывать все
# возможные риски. Как только все детали просчитаны и описаны – можно переходить к следующему этапу;

# - Дизайн системы. Разрабатывается прототип, дизайн-макет, платформа для программирования. Все члены команды должны
# быть расписаны по ролям, а также необходимо указать их обязанности;

# - Разработка. Команда пишет код продукта, согласно требованиям технического задания;

# - Тестирование. Проверка продукта, когда код написан. Если все благополучно, работу можно считать практически
# законченной;

# - Техническая поддержка. После релиза продукта, команда разработки поддерживает работу проекта на стабильном
# уровне, собирая обратную связь от пользователей и устраняя баги, если они возникают.



# Waterfall —  водопадная/каскадная модель разработки, описанная в 1970 году, дублирует этапы жизненного цикла ПО.
# Waterfall позволяет решать задачи по последовательному плану без возврата на предыдущие этапы.
#
# Принципы Waterfall:
#
# - Следуйте правилам;
# - Нет ТЗ — нет продукта;
# - Чем подробнее ТЗ, тем лучше продукт;
# - Следите, чтобы не было изменений.


# По мере развития и распространения ПО, нужно было максимально погружаться в проект, чтобы контролировать
# изменения, взаимодействовать с командой, предлагать новые решения. В рамках Waterfall это было невозможно, так как
# водопадная модель разработки не была гибкой. Именно в этот момент и появился Agile.


# Agile — это группа методик для гибкого управления продуктом. Суть этой группы методик заключается в разбивке
# процесса на небольшие временные промежутки — спринты. Во время каждого спринта команда разработки создает часть
# продукта, которую можно протестировать. Такой подход позволяет вносить правки на любом этапе.
#
# В Agile работа над продуктом строится по следующей логике:
#
# - составление ТЗ;
# - проектирование;
# - разработка;
# - тестирование;
# - результат.


# Пример
# Рассмотрим нашу тему на примере производственного процесса:


# Waterfall завод мороженого
#
# Гендиректор поручает технологу разработать новый вид мороженого. В лучшем случае, технолог пойдет в отдел
# маркетинга, чтобы они провели исследования. Но обычно такие идеи возникают не от желания потребителей, основанного
# на маркетинговых исследованиях, а от желания самого директора. По результатам исследований технолог разработает
# мороженое на собственный вкус и приносит его директору. Он пробует новый продукт и решает — переделывать или нет.
# Далее после утверждения директором, варщикам выдают технологические карты, по которым они могут запускать продукт в
# производство. Затем продавцам для реализации – упакованное мороженое. Это стандартный подход. Сотрудники получают
# задания, а оценка производится одним (иногда несколькими) человеком.


# Agile завод мороженого
#
# Гендиректору приходит идея разработать новый вид мороженого, и вот тут начинается чудо. При создании продукции
# будут задействованы не только технологи и сотрудники маркетинга, но также менеджеры по продажам, логисты, повара и
# реальные покупатели. При этом в команде нет никакой иерархии (кроме генерального директора) и итогом работы будет не
# награда конкретного сотрудника, а получение нового вида мороженого для покупателей. При этом все участники команды
# оценивают результат и дают обратную связь для его улучшения.


# Манифест гибкой разработки ПО:
#
# - Люди важнее инструментов.
# - Качество продукта важнее документации.
# - Взаимодействие с заказчиком важнее контракта.
# - Готовность к изменениям важнее установленного плана.



# Непрерывная разработка
# В разработке любого софта есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.

# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.

# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.

# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.

# В рамках непрерывного подхода решаются следующие задачи:
#
# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.

# CI/CD чаще всего зависит от тестировщиков и девопсов:
#
# - Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# - Девопсы автоматизируют процесс доставки ПО.

# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# Расположите этапы жизненного цикла ПО в правильном порядке:

# - Анализ требований
# - Проектирование
# - Разработка
# - Тестирование
# - Техническая поддержка



# Task.
# Выберите принципы методологии Agile:

# - Качество продукта важнее документации
# - Взаимодействие с заказчиком важнее контракта
# - Люди важнее инструментов
# - Готовность к изменениям важнее установленного плана



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Девопсы
# - Тестировщики



# =============================== 2.3 Подходы к разработке ==============================


# -------------------------------------------------
# Подходы к разработке
# -------------------------------------------------
# В разработке любого ПО есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.


# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.


# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.


# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.


# В рамках непрерывного подхода решаются следующие задачи:

# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.
#
# CI/CD чаще всего зависит от тестировщиков и разработчиков:
#
# Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# Разработчики автоматизируют процесс релиза ПО.
# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Тестировщики
# - Разработчики



# ================================ 2.5 Процесс тестирования ==========================================

# ISTQB - Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.
#
# Процесс тестирования
# Вопреки ожиданиям, процесс тестирования несколько шире, чем «садишься за комп и тестишь». Помимо непосредственного
# взаимодействия с объектом тестирования, существуют как подготовительные этапы, так и последующие. Для того, чтобы
# проверки стабильно давали точную информацию о качестве продукта, они документируются и регулярно актуализируются.
#
# Для измерения эффективности тестирования и отслеживания общего качества используются специальные метрики. На
# основании полученных результатов и рассчитанных метрик составляются отчеты. По разным оценкам, работа с документацией
# занимает от 50% до 70% времени тестировщика, на само же тестирование тратится оставшаяся часть.
#
# Настроенные процессы — залог успешной реализации проекта, и тестирование в этом успехе играет не последнюю роль.
#
# Четкое понимание того, что, как и в какой момент делать, экономит время, придает уверенность, устанавливает хорошие
# взаимоотношения в команде. Подобно фундаменту здания, который никто не видит, но на который все опирается. Сами по
# себе процессы не могут обеспечить успешность проекта, но могут существенно упростить ее достижение. Процесс
# тестирования не является чем-то отдельным, он плотно переплетается с другими процессами, входящими в разработку и
# выпуск программного обеспечения.
#
# Дисклеймер: в качестве основы для описания процесса тестирования была взята Программа подготовки базового уровня 2018
# года ISTQB, доступная для скачивания по ссылке https://www.rstqb.org/ru/istqb— downloads.html (на русском и
# английском языках)



# -------------------- Планирование -----------------------------
# Прежде всего оговоримся, что весь описываемый процесс не обязательно представляет собой жесткую последовательность.
# Разные этапы могут идти параллельно, потому что тут не успели, а там сделали раньше. Могут возникнуть непредвиденные
# обстоятельства, из-за которых придется возвращаться к сделанному ранее и переделывать по-новому.
#
# Процессы (в том числе тестирования) в разных компаниях или в одной компании на разных проектах могут существенно
# отличаться, поэтому данное описание не является догмой на все 100%. И, наконец, несмотря на то, что мы говорим о
# проекте в целом, процесс может применяться и отдельно к его частям. Например, выпуск новой версии вполне может пройти
# все описанные  здесь этапы. Обо всем этом надо помнить в процессе изучения и осмысления материала.
#
# Планирование тестирования — этап составления планов (внезапно!). Тест-план включает в себя всю общую информацию о
# проекте. Например, требования и дизайн продукта. Под требованиями подразумевается документ(ы), в котором
# сформулировано, какую функциональность продукт должен предоставлять пользователю. Техническое задание, спецификации,
# требования, юзер стори, любые аналогичные документы. Требования могут быть расписаны в разных формах, но они в любом
# случае включают в себя описание работы конечного продукта. Например:
#
# пользователь должен иметь возможность авторизоваться на сайте;
# авторизованный пользователь должен иметь возможность зайти в личный кабинет;
# в личном кабинете пользователь должен иметь возможность прикрепить банковскую карту с целью использования ее для
# будущих покупок на сайте.
#
#
# Дизайном называют макеты будущего продукта, отрисованные в графическом редакторе. Не так давно многое рисовалось в
# фотошопе, но сейчас чаще используются специальные программы, имеющие «заточенный» для этих целей интерфейс и
# функционал. Например, довольно популярна Figma — мы еще столкнемся с ней на следующих уроках, но можете погуглить
# ради интереса уже сейчас. Требования, дизайн и любые другие описывающие будущий продукт вещи называются «тестовым
# базисом».
#
# Помимо этого, план тестирования может включать в себя, например, расписание тестирования, т.е. когда будет
# тестироваться какая часть продукта. Откуда это может быть известно? Нельзя разрабатывать продукт по принципу «когда
# будет готово», все работы имеют временные оценки и установленные сроки реализации. Соответственно, когда будет
# готова конкретная функциональность, тогда и начнется ее тестирование.
#
# Еще к плану тестирования можно приложить анализ рисков, список метрик с формулами, бюджет, критерии начала и
# окончания тестирования, образцы тестовой документации, описание используемых техник и технологий. Вообще что угодно
# из того, о чем можно договориться «на берегу», когда разработка еще не начата. Вся общая информация, хоть как-то
# касающаяся тестирования — здесь.



# ------------------------------- Мониторинг и контроль -----------------------------------

# Этап мониторинга и контроля не является этапом «до» или «после», это этап «во время». Во время всего проекта, если
# быть точнее. Мониторинг и контроль тестирования подразумевают непрерывное отслеживание фактического хода работы и
# сверку его с тестовым планом. Помните, на этапе планирования мы говорили о расписании? Крайне важно не только иметь
# такой документ, но и регулярно к нему обращаться, а в случае расхождения вовремя принимать меры, чтобы
# скорректировать ход работ. Расчет метрик тестирования также входит в мероприятия данного этапа.
#
# Одной из метрик является процент пройденных проверок — завтра у нас выходит новая версия, а сегодня она
# протестирована только на 10% — значит, что-то идет не так. Например, новую версию установили только сегодня. Или
# ее установили неделю назад, а мы ничего не тестировали. Ищем причину, устраняем ее, продолжаем работу в штатном
# режиме.
#
# Разумеется, отчетность — тоже элемент данного этапа. Стандарт ISO/IEC/IEEE 29119-3 выделяет два вида отчетов: отчет
# о ходе тестирования и отчет о завершении тестирования. Форма и содержание отчетов могут сильно отличаться от проекта
# к проекту, а также в зависимости от целей, которые преследуют конкретные отчеты, и аудитории, для которой они
# составляются.
#
# Например, для сложных, формальных проектов с большим числом заинтересованных лиц может потребоваться более подробная
# и строгая отчетность. В гибкой разработке отчеты о ходе тестирования могут быть частью обсуждения на ежедневных
# встречах, поэтому составляются в автоматическом или полуавтоматическом режиме (например, путем выгрузки списка
# задач, по которым велись работы, из баг-трекера).
#
# В целом, для понимания того, что что-то идет не так, требуется отслеживать то, как оно идет в данный момент и знать,
# как оно должно идти. Мониторинг и контроль тестирования это в первую очередь задача руководства. Для рядового же
# сотрудника (как правило) данный этап заканчивается на выполнении регламентированных рутинных действий по ежедневному
# заполнению форм, если они не заполняются автоматически по мере его работы.



# ------------------------------------- Анализ ------------------------------------------------

# На этапе анализа занимаются… анализом (бадум тссс!). Крайне здравый вопрос: «Анализом чего»? И здесь мы приходим к
# фундаментальному принципу трассируемости, о котором будем упоминать постоянно и который красиво выстроится у нас к
# концу этого урока. Мониторинг и контроль стоит как бы в стороне, т.к. идет параллельно всем другим этапам. Но
# поставить его в самое начало или в самый конец списка было бы не очень логично.
#
# Из-за этого он вклинился на второе место и немного поломал последовательность, но это не страшно. Итак, на этапе
# анализа мы анализируем тестовый базис, собранный на этапе планирования. Напомним, что тестовым базисом у нас
# называются описывающие будущий продукт требования и дизайн.
#
# Анализировать их можно с двух сторон:
#
# Анализ базиса на наличие ошибок. Все документы, входящие в базис, тоже можно тестировать и выявлять такие баги, как
# неточность, неоднозначность, противоречивость, избыточность и т.д. Например, если на макете главной страницы
# кнопка «личный кабинет» расположена в десяти разных местах, это вполне может быть поводом уточнить, не стоит ли
# сократить это количество хотя бы до 9. Или требование нарисовать 7 перпендикулярных линий (погуглите, ролик веселый)...
# Анализ базиса с целью выявления тестовых условий. Под тестовыми условиями понимается конкретное утверждение, которое
# можно проверить. Например, «кнопка должна быть красивенькая» — не тестовое условие, а «кнопка должна быть 20х40,
# цвета FF0000, с надписью цвета FFFFFF «Старт» шрифтом Times new roman размера 9,5» — целый набор тестовых условий.
# Таким образом, по завершении этого этапа мы должны получить полностью непротиворечивые, абсолютно точные и
# максимально подробные документы тестового базиса и целый набор таких же качественных тестовых требований.



# --------------------- Проектирование----------------------

# И вот наступает этап проектирования, на котором мы будем… проектировать (никогда не надоест). Но
# вопросы: «Что именно?» и «Как?» здесь более чем уместны, давайте найдем на них ответ. Мы будем писать высокоуровневые
# тест-кейсы на основании тестовых условий. Для начала очень кратко разберем, что такое тест-кейс (подробно о
# тест-кейсах поговорим в модуле 3). Тест-кейс, он же тестовый сценарий, представляет из себя описание
# последовательности конкретных шагов (действий), которые следует пройти для проверки какой-либо функциональности. Как
# правило, для каждого шага прописывается ожидаемый результат, т.е. что должно произойти при выполнении действия,
# например:
#
# Нажать ЛКМ на иконку корзины в правой верхней части страницы — Страница корзины открыта.
#
# По сути своей, это уже тест- кейс — очень короткий, но все же. На практике тест-кейсы обычно длиннее. Например,
# открыть каталог, добавить товар в корзину, потом перейти в нее и убедиться, что товар добавился — уже вполне себе
# тест-кейс «Проверка добавления товара в корзину». Высокоуровневый тест-кейс характеризуется отсутствием привязки к
# конкретным данным — то есть мы не указываем какой именно товар из какого раздела каталога должен быть добавлен. Или,
# скажем, при проверке авторизации пишем «ввести корректный логин и пароль» вместо указания конкретных логина и пароля.
#
# Примечание: в других популярных источниках такое деление на высокоуровневые и обычные тест-кейсы отсутствует, но все
# же ISTQB достаточный авторитет, чтобы о нем рассказать.
#
# Тест-кейсы пишутся на основании тестовых условий. Вспомним нашу кнопку (которая «Старт», а не которая красивенькая),
# нам потребуется проверить ее цвета, надпись и шрифт. Так как тест-кейсы у нас высокоуровневые, мы просто укажем что
# ее параметры корректны, «соответствуют макету» (предположим, что мы взяли их с макета). В такой формулировке
# тест-кейс можно будет применить не только к конкретно этой кнопке, а вообще ко всем кнопкам, изображенным на
# макете (т.е. вообще ко всем кнопкам нашего продукта, т.к. макет должен отображать итоговый вид).
#
# И вот смотрите, как интересно у нас уже выстраиваются рабочие продукты каждого этапа по принципу
# трассируемости: сначала из макета, представляющего тестовый базис, были выделены тестовые условия, а уже на их
# основании написан высокоуровневый тест-кейс. То ли еще будет, идем дальше!



# ------------------------------- Реализация ---------------------------------------------

# На этапе реализации мы, как ни странно, не реализуем. Данный перевод английского implementation хоть и является
# самым распространенным, в данном случае крайне неудачен. В первоисточнике слово употребляется в значении «снабжение
# инструментами» и, собственно, именно это и происходит на данном этапе.
#
# Инструментами в нашем случае являются, например, все необходимые для тестирования вспомогательные программы.
# Баг-трекер, в котором будут описываться все найденные баги и отслеживаться прогресс их исправления. Сначала
# баг-трекер необходимо выбрать, затем оплатить его использование, после чего создать нужное количество учетных записей
# для всех, кто будет участвовать в процессе разработки.
#
# Также понадобится настроить баг-трекер —  уже упомянутая ранее Jira позволяет очень гибко кастомизировать набор
# полей, которые будут использоваться в ходе работы. Помимо банальных заголовка, описания, версии продукта и
# окружения, на котором воспроизводится баг, можно, например, добавить список компонентов продукта (отдельные разделы
# интернет— магазина — каталог, корзина, личный кабинет и т.д.). Или с помощью системы лейблов создать сложную
# детализацию функционала, который затрагивает баг (лучше не надо, но возможность есть). Также инструментами будет
# дополнительное ПО для выполнения каких-то специфических действий —  для работы с базой данных проекта, для
# проведения нагрузочного тестирования и т.д.
#
# Нельзя забывать о настройке стендов для тестировщиков, разработчиков, для других заинтересованных (менеджмента,
# инвесторов). Пусть вас не пугает слово «стенд» —  под ним подразумевается версия продукта, закрытая для доступа
# посторонних. То есть это банально тот же сайт интернет-магазина, что в итоге будет выпущен, но только его ранняя
# версия. С каталогом из 5 товаров, с регулярно отваливающейся корзиной и в принципе половиной функционала в
# состоянии «еще не готово». Зато имеющийся функционал уже надо тестировать.
#
# То есть, если нашим продуктом является сайт bestshop.org, то по адресу test-bestshop.org может располагаться стенд
# для тестировщиков, dev-bestshop.org —  стенд разработчиков, а manage-bestshop.org —  стенд для менеджмента.
#
# Разработчики пишут фичи и смотрят как они работают на своем стенде, потом набор фич объединяется вместе и составляет
# новую версию продукта —  ее раскатывают на стенде тестировщиков и она тестируется, а последняя стабильная
# протестированная версия устанавливается на менеджерский стенд, чтобы начальство могло отслеживать ход работ,
# показывать его заказчику, инвесторам и еще кому угодно, кто должен это увидеть.
#
# Сами стенды могут быть развернуты, например, во внутренней сети компании и извне на них зайти никто никогда не
# сможет. Устройство всей этой системы, в том числе и с «железной» стороны (программы должны запускаться на
# компьютерах, которые еще купить и настроить сначала надо) — тоже часть этапа реализации.
#
# Этот этап тоже мог бы выпасть из принципа трассируемости, если бы на этом его описание и окончилось, но нет. Также
# на этом этапе подготавливаются тестовые данные. Те самые тестовые данные, в отрыве от которых пишутся
# высокоуровневые тест-кейсы. То есть, если мы сложим эти два компонента, то получим что? Правильно, готовые к
# употреблению тест-кейсы.
#
# Тест-кейсы могут укладываться в последовательности в рамках этого этапа (логично сначала протестировать
# авторизацию, а потом личный кабинет — можно сэкономить немного времени).
#
# В целом, этап реализации можно было бы назвать этапом «настройки» или этапом «подготовки к выполнению», но
# первоисточник — есть первоисточник.



# ------------------------------------ Выполнение -----------------------------------------

# Ну что ж, мы прошли долгий путь и теперь, вооруженные до зубов спецификациями, установленными программами,
# настроенными доступами и целой кучей тест-кейсов мы переходим на этап выполнения, на котором будем
# ВЫПОЛНЯТЬ (вы же не думали, что эта шутка могла закончиться?) тестирование. Как мы будем это делать?
#
# Да, в общем-то, вот он, тот самый этап «протыкивания», этап «берешь и тестишь», с которым многие и ассоциируют
# профессию тестировщика (из тех, кто вообще о ней знает). У нас есть набор действий, ожидаемый результат которых
# заранее известен (тест-кейсы). Мы производим эти действия, отслеживая получаемый результат. Если полученный
# результат не совпал с ожидаемым, на это пишется баг-репорт, который уходит разработчикам. Результат каждого
# прохождения тест-кейсов (pass/fail) документируется на протяжении всего времени существования проекта.
#
# Остановимся чуть подробнее на этом моменте, чтобы процесс тестирования ПО стал немного понятнее. До сих пор мы
# описывали все этапы так, как будто однажды завершив один этап, мы переходим к следующему и больше назад не
# возвращаемся. В начале урока был дисклеймер о том, что последовательность не жесткая, вот его-то мы расширим и
# углубим.
#
# К нам на стенд приехала самая первая версия продукта, которую мы должны протестировать. Это маленький кусочек
# функционала, например, страница авторизации. При успешном вводе логина пароля нам показывается заглушка —  страница
# с надписью «авторизация успешна».
#
# Если же логин и пароль не подходят друг к другу, демонстрируется соответствующее сообщение. Функциональность
# протестирована, тест-кейсы пройдены, баг-репорты написаны. Приезжает новая версия, в которой исправлены баги
# предыдущей плюс добавлен новый функционал — вместо заглушки теперь показывается главная страница, только на ней
# ничего не работает (это прикрутят уже в следующей версии).
#
#  И вот важный момент, каковы наши действия:
#
# проверяем, исправлены ли баги предыдущей версии (те, которые разработчики пометили как исправленные и передали нам),
# в зависимости от результата переводим их в статус исправленных или возвращаем разработке на исправление;
# проводим тестирование нового функционала, проходим тест-кейсы, пишем баг-репорты;
# проводим полное тестирование оставшегося функционала (это называется регрессионное тестирование или сокращенно
# регресс), чтобы убедиться, что исправление багов и добавление новых фич его не сломало;
# в ожидании новой версии работаем с документацией, т.е. проверяем актуальность имеющихся тест-кейсов, пишем новые,
# считаем метрики и т.д.;
# Когда на наш стенд установят новую версию, все повторится по новой. Возможно, в какой-то момент будет внедряться
# фича, которая не была изначально запланирована, и в отношении нее весь тестовый процесс начнется сначала, при этом
# реализация запланированных фич прерываться не будет, они также будут выходить в рамках новых версий как было
# задумано изначально. Процессы будут идти параллельно, пока в определенный момент новая фича просто не станет частью
# новой версии продукта.
#
# Надеюсь, нам удалось передать, что процесс тестирования — это не лестница, это река.



# -------------------------------------- Завершение -------------------------------------------

# Этап завершения необязательно подразумевает под собой завершение всего проекта. Речь идет о завершении какой-то части
# работ, которую можно выделить. Это может быть банально выпуск новой версии. Что-то более крупное, например, выход
# продукта в релиз. Завершение проекта — тоже вполне себе подходящий повод, но все же он бывает один раз, а этапов
# завершения в процессе тестирования подразумевается гораздо больше.
#
# Это этап подведения итогов, учета возникших проблем и разработки способов их избежать в будущем. Тот момент, когда
# надо остановиться, оглянуться на проделанную работу и сказать «Хм, а ведь неплохо. Но в будущем можно поменять вот
# тут и тут и получится еще лучше». И обязательно сделать так в следующей версии, следующем релизе, следующем проекте.
# Ведь полученный опыт, дополнительно осмысленный на данном этапе, не позволит повторить допущенные ошибки. Время
# собирать камни.
#
# Вещественно этап воплощается в отчетах о проведенных проверках и их результатах, а также в изменениях в работе
# команды. Об изменениях говорить не будем — они индивидуальны для каждого проекта, каждой команды. А вот на отчетах
# остановимся, снова вспомнив принцип трассируемости в процессе тестирования. Возьмем отчет, в котором прописано, что
# баг А был обнаружен при прохождении тест-кейса Б, который в последней на данный момент версии продукта был пройден
# успешно. Тест-кейс Б был написан на основании тестового условия C, выделенного из пункта D документа E,
# представляющего собой список требований, выявленных аналитиком Ивановым при общении с заказчиком.
#
# На самом деле, правильно называть наш принцип «принципом двунаправленной трассируемости», ведь при его соблюдении
# мы можем проследить путь как от требования к результату в конечном продукте, так и от конечного продукта к
# конкретному требованию. И на этом мы ЗАВЕРШАЕМ теорию процесса тестирования (потому что никто не ждет испанскую
# инквизицию).



# Task.
# Поставь этапы тестирования в правильном порядке, с теоретической точки зрения:

# - Планирование
# - Мониторинг и контроль
# - Анализ
# - Проектирование
# - Реализация
# - Выполнение
# - Завершение



# Task.
# На каком этапе тестировщики получают все необходимое для начала тестирования продукта?

# - реализация



# Task.
# Как думаете, когда можно прекратить тестирование?

# - Если ущерб от незакрытого бага не превышает затрат на его исправление, то исправлять баг не надо
# - Если суммарный ущерб от всех известных незакрытых багов не превышает выгоды от внедрения существующей версии
# системы, то её надо внедрять (пусть даже и с известными незакрытыми багами)
# - Если ущерб от потенциального бага не превышает затрат на его поиск и исправление, то искать баг не надо



# ============================================================================



# =============================== 2.7 Пирамида тестирования =====================================


# --------------------------------------------------------
# Выделяют четыре уровня тестирования:
#
# - Модульное тестирование (Component/Unit testing);
# - Интеграционное тестирование (Integration testing);
# - Системное тестирование (System testing);
# - Приемочное тестирование (Acceptance testing).

# Задачи любого уровня тестирования:
#
# - Снижение риска;
# - Обнаружение дефектов;
# - Предотвращение перехода дефектов на более высокие уровни.



# -------------------------------------------------------------
# Модульное тестирование
# Для обозначения модульного тестирования используется множество синонимичных названий: модульное, юнит или
# компонентное.

# Модульное тестирование проводится, вызывая код,  и позволяет проверить, что отдельные части общего кода работают
# согласно требованиям документации.

# Модульное тестирование, как правило, проводится разработчиками. В качестве примера самого модуля может выступать
# любой отдельный компонент приложения, например, одна веб-страница, объект, функция или класс (страница авторизации,
# поиск товара в интернет магазине, перемещение товара в корзину).

# Например: разработано всего две страницы приложения: страница регистрации и страница авторизации. На этапе
# модульного тестирования нужно убедиться, что каждая страница в отдельности работает правильно, то есть на странице
# регистрации можно зарегистрировать нового пользователя, а на странице авторизации можно авторизоваться уже
# зарегистрированному пользователю.

# Т.е. сначала каждая страница проверяется по отдельности, а потом уже переходим к более высокому уровню
# тестирования - тестирование взаимодействия этих страниц друг с другом.

# Найденные дефекты, при модульном тестировании чаще всего исправляются самим разработчиком, без занесения в
# баг-трекинговую систему (место хранения отчетов о найденных багах).


# Типичные дефекты модульного тестирования:
#
# - Неправильное поведение модуля (несоответствующее документации и требованиям);
# - Неправильный код.



# ------------------------------------------------------------------------
# Интеграционное тестирование
# Это тестирование взаимодействия модулей системы или нескольких систем.
#
# Так как разные модули приложения могут разрабатываться разными программистами - необходимо проверить взаимодействие
# между ними.
#
# Один компонент (модуль) производит выходные данные, а другой компонент эти данные принимает на вход. Проверка
# правильности взаимодействия этих отдельных модулей или систем и называется интеграционным тестированием.
#
# В результате тестирования стоит ожидать, что все смежные системы и модули одной системы должны работать согласованно.
#
# Например, со страницы корзины при нажатии кнопки «Оплатить» происходит переход на страницу платежной системы и
# осуществляется оплата.
#
# Типичные тестовые объекты:
#
# - Подсистемы;
# - Базы данных;
# - Интерфейсы, с помощью которых взаимодействует система;
# - Микросервисы.

# Типичные дефекты:
#
# - Отсутствующие или неправильные данные;
# - Сбои связи между компонентами;
# - Нарушение обязательных правил безопасности.



# -----------------------------------------------------------
# Системное тестирование (System testing)
# Производится после окончания интеграционного. Сначала разработчики создают и тестируют модули, затем интегрируют и
# тестируют модули между собой. В результате получается некая завершенная система, базовая модель приложения.
#
# Цель системного тестирования: проверить все приложение целиком.
#
# На системном уровне тестирования проводится тестирование полного пути (end-to-end/E2E flow) использования продукта.
# Под путем использования понимается вся цепочка взаимодействия от запуска приложения до какого-то конечного результата.
#
# Пример сценария end-to-end для интернет магазина:
#
# - Незарегистрированный пользователь переходит на сайт интернет магазина;
# - Регистрируется на сайте;
# - Авторизуется на сайте;
# - Находит необходимый товар;
# - Добавляет его в корзину;
# - Статус заказа «Ожидает оплаты»;
# - Оплачивает заказ;
# - Деньги поступают на счет компании;
# - Статус заказа меняется на «Оплачен»;
# - После получения заказа пользователем статус заказа меняется на «Получен».

# Типичные дефекты:
#
# - Неожиданное или неверное поведение системы;
# - Система неспособна выполнять end-to-end задачи;
# - Система неспособна правильно работать в различных средах;
# - Система работает не в соответствии с пользовательским руководством.



# --------------------------------------------------------------------------
# Приемочное тестирование (Acceptance testing)
# Проверяет, выполнены ли все бизнес-требования перед выпуском приложения на рынок.
#
# На текущем уровне тестирования обязательно должны применяться реальные данные и реальное использование приложения.
# Такой подход делает приемочное тестирование очень важным этапом цикла выпуска приложения. Это окончательное
# тестирование, выполняемое после завершения модульного, интеграционного и системного тестирования
#
# Критерии приемки — это условия, которым должно удовлетворять приложение, чтобы быть принятым заказчиком.
#
# Приемочное тестирование включает следующие формы:
#
# Пользовательское приемочное тестирование (User acceptance testing)  —  производится пользователями конечного продукта;
# Операционные приемочные испытания (Operational acceptance testing) - как правило, проводят системные администраторы.
# Проверяются функции резервного копирования, установка/ удаление/ обновление системы, проверка безопасности и
# производительности приложения. Необходимо удостовериться, что приложение возможно обслуживать и сопровождать на
# требуемом уровне даже в экстремальных условиях;
# Контрактные и нормативные приемочные испытания (Contractual and regulatory acceptance testing )  —  проверка, что
# приложение соблюдает все нормативные требования, продукт не нарушает чью-то интеллектуальную собственность или не
# использует нелицензионный софт;
# Альфа и бета-тестирование (Alpha and beta testing ).
# Альфа тестирование  включает имитацию реального использования продукта штатными  или сторонними разработчиками, либо
# командой тестировщиков.
#
# Бета-тестирование  —  производится реальными пользователями, с целью получения от них обратной связи и выявления
# максимального числа ошибок для их последующего устранения перед окончательным выходом продукта на рынок (релизом).
#
# Например, в известной компании «WarGaming» есть несколько групп тестирования:
#
# Отдел тестирования WarGaming — сотрудники компании, занимающиеся львиной долей всего тестирования того, или иного
# продукта. Качество любимых танчиков зависит от них, в большей степени;
# Участники «Супертест» — группа опытных игроков, помогающая разработчикам со сбором статистики, которая оставляет
# комментарии и предложения, а главное — способная оценить изменения свежим, «незамыленным» взглядом и обнаружить
# неочевидные ошибки.
# Несложно догадаться, отдел тестирования проводят альфа -тестирование, а «Супертест» участвуют в бета-тестировании.



# ---------------------------------------------------------------
# Task.
# Отметьте четыре главных уровня тестирования:

# - Модульное
# - Интеграционное
# - Системное
# - Приемочное



# -----------------------------------------------------------------
# Task.
# Выберите все синонимы компонентного тестирования:

# - Юнит (Юнит-тестирование)
# - Модуль (Модульное тестирование)



# -------------------------------------------------------------------
# Task.
# В качестве одного модуля (компонента, юнита) могут выступать:

# - Маленькая независимая часть (компонент) приложения



# --------------------------------------------------------------------
# Task.
#   На чем нужно быть сосредоточенным, проводя Интеграционное тестирование (Integration Testing)?

# - На тестировании взаимодействия модулей



# ---------------------------------------------------------------------
# Task.
# Системное тестирование (System testing) проводится сразу после:

# - Интеграционного



# ---------------------------------------------------------------------


# =====================================================================


# ======================= 2.8 Методы тестирования =====================

# --------------------------------------------------------------------
# ISTQB - Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.
#
# White, black и grey box тестирование или «тестирование белого» (прозрачного, открытого, стеклянного), «черного или
# серого» (полупрозрачного) ящика — это методы тестирования, направленные на определение доступа к внутренней
# системе ПО.
#
# Проще говоря мы, как тестировщики, при проверке продукта можем или не можем иметь доступ к его коду. Рассмотрим
# далее каждый из методов
#
# ------------ Метод черного ящика (black box) -----------------

# Тестирование черного ящика ( отсутствие доступа к коду )  — также известное как тестирование, основанное на
# спецификации или тестирование поведения — техника, основанная на работе исключительно с внешними интерфейсами системы.
#
# Согласно ISTQB, тестирование черного ящика — это:
#
# тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента
# или системы;
# тест-дизайн, основанный на технике черного ящика — процедура написания или выбора тест-кейсов на основе анализа
# функциональной или нефункциональной спецификации компонента, или системы без знания ее внутреннего устройства.
# Преимущества:
#
# тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и противоречия в
# спецификации;
# тестировщику нет необходимости обладать дополнительными знаниями в программировании;
# можно начинать писать тест-кейсы, как только готова спецификация.
# Недостатки:
#
# тестируется только очень ограниченное количество путей выполнения программы;
# без четкой спецификации (а это, скорее, реальность на многих проектах) достаточно трудно составить эффективные
# тест-кейсы;
# некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне модульного
# тестирования.
# Пример: обычный калькулятор. У нас нет доступа к внутренней системе, но мы можем предположить как пользователь будет
# им пользоваться и на основе этого произвести тестирование функций: отображение цифр при нажатии на кнопки, работу
# операторов(сложение, вычитание и т.д.), удаление результата и т.д.



# -------------------------------------------------------
# --------------- Метод белого ящика (white box) ----------------------------

# Тестирование белого ящика ( полный доступ к коду / сам писал код ) — метод тестирования ПО, который предполагает, что
# внутренняя структура/устройство/реализация системы известны тестировщику.
#
# Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Так же мы знаем, каким
# должен быть результат этой обработки.
#
# В данном случае тестируемая программа для тестировщика — прозрачный ящик, содержимое которого он прекрасно видит.
#
# Как правило, таким видом тестирования на проектах занимаются сами программисты, ведь для использования этого метода
# тестировщик должен обладать достаточно высокой квалификацией.
#
# Согласно ISTQB, тестирование белого ящика — это:
#
# тестирование, основанное на анализе внутренней структуры компонента или системы;
# тест-дизайн, основанный на технике белого ящика — процедура написания или выбора тест-кейсов на основе анализа
# внутреннего устройства системы или компонента.
# Преимущества:
#
# тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского интерфейса;
# можно провести более тщательное тестирование с покрытием большого количества путей выполнения программы.
# Недостатки:
#
# для выполнения тестирования белого ящика необходимо большое количество специальных знаний;
# упор делается на код, без учета позиции конечного пользователя, вследствие чего могут пропускаться баги.
# Пример: двигатель автомобиля. Для водителя (особенно начинающего) двигатель автомобиля - черный ящик. Но, для
# механика нет. Он, словно программист, понимает логику работы компонентов двигателя и знает его слабые места.



# -----------------------------------------------------------
# --------------------- Метод серого ящика (grey box) -------------------------------

# Тестирование серого ящика ( частичный доступ к коду ) — метод тестирования ПО, который предполагает
# комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно лишь частично.
#
# Преимущества:
#
# Тестирование серого ящика включает в себя плюсы тестирования «черного» и «белого». Другими словами, тестировщик
# смотрит на объект тестирования с позиции «черного» ящика, но при этом проводит анализ на основе тех данных, что он
# знает о системе;
# Тестировщик может проектировать и использовать более сложные сценарии тестирования;
# Предоставляет разработчику достаточно времени для исправления дефектов.
# Недостатки:
#
# Возможность анализа кода и тестового покрытия ограничена, так как доступ к исходному коду ограничен.
# Тесты могут быть избыточными в том случае, когда разработчик также проверяет свой код Unit-тестами.
# Пример: разработчик, проверяющий программу, методом черного ящика ИЛИ тестировщик, ознакомившийся с архитектурой
# программы, проверяющий программу, методом черного ящика. Оба понимают логику работы программы, но проверяют ее, с
# точки зрения пользователя.
#
# P.S.
# ISTQB относит тестирование методами белого и черного ящика к методам проектирования тестов. Поэтому, ни о
# каком «среднем» или «промежуточном» методе в этом случае конечно и речи быть не может. Мы либо разрабатываем тесты,
# зная код, либо не зная его. То есть в классификации ISTQB такого вида тестирования не существует.



# ------------------------------------------------------------------
# Task.
# Соотнесите методы тестирования с их определениями:

# Метод черного ящика : Тестирование, основанное на спецификации или тестирование поведения — техника, основанная на
# работе исключительно с внешними интерфейсами системы.

# Метод белого ящика : Метод тестирования ПО, который предполагает, что внутренняя структура/устройство/реализация
# системы известны тестировщику.

# Метод серого ящика : Метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов. То есть,
# внутреннее устройство программы нам известно лишь частично.



# --------------------------------------------------
# Task.
# Какой метод не описан в ISTQB?

# - Метод серого ящика



# --------------------------------------------------
# Task.
# Из представленных утверждений выберите верное:

# - Тестирование методами черного ящика более близко к поведению пользователя, чем остальные.



# -----------------------------------------------


# =================================================


# ===================== 2.9 Подходы к тестированию ================================

# ----------------------------------------------------------
# Рассмотрим подходы к тестированию по степени формализации:
#
# Формальность —  это «иметь общепризнанную форму, структуру или набор правил».
#
# 1.  Тестирование на основе тест-кейсов (виды тестовой документации будут рассмотрены в 3 разделе
# курса) — формализованный подход, в котором тестирование производится на основе заранее подготовленных тест- кейсов
# и иной документации.
#
# Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых для проверки
# реализации функционала тестируемого программного обеспечения (ПО) или какого-то его свойства.
#
# Эта информация включает в себя четкое описание действий, которые нужно выполнить, шаг за шагом. После выполнения
# действий нужно сравнить ожидаемый результат работы приложения с тем, который получен.
#
# Это самый распространенный способ тестирования, который также позволяет достичь максимальной полноты исследования
# продукта за счет строгой систематизации процесса.
#
# 2.  Исследовательское тестирование (Exploratory testing) — это частично формализованный подход тестирования ПО, при
# котором тестовые наборы не создаются заранее, а тестировщик проверяет приложение «на лету».
#
# Тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, дорабатывается в процессе
# выполнения с целью более полного исследования приложения.
#
# Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, а не как на
# бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию ты сначала разрабатываешь
# тестовые случаи, а затем исполняешь их. Исследовательское тестирование — это одновременный процесс разработки и
# выполнения тестов.
#
# В качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться чек-листы.
#
# Также в результате исследовательского тестирования могут появиться новые тест- кейсы. То есть мы можем выполнять
# исследовательское тестирование и с целью написания новых тест-кейсов.
#
# 3.  Свободное (интуитивное) тестирование (Ad Hoc Testing или Monkey Testing) полностью неформализованный подход, в
# котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев.
#
# Тестировщик полностью опирается на свою интуицию для спонтанного выполнения с продуктом действий, которые, как он
# считает, могут обнаружить ошибку.
#
# В прямом смысле — «куда хочу, туда и кликаю, в порядке каком хочу».
#
# Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует придерживаться
# при выполнении тестирования. Таким образом, метод не структурирован, и, следовательно, дефекты, обнаруженные с
# помощью этого метода, может быть труднее воспроизвести, но и вместе с этим возможно найти «Хитрые баги».
#
# В свою очередь Интуитивное тестирование подразделяется на 2 вида:
#
# buddy testing (совместное тестирование) — когда 2 человека, как правило разработчик + тестировщик, работают
# параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять
# необходимые проверки, а программисту фиксить баги на ранних этапах.
#
# pair testing (парное тестирование) —  когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру,
# один может искать дефекты, а второй —  их документировать.
#
# Используя различные подходы к тестированию, можно выбирать один или комбинацию подходов, для более глубокого и
# обширного тестирования. Какой именно подход выбирать — зависит от конкретного проекта и целей поставленных перед
# тестировщиком.



# ------------------------------------------------------
# Task.
# Что такое Исследовательское тестирование?

# - Методика тестирования ПО, при которой тестовые наборы не создаются заранее, а тестировщик проверяет
# приложение "на ходу"



# --------------------------------------------------------
# Task.
# Дано требование для валидации поля для введения пароля: Длина поля не должна превышать 5 символов. Можно использовать
# любые буквы латинского алфавита и числа. Поле не может быть пустым. Выберите возможные варианты валидного пароля:

# - 58R44
# - 65
# - 98765



# ---------------------------------------------------------
# Task.
# Укажите вариант для обозначения текста ошибки при авторизации пользователя при неверно введенном логине и/или
# пароле, который считается самым безопасным с точки зрения недопущения раскрытия этих данных злоумышленнику:

# - Пароль или логин введены неверно



# -----------------------------------------------------------


# ===========================================================



# ======================= 2.10 Виды тестирования ===================================

# ---------------------------------------------------------
# Стоит начать с того, что по критерию запуска программы тестирование делится на два типа: Статическое и Динамическое.
# Статическое тестирование (Static Testing) — тип тестирования, при котором код программы не исполняется во время
# проведения тестов.
#
# Статическое тестирование включает тестирование спецификации и прочей документации, файлов, либо тестирование и анализ
# программного кода (code review) или скомпилированного кода без его запуска. Может производиться как вручную, так и с
# помощью специальных инструментальных средств, т.е .автоматизировано.
#
# Код-ревью (code review) может выполняться одним из участников команды разработчиков или тестировщиком. Как
# правило, на код-ревью проверяются качество кода, стандарты использования, решения реализации, оставляются
# комментарии. Это помогает предотвратить дефект на начальном этапе.
#
# Динамическое  тестирование (Dynamic Testing) — тестирование, при котором выполняется код программы и проверяется
# поведение приложения во время работы. Тут происходит взаимодействие с интерфейсом запущенной программы, ее формами,
# сервером, базой данных и т.д.
#
# Если проводятся тесты на работающем приложении — значит, это динамические тесты.
#
# По степени автоматизации тестирование делится на Ручное и Автоматизированное.
# Ручное тестирование - это вид тестирования, при котором тестировщики вручную выполняют тесты без использования
# инструментов автоматизации.
#
# Каждое приложение должно быть протестировано вручную, прежде чем тесты можно будет автоматизировать. Это делается
# для того, чтобы определить, нужно ли вообще внедрять автоматизацию. Для проведения ручного тестирования необязательно
# владеть навыками использования какого-либо инструмента. Один из основных принципов тестирования заключается в
# том, что 100% автоматизация невозможна. Поэтому ручное тестирование неизбежно во всех проектах.
#
# Автоматизированное тестирование - это вид тестирования, при котором тесты проверяются автоматически с помощью
# специальных инструментов. Например, Selenium или Appium.
#
# Как только тесты автоматизированы, человек практически не принимает участие в выполнении тестов. Поэтому
# автоматизированное тестирование является эффективным видом тестирования. Цель автоматизации - сократить количество
# тестов, которые необходимо выполнять вручную, чтобы сократить время на тестирование.
#
# По ожидаемому поведению тестирование разделяется на:
# Позитивное тестирование (Positive Testing) — тестирование с применением сценариев, которые соответствуют ожидаемому
# поведению приложения.
#
# Позитивные тестовые сценарии проверяют, что приложение работает соответственно требованиям, если пользователь
# предоставляет допустимые, валидные данные или выполняет предусмотренные действия.
#
# Пример позитивного сценария: для Авторизации в системе уже зарегистрированного пользователя необходимо ввести
# существующий логин, правильный пароль, нажать кнопку «Войти». Ожидаемый результат — произошел вход в систему.
#
# Негативное тестирование (Negative Testing) — тестирование с применением сценариев, которые соответствуют внештатному
# поведению приложения.
#
# Негативные тестовые сценарии проверяют, как приложение справляется с данными, которые выходят за границы,
# предусмотренные требованиями, или неожиданными действиями пользователя.
#
# Пример негативного сценария: для Авторизации в системе уже зарегистрированного пользователя ввести несуществующий
# логин, или неправильный пароль, нажать кнопку «Войти». Ожидаемый результат – появляется сообщение о неправильности
# введенных данных.



# --------------------------------------------------
# По хронологии тестирование разделяют на:
# Дымовое тестирование (Smoke Testing) - включает в себя минимальный набор тестов на самые очевидные ошибки. Дымовое
# тестирование проверяет работоспособность критически важных функциональных частей приложения.
#
# Например, регистрация нового пользователя, создание нового заказа, выставление счета клиенту, получение оплаты. Это
# базовый функционал, который регулярно контролируется Smoke-тестами.
#
# Санитарное тестирование (Sanity Testing) — проводится после незначительных изменений в функционале, коде или починке
# багов. Проверяет, что исправленный код или новый функционал работает, как и ожидалось.
#
# Как пример, программисты устранили дефект на странице создания нового заказа. В этом случае санитарные тесты должны
# проверить общее состояние приложения и нацелены на то, чтобы избежать потерь времени и усилий, чтобы быстрее
# определить возможные недостатки ПО и их критичность, а также стоит ли переходить в фазу более тщательного
# тестирования. Обычно выполняется вручную.
#
# Регрессионное тестирование (Regression Testing) — тестирование приложения, направленное на обнаружение ошибок в уже
# проверенных участках программ (или исходных кодах). Помогает убедиться, что недавние изменения не сломали работающую
# функциональность приложения. Регрессионные тесты должны проводиться при любых изменениях кода, потому полная
# автоматизация — лучшая практика в этом типе тестирования.
#
# В регрессию включаются тесты, которые покрывают тестирование безопасности, критических и важных функций. Включаются
# те области, которые часто меняются в ходе разработки, где высока вероятность ошибки.
#
# Повторное тестирование (Retesting) — проводится после устранения дефекта в части функционала с целью подтверждения
# исправления ошибки.  Перепроверяет и подтверждает то, что ранее неудачные тест-кейсы успешно проходятся после
# того, как эти дефекты были исправлены. При этом используются те же самые тест-кейсы, которые выявили дефект — с
# использованием тех же данных, на том же окружении, но с различным набором входных данных.
#
# Тестирование делится также на Функциональное тестирование и Нефункциональное тестирование.
# Функциональное тестирование (Functional Testing) включает в себя тесты, оценивающие функции приложения. Функции
# системы — это то, «что» должна делать система.
#
# С помощью этого вида приложение проверяется на способность выполнять свои функции. Сюда входят: модульное,
# интеграционное, системное и приемочное тестирование. Кроме того, регрессионное и дымовое тестирования тоже являются
# подвидами функционального. Исполняется функциональное тестирование на основании требований в виде спецификаций или
# пользовательских историй.
#
# Нефункциональное тестирование (Non-functional Testing) оценивает характеристики систем и программного обеспечения,
# такие как надежность, производительность, удобство использования, эффективность работы или его безопасность.
# Нефункциональное тестирование — это проверка того, «насколько хорошо» ведет себя система.



# --------------------------------------------------------
# Рассмотрим Нефункционального тестирование подробнее:
#
# - Тестирование пользовательского интерфейса (User interface testing) — проверка соответствия интерфейса ПО требованиям
# дизайна. Например, проверка наличия всех требуемых элементов на странице, их размеров и расположения, тестирование
# шрифтов, цветов, изображений.
#
# - Тестирование удобства пользования (Usability Testing) — определение удобства использования приложения. Проверяется
# эргономичность интерфейсов. Например, оформление и графические элементы с точки зрения удобства восприятия, удобство
# навигации. В этот вид входит Тестирование доступности.
#
# - Тестирование Доступности (Accessibility Testing) — проверка доступности приложения для пользователей с нарушением
# слуха, зрения и цветовосприятия, а также людей, у которых нет возможности использовать клавиатуру. Например,
# использование определенной цветовой гаммы, добавление субтитров на видео или озвучивание всей страницы.
#
# - Тестирование производительности (Performance Testing) — тестирование скорости работы приложения под определённой
# нагрузкой.
#
# - Нагрузочное тестирование (Load testing) — данный тип тестирования позволяет оценить поведение системы при нормальных
# условиях и возрастающей нагрузке, целью нагрузочного тестирования является также определение максимальной нагрузки,
# которую может выдержать система. Например, мы рассчитываем, что одновременно приложением будет пользоваться 500
# пользователей, и через специальные программы (например Jmeter) создаются условия, которые моделируют использование
# приложения одновременно чуть менее 500 пользователями.
#
# - Стресс-тестирование (Stress testing) — используется для определения устойчивости системы или модуля при пороговых
# значениях рабочей нагрузки или за ее пределом. К примеру моделируются условия одновременного использования 500 или
# немногим более пользователей.
#
# - Объемное тестирование (Volume testing) — тестирование позволяет оценить производительность системы при увеличении
# объемов данных как самого приложения, так и его базы данных. Когда те же 500 пользователей отправляют одновременно
# какой-то объем информации.
#
# - Тестирование надежности  (Reliability Testing) — проверка работоспособности приложения при длительном тестировании
# с ожидаемым уровнем нагрузки.
#
# - Тестирование безопасности (Security Testing) — оценка уязвимости приложения к различным атакам. Оценка безопасности
# пользовательских данных, на сколько просто неавторизованный пользователь может получить доступ к системе или данным.
#
# - Тестирование установки  (Installation Testing) — проверка успешной инсталляции, настройки, обновления и удаления.
#
# - Тестирование совместимости (Compatibility Testing) — проверка корректной работы приложения в определенном окружении,
# например, устройстве, операционной системе (кроссплатформенное тестирование) или браузере (кроссбраузерное
# тестирование).
#
# - Тестирование на отказ и восстановление (Recovery Testing) — проверка насколько хорошо приложение может оправиться от
# аварий и сбоев оборудования.
#
# - Тестирование локализации (Localization Testing, l10n) — тестирования локализованной версии приложения: проверка
# правильности перевода интерфейса пользователя, системных сообщений и ошибок, раздела "Помощь"/"Справка",
# документации, контроль формата даты и времени.
#
# - Тестирование интернационализации (Internationalization Testing, i18n) — Насколько продукт может адаптироваться для
# той или иной локали при выходе на другие рынки. Например, возможность поддержки вертикального текста Азиатских
# стран, чтение справа налево в арабских странах.
#
# В целом, можно сказать, что нет строгой системы распределения по видам и типам тестирования. Есть «скелет», а
# остальные виды могут мигрировать.



# ----------------------------------------------------------------
# Task.
# Что такое нефункциональное тестирование?

# - Проверка того, "насколько хорошо" ведет себя система



# ----------------------------------------------------------------
# Task.
# К какому типу тестирования относятся модульное, интеграционное, системное, приемочное?

# - Функциональное



# ----------------------------------------------------------------
# Task.
# Дайте определение тестированию пользовательского интерфейса

# - Проверка соответствия интерфейса ПО требованиям дизайна



# ----------------------------------------------------------------
# Task.
# Выберите опции, которые необходимо проверить в рамках тестирования доступности

# - Соответствует ли звуковое воспроизведение информации, указанной в приложении
# - Удобны ли для восприятия цвета, используемые в приложении



# -----------------------------------------------------------------
# Task.
# Что такое стресс-тестирование?

# - Определение устойчивости системы или модуля при пороговых значениях рабочей нагрузки или за ее пределом



# -----------------------------------------------------------------
# Task.
# Какой вид тестирования отвечает за проверку работы базового/критичного функционала?

# - Дымовое



# ------------------------------------------------------------------
# Task.
# Что такое статическое тестирование?

# - Тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться



# ------------------------------------------------------------------
# Task.
# Выберите действия, которые относятся к статическому тестированию

# - Инспекция проектной документации
# - Анализ программного кода



# --------------------------------------------------------------------
# Task.
# На какие виды подразделяется тестирование по критерию запуска программы?

# - Статическое
# - Динамическое



# --------------------------------------------------------------------



# ====================================================================


# ======================================================================================================================
# 3. Планета артефактов
# ======================================================================================================================


# ================== 3.2 Спецификация и альтернативные источники ожидаемого результата ====================

# ----------------------------------------------------------------------------------------------------------------------
# Как мы выяснили, основная задача тестирования - это проверка ПО на соответствие между реальным поведением программы и
# её ожидаемым поведением на конечном наборе тестов, выбранных определенным образом. Ожидаемое поведение описывается в
# спецификации - это документ, описывающий реализацию программы в виде требований. Спецификация должна соответствовать
# следующим критериям:
#
# - Корректность — точное описание.
#
# - Проверяемость — описание требований таким образом, чтобы можно было однозначно понять, выполнено все в соответствии
# с требованиями или нет.
#
# - Полнота — в требовании должна содержаться вся необходимая информация для реализации.
#
# - Недвусмысленность — требование должно однозначно описываться.
#
# - Непротиворечивость — требования не должны противоречить другим требованиям и документам.
#
# - Приоритетность — у каждого требования должен быть приоритет, что позволит грамотно управлять ресурсами на проекте.
#
# - Атомарность — требование нельзя декомпозировать на отдельные части без потери деталей.
#
# - Модифицируемость — каждое требование можно изменить без потери цели требования.
#
# - Прослеживаемость — требование должно иметь уникальный идентификатор, по которому на него можно сослаться.


# Бывают ситуации, когда спецификация отсутствует. Помимо спецификации, есть и другие источники ожидаемого результата.
# Рассмотрим основные:
#
# 1) Общие требования к ПО на рынке:
#
# - Функциональная пригодность - программа должна решать заявленные задачи пользователя.
# - Надежность - программа должна работать стабильно, так как любой сбой потенциально приносит убытки.
# - Защищенность - программа должна сохранять пользовательские данные в безопасности.
# - Удобство использования - программа должна быть приятна и эффективна.

# 2) Гайдлайн - это руководство по использованию фирменного стиля, которое содержит инструкцию о том, как работать с
# элементами дизайна. Например, у iOS и Android есть свои гайдлайны.
#
# 3) Здравый смысл. Бывают баги и в самой спецификации, связанные с нерациональным использованием или реализацией
# определенной функциональности. В случае расхождения предполагаемой реализации функциональности со здравым
# смыслом, необходимо предложить улучшения продукта.
#
# 4) Конкуренты. Исследование конкурентов — постоянный процесс. Суть конкурентного анализа — всегда знать, куда движется
# рынок, что делают конкуренты, как меняются интересы аудитории. Результаты анализа нужно обновлять регулярно, раз в
# квартал или в год.



# -------------------------------------------------------------
# Пример спецификации

# https://disk.yandex.ru/i/rRvnCIMPdag-jw



# --------------------------------------------------------------



# ==============================================================



# ======================= 3.3 Тест-кейс =============================

# -------------------------------------------------------------------
# Тестовая документация — один из важнейших атрибутов в работе тестировщика. Мы расскажем вам, зачем она нужна и чем
# может быть полезна.


# Для чего нужна тестовая документация?

# В процессе тестирования любого продукта создается документация, которая помогает организовать работу отдела
# тестирования и держать всех членов команды в курсе дела. Такая документация создается до начала или в процессе
# тестирования. В хорошо оформленной документации любой член команды может найти всю необходимую информацию.


# Какая бывает документация?

# Наиболее распространенные документы, которые должен знать и уметь писать тестировщик уровня «джуниор» это:
#
# - тест-кейс;
# - чек-лист;
# - баг-репорт;
# - отчет о тестировании.



# ----------------------------------------------------------------------
# Что такое тест-кейс?
# Тест-кейс — это документ с описанными четкими действиями, которые нужно выполнить, чтобы проверить какую-либо функцию
# продукта. Эти действия направлены на проверку того, что функция работает должным образом и соответствует стандартам,
# и требованиям клиента.
#
# Простыми словами тест-кейс — это проверка получения ожидаемого результата. Тест-кейс «Проверить ввод отрицательных
# чисел в поле "Возраст"» означает, что нужно попробовать ввести отрицательные числа в указанное поле и в ответ,
# например, получить сообщение, что такие данные вводить недопустимо.
#
# Тест-кейсы, проверяющие одну функциональность, могут быть объединены в тест-сьюты (тест-наборы).
#
# Из чего состоит тест-кейс?
# Тест-кейс имеет определенный набор атрибутов. Некоторыми тестировщик пользуется регулярно, а какой-то частью он может
# не воспользоваться ни одного раза за всю свою карьеру. Все зависит от тестируемого продукта.
#
# 1. ID — обязательный атрибут. Это номер тест-кейса.
#
# Его используют для организации и навигации по всем тест-кейсам.
#
# Может создаваться как автоматически системой управления тестированием, в которой создается и будет
# храниться тест-кейс, так и вручную, если не используется такая система.
#
# Номер может быть представлен, например, в числовом виде: так - «345», или так - «1-45». Но может быть представлен в
# смешанном - «П-45», где буква обозначает какой-то функционал в продукте.
#
# Главное, чтобы эти номера были уникальные.
#
# 2. Заголовок (название) — обязательный атрибут.
#
# В заголовке отражается суть тест-кейса, то есть описывается что будет проверяться.
#
# Заголовок должен быть понятным, но и не сильно длинным.
#
# 3. Предусловия — необязательный атрибут.
#
# Здесь указываются действия, которые необходимо выполнить перед выполнением основных действий тест-кейса. Эти действия
# не имеют прямого отношения к проверке.
#
# Например, найти книгу на сайте может только зарегистрированный пользователь. Для того, чтобы выполнить тест-кейс
# проверки поиска, пользователь должен предварительно авторизоваться. То есть в предусловии необходимо указать, что
# пользователь должен быть зарегистрирован и  авторизован.
#
# Также здесь можно указать тестовые данные для авторизации, если эти данные не вынесены в отдельный документ.
#
# 4. Шаги — обязательный атрибут.
#
# В этом блоке описывается последовательность действий, которые необходимы для проверки.
#
# Последовательность нумеруется начиная с 1. Если шаг всего один, его принято не нумеровать.
#
# Действия должны быть описаны понятно.
#
# Должны использоваться безличные глаголы. Правильно: перейти, открыть, нажать. Неправильно: перейди, откройте, нажми.
#
# 5. Постусловия — необязательный атрибут.
#
# Аналогично блоку «Предусловия» в этом атрибуте указываются действия, не связанные с основной проверкой тест-кейса, но
# необходимые для возврата системы в исходное состояние.
#
# 6. Ожидаемый результат — обязательный атрибут.
#
# Здесь описывается результат, который ожидается получить в результате успешно выполненных действий из блока «Шаги».
#
# Ожидаемый результат может быть общим для всего тест-кейса.
#
# Но может быть и несколько, на каждый выполняемый шаг из блока «Шаги».
#
# 7. Требования к среде — необязательный атрибут.
#
# Тут можно указать специальное оборудование, программное обеспечение и т.д., которое будет необходимо для прохождения
# данного тест-кейса.
#
# 8. История редактирования — необязательный атрибут.
#
# Краткий журнал, в котором будет указываться кто, когда и почему внес изменения в тест-кейс.



# ----------------------------------------------------------------
# Примеры тест-кейсов.
# Давайте вместе с вами рассмотрим сайт, на котором публикуются рецепты приготовления блюд resept_test_site.ru (сайт
# выдуман).
#
# На данном сайте есть фильтр по дате публикации рецепта.


# Напишем проверки выборки рецептов за указанный период.


# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период (дата начала меньше даты окончания)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке «Фильтр» указать дату окончания периода, которая больше даты начала;
# 4) Нажать кнопку «Выбрать».

# Ожидаемый результат:
#
# На странице отображаются только рецепты, у которых дата публикации входит в указанный период.
#
#
#
# ID: Ф-2
#
# Заголовок: Проверить выбор рецептов за указанный период (даты равны)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке «Фильтр» указать дату окончания периода равную дате начала;
# 4) Нажать кнопку «Выбрать».

# Ожидаемый результат:
#
# На странице отображаются только рецепты, которые были опубликованы в указанный день.
#
#
#
# ID: Ф-3
#
# Заголовок: Проверить выбор рецептов за указанный период (дата начала больше даты окончания)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке Фильтр» указать дату окончания периода, которая меньше даты начала;
# 4) Нажать кнопку «Выбрать».

# Ожидаемый результат:
#
# На странице отображается сообщение о некорректности ввода дат.



# ---------------------------------------------------------------------
# «Ожидаемый результат» в тест-кейсе — один или много?
# В тест-кейсах может быть один или много ожидаемых результатов. Сколько их указать, решает сам автор. Главное, чтобы это было правильно и понятно оформлено.
#
# Для примера, перепишем тест-кейс Ф-1 с несколькими ожидаемыми результатами.
#
#
#
# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период (дата начала меньше даты окончания)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# в прошлом относительно указанного периода;
# в текущем периоде;
# в будущем относительно указанного периода.
# №
#
# Шаги:
#
# Ожидаемый результат:
#
# 1
#
# Открыть главную страницу сайта.
#
# Главная страница сайта открыта.
#
# 2
#
# В блоке «Фильтр» указать дату начала периода.
#
# В поле отображается введенная дата.
#
# 3
#
# В блоке «Фильтр» указать дату окончания периода, которая больше даты начала.
#
# В поле отображается введенная дата.
#
# 4
#
# Нажать кнопку «Выбрать».
#
# На странице отображаются только рецепты, у которых дата публикации входит в указанный период.
#
# Если переписать наши тест-кейсы в таком виде и если вдруг что-то измениться в каком-либо результате, то придется исправлять данные во всех остальных тест-кейсах. Очевидно, что это займет много времени.
#
# Один из недостатков тест-кейсов — это много похожих тест-кейсов. Если присмотреться к приведенным примерам тест-кейсов Ф-1, Ф-2, Ф-3, то все действия в блоке «Шаги» скопированы и исправлены только даты.
#
# В таких случаях есть смысл переписать эти 3 тест-кейса в один, но с разными входными данными и несколькими ожидаемыми
# результатами.
#
#
#
# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:                                                                    Ожидаемый результат:
#
# 1) Открыть главную страницу сайта;                                       Главная страница сайта открыта.

# 2) В блоке «Фильтр» указать дату начала периода;                         В поле отображается введенная дата.

# 3) В блоке «Фильтр» указать дату окончания периода из таблицы данных;    В поле отображается введенная дата.

# 4) Нажать кнопку «Выбрать».                                              На странице отображаются только рецепты, у
#                                                                          которых дата публикации входит в указанный
#                                                                          период.


# Если переписать наши тест-кейсы в таком виде и если вдруг что-то измениться в каком-либо результате, то придется
# исправлять данные во всех остальных тест-кейсах. Очевидно, что это займет много времени.
#
# Один из недостатков тест-кейсов — это много похожих тест-кейсов. Если присмотреться к приведенным примерам
# тест-кейсов Ф-1, Ф-2, Ф-3, то все действия в блоке «Шаги» скопированы и исправлены только даты.
#
# В таких случаях есть смысл переписать эти 3 тест-кейса в один, но с разными входными данными и несколькими
# ожидаемыми результатами.


# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке «Фильтр» указать дату окончания периода из таблицы данных;
# 4) Нажать кнопку «Выбрать».


# Входные данные:                                                          Ожидаемый результат:
#
# 1) В блоке «Фильтр» указать дату окончания периода, которая больше       На странице отображаются только рецепты, у
# даты начала.                                                             которых дата публикации входит в указанный
#                                                                          период.

# 2) В блоке «Фильтр» указать дату окончания периода равную дате начала.   На странице отображаются только рецепты,
#                                                                          которые были опубликованы в указанный день.

# 3) В блоке Фильтр» указать дату окончания периода, которая меньше даты   На странице отображается сообщение об
# начала.                                                                  некорректности ввода дат.


# В таком виде избавляемся от большого количества копирования и трудностей поддержки уровня актуальности документации.
#
# ----------------- Инструменты для хранения тест-кейсов --------------------

# Для хранения тест-кейсов существуют системы управления тестирования (TMS - Test Management System).
#
# На сегодняшний день их довольно много. Есть как полностью бесплатные, так и платные, и каждая система имеет свои
# недостатки и преимущества.
#
# Вот несколько известных и популярных:
#
# - Azure DevOps
# - Test IT
# - TestRail
# - Qase
# - Allure TestOps
# - Zephyr Scale
# - Zephyr Squad
#
#
# Для первого знакомства с подобными системами можно попробовать создать тест-кейсы в бесплатном Testlink. Но, также
# можно организовать хранение тест-кейсов и в Гугл Таблице. Это будет менее удобно, но совсем бесплатно.
#
# Преимущества и недостатки тест-кейсов
# На тему преимущества и недостатков тест-кейсов на проекте ведется множество споров, написана куча статей.
#
# Давайте посмотрим, что же может быть записано в преимущество,  что в недостаток.


# Преимущества:
#
# - уже написанные тест-кейсы можно использовать для ознакомления новичков  с проектом, независимо от его опыта;
# - всегда можно посмотреть, как и что делать, если вдруг забыли (все мы живые люди, а не роботы);
# - Иногда приходится тестировать то, с чем не очень хорошо знакомы;
# - Существование тест-кейса (или кейсов) позволяет быстро вникнуть в то, что важно проверить. Так же при нехватке
# тестировщиков на проекте, можно привлечь коллегу из соседнего проекта в помощь.


# Недостатки:
#
# - много копирования одинаковой информации из тест-кейса в тест-кейс. Если пишутся тест-кейсы, например, на одно поле,
# то многие шаги будут повторяться;
# - сложность поддержки большого количества тест-кейсов. Например, изменение названия одной кнопки. Нужно будет найти
# все тест-кейсы где, есть старое название, и заменить его на новое. А если таких кнопок не одна и еще парочка полей?
# - неактуальные тест-кейсы. Если нет времени и  часть изменений не было внесено в тест-кейсы, то сотрудник, который уже
# давно на проекте, пройдет их как нужно. А вот для новичка это будет затруднительно.


# Для того чтобы документация помогала в работе, ее нужно поддерживать в актуальном состоянии и постоянно дорабатывать.
# Но, к сожалению, это отнимает много времени и сил. Релиз никто не отложит, потому что вы еще не поправили все нужные
# тест-кейсы или не дописали новые.
#
# -------------- Когда нужно использовать тест-кейсы? ------------------

# Но при наличии довольно существенных недостатков тест-кейсы в некоторых случаях буквально необходимы.
#
# Если тестируемый продукт жизненно важен и ошибки в нем могут привести к непоправимым последствиям. Например,
# медицина, ПО для атомных станций и т.д.:
# Если продукт очень сложный. Для того чтобы не вспоминать каждый раз как строится отчет, лучше зафиксировать это в
# тест-кейсе;
# Если у вас в команде идет постоянная ротация, то удобнее знакомить с продуктом с помощью прохождения тест-кейсов.

# --------------- P.S. ------------------

# 1. Тест-кейсы должны быть понятными и конкретными.
#
# Для проверки этого можно дать пройти их любому члену команды, который не знаком с продуктом.
#
# Этими тест-кейсами в дальнейшем придется пользоваться вашим коллегам. Если тест-кейс непонятен, то это плохой
# тест-кейс, а значит его надо переписывать.
#
# 2. Девиз для написания заголовка - «Кратко, но ёмко!». Из заголовка тест-кейса должно быть понятно какую проверку
# необходимо провести, не читая последовательность в блоке «Шаги». Можно использовать сайт http://bugred.ru/.
#
# 3. Девиз для тест-кейсов «Не доверяй, но проверяй». Для проверки необходимо подготовить тестовые данные, по которым
# можно точно сказать работает ли проверяемая функция или нет.



# ------------ Task. ----------------------
# Выбрать верное определение тест-кейса:

# - это документ, содержащий последовательность действий направленную на проверку какого-либо функционала, описывающий
# как прийти к ожидаемому результату.



# ----------- Task. ----------------------
# Правильно расположить атрибуты тест-кейса:

# - ID
# - Заголовок
# - Предусловие
# - Шаги
# - Постусловия
# - Ожидаемый результат
# - Требования к среде
# - История редактирования



# ------------------ Task. ---------------------------
# Выбрать верные утверждения для “хорошего тест-кейса”

# Тест-кейс должен быть понятным и конкретным



# ---------------- Task. ----------------------------
# Выбрать обязательные атрибуты тест-кейса:

# - Заголовок
# - Ожидаемый результат
# - Шаги
# - ID



# ----------------------------------------------------


# =====================================================



# ======================= 3.4 Чек-лист ==========================

# ---------------------------------------------------------------

# -------------- Что такое чек-лист, и чем он отличается от тест-кейса? ----------------

# Чек-лист — это список с кратким описанием того, что нужно проверить.
#
# Благодаря такому списку, процесс тестирования будет проходить более организованно, что уменьшает шансы что-то забыть.
#
# Чек-лист для тестирования — это как список продуктов, которые надо купить, написанный перед походом в магазин.
#
# В отличии от тест-кейсов, чек-листы используются для простых систем (например, интернет-магазин), где нет сложных
# процессов, которые необходимо документировать. Проще написать список проверок для нужных функций, чем писать
# полноценные тест-кейсы, а потом еще и поддерживать их в актуальном состоянии.
#
# Чек-листы могут быть разного уровня детализации. Уровень детализации будет зависеть от сложности продукта, от знаний
# сотрудников тестируемого продукта и требований к отчетности о его статусе.
#
# Чек-листы можно составлять как «верхнеуровневые» проверки, которые помогут выявить в каком блоке/разделе/направлении
# нужно будет двигаться для создания тест кейсов.
#
# ------------- Из чего состоит чек-лист? ----------------

# У чек-листа намного меньше атрибутов, чем у тест-кейса.
#
# 1) ID — обязательный атрибут. Номер чек-листа. Используется для организации и навигации по всем чек-листам. Номер
# чек-листа может отражать степень детализации и может быть представлен в таком виде «3.2.6»;
# 2) Описание проверки — обязательный атрибут. Краткое описание того, что должно быть проверено. Здесь так же
# применяется принцип краткости и информативности;
# 3) Пример — необязательный атрибут. Если используются специфические данные для проверки функционала, здесь можно
# указать их;
# 4) Окружение — необязательный атрибут. Указывается вся необходимая информация о сборке, устройствах, платформах
# и т.д., на которых должна проходить проверка;
# 5) Результат — обязательный атрибут. Здесь описывается результат, который ожидается получить в ходе успешной проверки.



# ----------------------------------------------------------------

# ------------------- Пример чек-листа ---------------------

# Разберем сайт с рецептами resept_test_site.ru. На нем есть фильтр по дате публикации рецепта.
#
# При тестировании новой версии нам важно не забыть проверить работу фильтра.
#
# 1 Проверить работу фильтра по дате публикации.              Выбираются статьи соответствующие указанным датам.
#
# Но данный фильтр у нас встречается в разных разделах сайта. Немного детализируем нашу проверку.

# 1. Проверить работу фильтра по дате публикации.

# 1.1. На «Главной» странице
# 1.2. В разделе «Авторы»                          Выбираются статьи соответствующие указанным датам.
# 1.3. В разделе «Рецепты»


# С такой детализаций уже будет трудно забыть проверить в других разделах. Этот чек-лист можно детализировать глубже,
# если есть необходимость.
#
# ------------------- Как составить хороший чек-лист? --------------------

# Для составления хорошего чек-листа есть несколько рекомендаций.
#
# 1. Один пункт — одно действие. Один пункт чек-листа должен представлять собой одну минимальную полную операцию.
#
# Чек-лист в таком виде «Проверить работу фильтра на «Главной» странице, в разделе «Авторы» и «Рецепты» лучше не
# использовать;
#
# 2. В названиях пунктов чек-листа используйте принципы, общие для всех членов команды. Например, использовать глаголы
# в инфинитиве «проверить», «отправить», или существительные «проверка», «добавление»;
#
# 3. Понятные и конкретные формулировки. При прохождении чек-листа тестировщик не должен вспоминать, что имелось в
# виду. Если такая ситуация повторяется неоднократно, то стоит подумать про изменение формулировки описания проверки;
#
# 4. В зависимости от сложности функционала детализируйте чек-лист;
#
# 5. Объединяйте чек-листы в таблицы. В таблицах можно добавить столбцы с дополнительными данными (платформа, версия
# продукта, сотрудник и т.п.) и статус проверки.



# ------------- Инструменты для хранения чек-листов -----------------------

# Для хранения и прохождения чек-листов есть инструменты, как и для тест-кейсов.
#
# Список нескольких популярных:
#
# - TestRail, TestLink — и прочие системы управления тестированием;
# - Jira;
# - Trello;
# - Гугл Таблицы — при правильной настройке, можно сделать довольно удобную систему прохождения чек-листов и сбора
# информации для отчетности. Главное преимущество — это бесплатно;
# - Sitechco — бесплатная программа, в которой можно попрактиковаться в создании и прохождении чек-листов.

# ----------------------- Преимущества и недостатки чек-листов -------------------------------

# Как и у тест-кейсов, так и у чек-листов есть свои плюсы и минусы.


# Преимущества:
#
# - проверка в одну строку легко читается и не долго пишется;
# - проходить чек-листы быстрее: в тест-кейсе нужно отмечать прохождение каждого шага, а в чек-листе достаточно одной
# строки;
# - статус прохождения чек-листа это источник результатов для отчета: можно быстро посчитать сколько проверок
# выполнено, и в каком они статусе, узнать количество открытых репортов;
# - легко можно поменять порядок проверок, если это необходимо;
# - так как одни и те же проверки разные люди могут проходить по-разному, то в некоторой степени можно избавиться
# от «эффекта пестицида».


# Недостатки:
#
# - каждый тестировщик выполняет проверки чек-листа по-своему;
# - недостаточность детализации;
# - для обучения новых сотрудников не подходит: проверки описывают то, что нужно сделать, без привязки к интерфейсу.


# Чек-листы хорошо использовать на начальном этапе тестирования. Накидать начальный список проверок и потом, при
# необходимости, детализировать займет не так много времени, как написание полноценных тест-кейсов.
#
# Также можно использовать смешанную документацию. Для простого функционала чек-листы, а для более сложного
# полноценные тест-кейсы.



# ------------------- Task. --------------------------
# Верно ли, что чек-лист — это список того, что должно быть проверено?

# - Да



# --------------------- Task. -----------------------------------
# Правильно расположить атрибуты чек-листа:

# - ID
# - Описание проверки
# - Пример
# - Окружение
# - Результат



# ------------------------------- Task ---------------------------------------------
# Выбрать обязательные атрибуты чек-листа:

# - ID
# - Описание проверки
# - Результат



# ------------------------------------------------------------------------


# ==================================================================


# ============================ 3.5 Баг-репорт ==============================

# --------------------------------------------------------------------------
# В процессе тестирования продукта могут обнаруживаться ошибки, о которых должны узнать разработчики, чтобы их
# исправить. Но информацию о существующей ошибке надо донести в удобном и понятном виде. Для этого используют
# баг-репорт. Это еще один документ, который составляется тестировщиком.
#
# ---------------------- Что такое баг-репорт? ----------------------
# Баг-репорт - это документ, в котором описана последовательность шагов, приводящая к неверному поведению функционала,
# а также описан ожидаемый результат.
#
# Вернемся к нашему сайту с рецептами. На сайте есть фильтр, с помощью которого мы можем выбрать опубликованные рецепты
# за определенный промежуток времени.
#
# Мы хотим увидеть все рецепты за 2021 год.
#
# Вводим данные и нажимаем кнопку “Выбрать”.


# И видим результат выборки: пусто.
#
# Очевидно, что фильтр работает неверно. Мы ожидали получить список рецептов за 2021 год, но не получили нужного нам
# результата.
#
# Для того, чтобы сообщить об этой ошибке, в работе фильтра необходимо написать баг-репорт. Так, в нем нужно описать
# действия, которые привели к ошибке, указать, в чем состоит ошибка и что ожидалось.
#
# ----------------- Из чего состоит баг-репорт? ------------------------

# У баг-репорта, как и у всех документов рассмотренных ранее, есть атрибуты. Часть из них обязательна для заполнения,
# часть - не обязательна.
#
# 1) ID — обязательный атрибут. Это номер баг-репорта. В большинстве случаев, автоматически создается баг-трекинговой
# системой.
# 2) Заголовок — обязательный атрибут. С помощью одного предложения описывается суть бага. Для написания заголовка
# используют вопросы “Что? Где? Когда?”. Эти вопросы помогают написать понятный для всех членов команды заголовок, не
# слишком длинный, но отражающий суть бага.
# 3) Шаги  — обязательный атрибут. Здесь описывается последовательность действий, которые необходимо выполнить для
# воспроизведения бага. На этом этапе указывается минимум необходимых действий.
# 4) Фактический результат — обязательный атрибут. Описывается полученный результат после выполнения описанных шагов.
# 5) Ожидаемый результат — обязательный атрибут. Описывается результат, который мы ожидали увидеть после выполнения
# указанных шагов.
# 6) Серьезность — обязательный атрибут. Указывается уровень серьезности бага и насколько это критично влияет на общую
# функциональность тестируемого продукта.
# 7) Приоритет — необязательный атрибут. Указывается очередность исправления бага.
# 8) Скриншот или видео — обязательный атрибут. Видео или скриншот должны четко демонстрировать баг. Можно сделать
# выделение бага, сделать короткие поясняющие надписи, если это необходимо.
# 9) Тип бага — необязательный атрибут. Исходя из этой информации, можно составить отчет и провести анализ о слабых
# местах в продукте, чтобы потом их исправить.
# 10) Статус — необязательный атрибут. Указывается статус бага в его “жизненном цикле”.
# 11) Требование — необязательный атрибут. Указывается ссылка на требование, в котором прописано ожидаемое поведение.
# При наличии такого документа, можно избежать споров (если возникнут) баг или фича.
# 12) Дополнительная информация — необязательный атрибут. Дополнительной информацией может быть файл с тестовыми
# данными,данные для авторизации (тестовый логин и пароль) и т.д.
# 13) Окружение — необязательный атрибут. Если нужно, то можно указать версию браузера, операционную систему и т.д.
# 14) Автор — необязательный атрибут. Указывается тестировщик, который обнаружил и создал баг-репорт. У разработчиков
# могут возникнуть дополнительные вопросы и так будет понятно, к кому надо обратиться.
# 15) Исполнитель — необязательный атрибут. Указывается человек, который продолжит работу над исправлением бага.
# 16) Версия обнаружения — необязательный атрибут. Указывается версия продукта, в которой был обнаружен баг.
# 17) Комментарии — необязательный атрибут. В комментариях происходит обсуждение бага после создания баг-репорта.


# ---------------- Серьезность и приоритет -------------------------

# Прежде чем оформить наш баг-репорт на найденную ошибку на сайте, рассмотрим подробнее несколько моментов:
#
# какие бывают степени “серьезности” и “приоритета”,
# что такое “жизненный цикл” бага и какие есть статусы.
# Для уровней серьезности бага нет единых стандартов. Количество и названия отличаются в разных компаниях. Рассмотрим
# один из используемых набором уровней.
#
# - Блокирующий (Blocker) —  этот уровень выставляется, когда из-за описанного бага продукт совсем не работает.
# Например, на нашем сайте с рецептами открывается главная страница и зависает, не реагирует на клики и другие действия.

# - Критический (Critical) — этот уровень указывается, когда описанный баг влияет на главный  функционал. Например, для
# нашего сайта критическим функционалом будет создание и публикация рецепта. Если у пользователей не будет возможности
# создавать и публиковать свои рецепты, то он может уйти на другой работающий сайт.

# - Серьезный (Major) — этот уровень выставляется, когда баг создает неудобства, но не влияет на критический функционал.
# Например, у вновь созданного и опубликованного рецепта не появляется плашка “Новый”.

# - Незначительный (Minor) — этот уровень указывается для бага, который не влияет на “логику” приложения. Чаще всего это
# баги, возникающие при верстке, локализации и т.д. Например, цвет шрифта всех кнопок должен быть темно-синий (согласно
# макету), а разработчики забыли про одну кнопку и сделали ее с зеленым шрифтом.

# - Тривиальный (Trivial) — баги этого уровня не влияют на работу и качество продукта. Такие баги не исправляют
# специально, а обычно делают правку в ходе реализации функционала, который находится рядом. Например, на нашем сайте в
# футере отображается прошедший год.

# Серьезность в баг-репорте выставляет тестировщик. А вот приоритет выставляется руководителем или менеджером проекта.
#
# Уровни приоритета также могут различаться в разных компаниях.
#
# - Высокий (High) —  баг с таким статусом, будет исправляться в первую очередь.
# - Средний (Medium) —  баг будет исправляться после всех багов с высоким статусом.
# - Низкий (Low) —  баг будет исправляться в последнюю очередь, когда все ошибки более высокого приоритета будут
# исправлены.



# ------------------------------ Жизненный цикл -----------------------------------
# “Жизненный цикл” бага —  это последовательность этапов, которые проходит баг-репорт с момента его создания до
# окончательного закрытия.
#
# Нагляднее этот цикл отображать в виде блок-схемы, на которой отображается статус, как можно к нему перейти и на что
# может быть изменен.
#
# В разных компаниях может быть разный жизненный цикл. Это связано с использованием разных систем баг-трекинга. В
# одних —  этапы цикла уже настроены и их нельзя изменить, а в других —  предоставляется возможность настройки “под
# себя”, если это необходимо.


#  Рассмотрим немного подробнее каждый этап.
#
# - Новый — баг найден и при создании баг-репорта в системе, этот статус устанавливается автоматически.
# - Отклонен — если баг был уже ранее внесен или не будет правиться по каким-либо причинам или не воспроизводится
# больше, то руководителем команды может быть выставлен данный статус. Далее можно или переоткрыть (с новыми
# доказательствами и доводами, что это баг), или закрыть.
# - Открыт — устанавливается после проверки руководителем и принятия решения об исправлении. Может быть переведен в
# статус Отсрочен, Исправлен или Отклонен.
# - Отсрочен — если нет необходимости исправлять данный баг в данной итерации. В последующих итерациях может быть
# переведен в Открыт или Закрыт.
# - Исправлен — статус выставляется после исправления бага разработчиком и перевода его на проверку тестировщику. Может
# быть Повторно открыт или Закрыт.
# - Повторно открыт — статус означает, что при проверке исправления, проблема все еще воспроизводится. Можно перевести
# в статус Исправлен, Отсрочен или Отклонен.
# - Закрыт - баг исправлен и не воспроизводится.



# ------------------- Пример баг-репорта ------------------------------
# № 1. Нет данных в результате выборки фильтра при указании данных за год
#
# Статус: Новый
#
# Окружение: Win 10, Google Chrome Версия 100.0.4896.75 (Официальная сборка), (64 бит)
#
# Серьезность: Серьезный (Major)
#
# Предусловие: в базе должны быть созданы рецепты до 2021 г, в 2021 г и после 2021 г.
#
# Шаги:
# 1) Открыть главную страницу: resept_test_site.ru.
# 2) В блоке “Фильтр” заполнить поля дат значениями: “01.01.2021”, “31.12.2021”.
# 3) Нажать кнопку “Выбрать”.
#
# Ожидаемый результат:
# Пользователь видит результат выборки - все рецепты созданные за 2021 г.
#
# Фактический результат:
# Пользователь видит пустой результат выборки - нет ни одного рецепта.
#
# Cкрин_ошибки.jpg


# В приведенном примере Ожидаемый результат написан первым, а затем Фактический результат. Но может быть и наоборот.
#
# Чаще всего пишут сначала Фактический результат, а потом Ожидаемый, т.к. наша задача описать проблему и такой порядок
# читается логичнее и проще для усвоения.
#
# Но когда на проекте добавляется очень много данных в блок Дополнительная информация, логично описать Ожидаемый
# результат, Фактический результат и к нему Дополнительная информация.
#
# Все! Наш баг описан и его можно передавать разработчикам. Но, на самом деле, есть еще один важный момент перед тем
# как передавать его разработчикам — локализовать проблему.


# ----------------------- Локализация --------------------------------

# В чем же будет состоять локализация нашего бага?
#
# - Хорошо было бы выяснить, проблема только с 2021 годом или с остальными тоже есть сложности?
# - А есть ли проблема с другими периодами (день, неделя, месяц и т.д.), то есть работает ли вообще фильтр по датам?
# - А если ввести только одну дату для фильтра?
# - Такой баг во всех заявленных для тестирования браузерах?
# - Фильтр так работает на всех страницах, где присутствует или это только на главной странице сайта?


# Это приблизительный список вопросов, ответы на которые помогут понять, где проблема:
#
# - это 2021 год проблемный;
# - возможно, фильтр не работает совсем;
# - визуально кнопки фильтра могут быть одинаковые на всех страницах сайта, но на главной может отличаться реализация и
# вот она как раз и сломалась.


# После локализации, возможно придется отредактировать баг-репорт или вообще переписать его.  Поэтому лучше найти
# границы проблемы до написания баг-репорта.


# ------------------------- Инструменты для управления дефектами ----------------------------
# Чаще всего можно услышать название для таких инструментов как “баг-трекинговая система”.
#
# Такие системы используются в процессе разработки продукта, для документации багов, а также предложений для
# улучшения. В этих системах удобно получать данные  для анализа о процессе исправления ошибок и выполненных улучшений.
#
# Список из наиболее известных:
#
# - Atlassian JIRA
# - Redmine
# - Mantis


# Для тренировки можно воспользоваться Гугл Таблицей.



# ----------------------------------------------------------------------------

# ------------------ Алгоритм написания --------------------------

# - Проверить, что баг воспроизводится 2-3 раза;
# - Локализовать проблему;
# - Проверить, что вы не создадите дубликат в системе управления дефектами;
# - Написать заголовок (должен отвечать на вопросы “что? где? когда?”);
# - Заполнить обязательные поля отчета;
# - Заполнить необходимые необязательные поля отчета;
# - Перечитать баг-репорт;
# - Пройти написанные шаги и проверить, что все понятно, ссылки корректны;
# - Сохранить отчет;
# - Назначить отчет либо на разработчика функционала, либо на руководителя.


# --------------------------- Частые ошибки начинающих тестировщиков -----------------------------
# - В заголовке не используется правило трех вопросов;
# - Присутствует лишняя информация в заголовке (окружения, учетные данные пользователей, версия и т.д.);
# - Нет шагов для воспроизведения бага;
# - Описано слишком много лишних шагов для воспроизведения;
# - Пропущено описание фактического и / или ожидаемого результата;
# - Нет обоснования почему это баг;
# - Отсутствует скриншот / видео бага или на нем нет фиксации бага.



# ---------------- Task. ----------------------
# В логотипе указано неправильное название компании. Какой уровень приоритета будет у этого бага?

# - High



# ------------------ Task. ---------------------------
# В логотипе указано неправильное название компании. Какой уровень серьезности будет у этого бага?

# - Trivial



# ------------------- Task. -----------------------------
# Выбрать обязательные атрибуты баг-репорта:

# - Серьезность
# - Скриншот или видео
# - ID
# - Шаги
# - Ожидаемый результат
# - Фактический результат
# - Заголовок



# -----------------------------------------------------------------------


# ========================================================================


# ========================== 3.6 Отчет по тестированию ==================================

# ---------------------------------------------------------------------------------------
# И вот, наконец, тест-кейсы или чек-листы написаны на новую функциональность, тестирование завершено, баг-репорты
# созданы в баг-трекинговых системах и переданы разработчикам. Теперь можно спокойно попить чай, но есть еще один
# документ, который пишут тестировщики по окончании процесса тестирования — это отчет о результатах тестирования. Этот
# документ помогает провести анализ результатов как промежуточного, так и финального тестирования.
#
# Не все компании практикуют написание отчета, не везде этот документ имеет обязательный характер. Но иметь хотя бы
# минимальное представление о том, что такое отчет о результатах, было бы полезно.


# ------------------- Что такое отчет о  результатах тестирования? -----------------------------

# Отчет о тестировании — это документ, который содержит описание процесса тестирования, общую информацию о том, что
# было протестировано за отчетный период, результаты тестирования и данные, которые необходимы для оценки текущего
# или финального состояния продукта.
#
# Представленная таким образом информация должна помочь заинтересованным лицам в проекте увидеть полную и объективную
# картину о качестве программного продукта.
#
# Отчет создается по расписанию, которое оговаривается в команде. Это может быть как календарная привязка (раз в
# неделю), так и привязка к окончанию тестирования билда или функциональности.


# ---------------- Содержание отчета о тестировании -------------------

# Отчет составляется по шаблону предоставленному заказчиком. Если же шаблона нет, а отчет нужен, то можно
# придерживаться следующего списка:
#
# 1) Информация о проекте — краткое описание содержания отчета. Например, название проекта, тестируемая версия и т.д.;
#
# 2) Команда тестировщиков — список людей, которые задействованы в тестировании. Если был один человек, то можно
# опустить этот пункт;
#
# 3) Описание процесса тестирования — какие использовались техники, методы и инструменты;
#
# 4) Краткое описание результатов — что было протестировано (версия, номер сборки); что тормозит процесс тестирования
# (критичные дефекты, недоработанная функциональность, пробелы в требованиях);
#
# 5) Расписание — временные сроки тестирования функционала;
#
# 6) Статистика по багам — баги, обнаруженные за отчетный период, степень их важности и срочности.
#
# 7) Список новых багов — список багов, впервые обнаруженных в данном отчетном периоде.
#
# 8) Список устраненных дефектов — список багов, исправленных разработчиками в отчетном периоде.
#
# 9) Рекомендации — выводы по результатам тестирования и рекомендации по повышению его эффективности в будущем.
#
# 10) Приложения — графики, таблицы, диаграммы, демонстрирующие числовые характеристики процесса тестирования.



# --------------------------------------------------------------------------------
# Пример отчета
# https://disk.yandex.ru/i/Rl4R2AyeGccvlg



# =================================================================================