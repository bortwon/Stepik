# ========================== Начало =========================

# Программная ошибка (жарг. баг) — означает ошибку в программе или в системе, из-за которой программа выдает
# неожиданное поведение и, как следствие, результат. Большинство программных ошибок возникают из-за ошибок команды
# разработки.



# Тестирование программного обеспечения — процесс исследования, испытания программного продукта, имеющий своей целью
# проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе
# тестов, выбранных определённым образом. Тестировщик, в свою очередь, моделирует различные ситуации (тесты), которые
# могут возникнуть в процессе использования программы, чтобы разработчики смогли исправить обнаруженные баги.



# Мы воспользуемся популярной техникой тест-дизайна, позволяющей быстро и качественно проверить что-либо:
#
# - Техника выделения классов эквивалентности и граничных значений позволяет уйти от дублирующих проверок.
# Следовательно, мы сократим количество однотипных тестов.
#
# - Классы эквивалентности — это разбиение функционала на наборы данных, которые ведут себя в пределах этих наборов
# одинаково. Например, дети, взрослые и пенсионеры - это все классы эквивалентности.
#
# - Анализ граничных значений — это метод, который улучшает разделение классов эквивалентности. В нашем случае, самые
# близкие значения — это 17 и 66.



# Чек-лист– это список, содержащий ряд необходимых проверок во время тестирования программного продукта. Отмечая пункты
# списка, команда или один тестировщик могут узнать о текущем состоянии выполненной работы и о качестве продукта.

# ===================================================================



# ========================== Теория ==============================


# ------------------------ 2.2. Тестирование и качество ------------------------

# Качество программного обеспечения — способность программного продукта при заданных условиях удовлетворять
# установленным или предполагаемым потребностям.



# Quality assurance, Quality control и Testing. Who is who?

# 1. Testing (тестирование) — самый первый уровень. Это проверка программного продукта на соответствие требованиям
# этого продукта.

# То есть ожидаемый результат и фактический результат совпадают, и это тот минимум, без которого нельзя выпускать
# продукт. Возьмем для примера тестирование в интернет—магазине кнопки «Купить».
# В процесс тестирования будет входить проверка функционала и сверка с макетом. Кнопка нажимается, открывается нужное
# окно, кнопка находится в правом нижнем углу, окрашена в зеленый цвет и т.д.


# 2. QC (Quality Control, контроль качества) — второй уровень, включает в себя тестирование и контроль за соответствием
# заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшн.

# Основная задача контроля качества — предоставить объективную картину того, что происходит с качеством продукта на
# разных этапах разработки. Управление качеством (Quality control) — часть менеджмента качества, направленная на
# выполнение требований к качеству. Это означает, что необходимо выполнять требования, а как это будет
# происходить, зависит от корпоративной культуры.
# Вернемся к интернет-магазину. QC даст отмашку на релиз, если не заполнена страница благодарностей, на которую можно
# перейти из футера (подвала) сайта. Или, например, не даст добро, если страница благодарностей заполнена, а каталог
# пустой.


# 3. QA (Quality Assurance, обеспечение качества) — часть обеспечения согласованного уровня качества продукта. Это уже
# проактивная работа, т.к. основная задача обеспечения качества — это выстроить систему, которая будет работать на
# качество продукта, чтобы при тестировании количество дефектов было минимальным.
#
# В зависимости от специфики проекта сюда может входить тестирование документации, ревью кода на соответствие
# стандартам, внедрение каких-то методик по работе с качеством.
# Обеспечение качества (Quality Assurance) — часть менеджмента качества, направленная на создание уверенности, что
# требования к качеству будут выполнены.

# При более полном понимании можно обратиться к ГОСТ Р ИСО 9000-2015

# -------------------------------------------------------------------------------


# ---------------------------- 2.3. Принципы тестирования ---------------------------------

# Принципов тестирования всего 7. Как и большинство принципов, они редко напрямую используются на практике, но при
# этом любое тестирование предполагает их соблюдение:

# 1) Тестирование не может доказать отсутствие багов(только их наличие);
# 2) Исчерпывающее тестирование невозможно по определению;
# 3) Раннее тестирование позволяет сэкономить ресурсы;
# 4) Парадокс пестицидов;
# 5) Кластеризация багов;
# 6) Тестирование зависит от контекста;
# 7) Заблуждение об отсутствии багов;



# 1) Тестирование не может доказать отсутствие багов(только их наличие);

# Отсутствие багов во время проверки не может гарантировать отсутствия багов при подобных действиях в другое время. Из
# этого делаем вывод, что тестирование не может доказать отсутствие багов.

# Но с другой стороны, мы точно знаем, что баг может возникнуть у пользователя, раз он возник у нас. А раз баг есть,
# значит, что-то его вызывает. Следовательно, нужно найти причину этого бага и устранить ее.
#
# Исходя из этого, мы получаем вторую часть принципа — тестирование может доказать наличие багов.
#
# Здесь может показаться, что тестирование не так уж и нужно, раз не может ничего гарантировать. Да и тестировщик ни
# за что ответственности не несет — пропустил баг и ладно, отсутствие багов никто и не гарантировал. Все совсем не так.
# Как правило, для любого разрабатываемого ПО подразумеваются (и напрямую указываются) некие «нормальные условия», при
# которых оно должно работать, и именно в этих условиях проводятся проверки.

# P.S.
# Довольно хорошо иллюстрирует условия разработка мобильных приложений для устройств на iOS. Есть достаточно
# ограниченный список моделей айфонов и версий их операционной системы. Можно запланировать, что для запуска
# приложения нужна модель не старше определенной и версия iOS также не ниже определенной. При соблюдении этих условий
# приложение будет работать как задумано, в остальных случаях за результат никто не отвечает. И, соответственно,
# тестирование не проводится. С андроидом ситуация похожая, но там все чуть сложнее, т.к. у каждого производителя
# своя линейка моделей. Или вот еще пример: если вы напишете в техподдержку популярного баг-трекера Jira, что он
# некорректно работает на вашем макбуке, то получите ответ, что устройства от Apple официально не поддерживаются. В
# общем, это ваши проблемы, что у вас там не работает. Никто не будет разбираться до тех пор, пока не запустите на
# поддерживаемой конфигурации.



# 2) Исчерпывающее тестирование невозможно по определению;

# Тестировать можно бесконечно, проверяя различные сценарии поведения, но придется потратить оень много времени и
# ресурсов.

# На практике тестировщики выбирают наиболее эффективные проверки, руководствуясь знаниями о тестируемом ПО и здравым
# смыслом. Например, если у нашего поля в коде задано ограничение на ввод только цифр, то с ввода цифр и следует
# начать (положительные проверки всегда идут первыми!). Для негативных проверок достаточно будет несколько раз ударить
# по клавишам в русской раскладке. Ну и на английской, для успокоения совести. Ничего не появилось — ок, буквы не
# принимает. Теперь спецсимволы — как правило, в таком случае просто копируется и вставляется строка в
# духе `~@#$%^&*()_+|-=\{}[]:»;’<>?,./®©£¥¢¦§«»€. Если что-то из этого не заблокировано, оно появится в поле. Плюс надо
# быть особенно внимательным к точкам и запятым, ведь ими может отделяться дробная часть, поэтому попробовать
# ввести «2,» и «5.» тоже стоит. Вот и все, мы ужали годы проверок в пять минут и отправились тестировать следующее
# поле, спасибо второму принципу тестирования.



# 3) Раннее тестирование позволяет сэкономить ресурсы;

# Пожалуй, самый осязаемый, самый материальный принцип. Как вы позже узнаете, процесс тестирования программного
# обеспечения включает в себя не только работу с уже готовым или скорее полуготовым продуктом. По сути
# своей, тестирование сопровождает процесс разработки где-то с момента зарождения идеи. Когда на каждую мысль «Вот
# так будет очень хорошо!» появляется критическая оценка «А правда ли будет?» — это уже можно назвать тестированием.

# Но, возвращаясь к тестированию ПО, чем раньше была найдена ошибка (она же баг, она же дефект и т.д.), тем больше
# ресурсов будет сэкономлено. Ну или меньше потрачено, разницы нет. Под ресурсами мы понимаем, в первую очередь, время
# и деньги.

# Современные подходы говорят о том, что тестирование должно участвовать во всех этапах разработки ПО, а не просто
# получать на руки новую версию и протыкивать ее на предмет багов. Эффективность подобных практик доказана реальными
# результатами, поэтому в идеале команда тестирования должна быть на проекте уже на стадии первых обсуждений и планов.



# 4) Парадокс пестицидов;

# На практике возможна ситуация, когда программист, исправляя неоднократно найденный баг, изменит код таким образом, что
# баг на тех же самых данных перестанет повторяться, а на других продолжит. Предположим, в калькуляторе вместо
# умножения происходит сложение. Тестировщик всегда проверяет умножение, вводя 5х5 и получая 10 вместо 25. Тогда
# разработчик напишет код примерно такого содержания: если А=5 и В=5, то АхВ=25, во всех остальных случаях АхВ=А+В. В
# очередной раз введя 5х5, тестировщик наконец увидит 25 и подтвердит исправление бага. А если бы каждый раз вводил
# разное…
#
# Разумеется, ни один вменяемый разработчик никогда не поступит подобным образом. Но на этом тривиальном примере
# очевидна нелогичность решения. В большой сложной системе может быть непонятно, что новый код не исправляет реальную
# проблему, а лишь делает ее менее заметной.

# Итог:
# если одни и те же тесты повторяются снова и снова, в конечном итоге один и тот же набор тестов больше не обнаружит
# никаких новых дефектов. Чтобы преодолеть этот “парадокс пестицидов”, необходимо регулярно пересматривать и
# пересматривать тестовые примеры, а также писать новые и различные тесты для проверки различных частей программного
# обеспечения или системы на наличие потенциально большего количества дефектов.



# 5) Кластеризация багов;

# Закон Парето справедлив и для дефектов ПО. Это тот, который про 20% одного дает 80% другого. В нашем случае одним
# является функционал, а другим — баги. Ошибки при проверках имеют свойство складываться вместе, образовывая кластер.
# Или кучковаться в одном кластере разрабатываемого ПО — суть не меняется.
#
# Почему так получается? Причин может быть много, одно тянет за собой другое, а каждый случай индивидуален. Например,
# за «проблемный» модуль продукта отвечает программист, который ранее с подобными задачами не сталкивался. Учится по
# ходу дела и допускает много ошибок при выполнении задач. Или у заказчика нет четкого понимания как эта часть
# программы должна работать, он пытается менять решения на ходу, что сильно сказывается на уже сделанных частях. Или
# модуль плохо описан в документации, из-за чего возникает множество разночтений при выполнении.
#
# Докопаться до первопричины, устранить сразу множество имеющихся багов или хотя бы предотвратить появление
# будущих — это очень здорово. Но редко когда удается это сделать. Если разработчик только набирается опыта, он не
# наберется его моментально. На заказчика не снизойдет ясное видение готового продукта. А документация не изменится
# в одночасье.
#
# Для нас, как тестировщиков, важен один вывод из пятого принципа: нашел баг — поищи другой поблизости.
#
# P.S.
# Немного о другом, но все же важном на практике моменте. Согласно принципам программирования, похожие элементы не
# создаются каждый по отдельности. Вместо этого общая часть кода пишется в одном месте и используется уже в коде
# однотипных элементов в виде ссылки, а разнящиеся части дописываются после нее. Таким образом, если баг вызван ошибкой
# в общей части кода, сломаются все использующие общий код элементы. И, будучи найденным в одном элементе, этот баг
# может быть пропущен в другом. Об этом тоже надо помнить и сразу оценивать, что еще мог зацепить найденный баг.



# 6) Тестирование зависит от контекста;

# Это значит, что способ, которым вы тестируете сайт для e-commerce, будет отличаться от способа тестирования
# мобильного приложения. Софт бывает самый разный и подход к его тестированию тоже бывает самый разный. Необходимо
# применять разные подходы, методологии, техники и типы тестирования в зависимости от приложения.

# PS
# Уместна такая аналогия: спортсмен, готовящийся к соревнованиям, занимается спортом 6 часов в день. Офисный работник,
# заботящийся о своем здоровье, занимается спортом 6 часов в неделю.
# Все решают приоритеты, определяемые глобальными и текущими задачами, т.е. тот самый контекст.




# 7) Заблуждение об отсутствии багов;

# Отсутствие багов невозможно, но это мы знали и раньше, так о чем же седьмой принцип? Он о том, что отсутствие багов
# не смогло бы обеспечить серьезных преимуществ. Не надо бояться самого факта наличия багов в системе, баги — это
# нормально.
#
# P.S.
# И это опять-таки не значит, что тестировщик не несет ответственности за пропущенный баг, а на любые претензии может
# ответить «Баги — это нормально». Действительно, пропущенный краш приложения, повторяющийся при смене языка у 0,001%
# пользователей, это не так уж и страшно. Пропущенный краш приложения при запуске, повторяющийся у 99%
# пользователей — свидетельство того, что приложение никто не тестировал. Если хорошо поискать, баги найдутся в любом
# ПО, но очень важно, чтобы эти баги не мешали (ну хотя бы несильно) большинству пользователей.



# Task.
# Известно, что основной поток посетителей приходит по результатам запроса “.......”, сделанного с
# мобильного телефона. Используя сервис https://gs.statcounter.com/, необходимо выбрать три самых популярных браузера;
# на них будем осуществлять проверку.

# - Google Chrome
# - Safari
# - Samsung Internet



# Task.
# Предположим, мы в 1963 году тестируем поле ввода, которое может принимать только символы ASCII. Какое количество
# позитивных проверок будет исчерпывающим для поля, если известно, что ввести возможно только 3 символа?

# - 2 097 152
# (Согласно википедии, изначально (1963 год) ASCII была разработана для кодирования символов, коды которых
# помещались в 7 бит (128 символов; 2^7=128). Количество сочетаний из трёх символов вычисляется с помощью возведения
# общего количества возможных символов в третью степень. 128^3=2 097 152)



# Task.
# Что нужно делать, чтобы избежать парадокса пестицида?

# - Добавлять новые тесты
# - Пересматривать и улучшать тесты
# - Использовать разные тестовые данные



# Task.
# Предположим, у нашего сайта на 5 разных страницах встречаются селекты. Это такие выпадающие списки, вы их точно видели
# и не раз. При этом на 2 страницах селект представляет собой выпадающий список из нескольких вариантов. Назовем этот
# тип Селект 1.

# На 2 страницах список длинный и есть возможность искать по нему, вводя что-либо в поле селекта. Он будет - Селект 2.

# На последней странице при клике по селекту вместо выпадающего списка появляется подсказка «Введите не менее 3
# символов для поиска» и только после ввода появляется соответствующий поиску список возможных вариантов. А он будет
# Селект 3.

# При клике по Селекту 3 он не раскрылся. Какое предположение будет наиболее логичным для поиска аналогичной ошибки:

# - Имеет смысл проверить Селекты 1 и 2, т.к. выпадающий список при клике - общая функциональность всех селектов.



# Task.
# Отметьте виды тестирования, которые следует провести для мобильной игры с аудиторией 1 млн пользователей (в целях
# задачи считать, что ресурсов достаточно для любого объема тестирования):

# - тестирование безопасности
# - тестирование установки
# - тестирование удобства использования
# - функциональное тестирование
# - тестирование производительности
# - нагрузочное тестирование
# - тестирование совместимости



# Task.
# Перед вами требования заказчиков на разных проектах. Используя знание принципов тестирования отметьте те из них,
# которые, скорее всего, НЕ получится выполнить.

# - Да какая документация, приложение маленькое, его можно и так проверить;
# - Приложение должно соответствовать дизайну на любом устройстве;
# - Не выпустимся пока не выловим все баги;
# - Наше ПО рассчитано прежде всего на домохозяек, у них оно баговать не должно;
# - За пару часов до релиза передаём новую версию в тестирование, выпускаемся на всех возможных платформах.


# ====================================================================================



# ========================= 2.4 Методологии разработки =======================================

# SDLC, Waterfall, Agile и CI/CD. Who is who?

# Мы уже понимаем, что любое программное обеспечение создается по определенным правилам или «канонам», если хотите. В
# силу этого обстоятельства существует такое понятие как «жизненный цикл ПО».
#
# Жизненный цикл ПО (SDLC) – это период времени, который начинается с возникновения идеи продукта до прекращения его
# использования — вывода из эксплуатации.
#
# Жизненный цикл программного обеспечения состоит из последовательных этапов:
#
# - Анализ требований. На этом этапе составляется ТЗ(Техническое задание – это документ, содержащий информацию для
# постановки задач на разработку), обозначаются сроки по каждой задаче и план работ. Здесь также нужно учитывать все
# возможные риски. Как только все детали просчитаны и описаны – можно переходить к следующему этапу;

# - Дизайн системы. Разрабатывается прототип, дизайн-макет, платформа для программирования. Все члены команды должны
# быть расписаны по ролям, а также необходимо указать их обязанности;

# - Разработка. Команда пишет код продукта, согласно требованиям технического задания;

# - Тестирование. Проверка продукта, когда код написан. Если все благополучно, работу можно считать практически
# законченной;

# - Техническая поддержка. После релиза продукта, команда разработки поддерживает работу проекта на стабильном
# уровне, собирая обратную связь от пользователей и устраняя баги, если они возникают.



# Waterfall —  водопадная/каскадная модель разработки, описанная в 1970 году, дублирует этапы жизненного цикла ПО.
# Waterfall позволяет решать задачи по последовательному плану без возврата на предыдущие этапы.
#
# Принципы Waterfall:
#
# - Следуйте правилам;
# - Нет ТЗ — нет продукта;
# - Чем подробнее ТЗ, тем лучше продукт;
# - Следите, чтобы не было изменений.


# По мере развития и распространения ПО, нужно было максимально погружаться в проект, чтобы контролировать
# изменения, взаимодействовать с командой, предлагать новые решения. В рамках Waterfall это было невозможно, так как
# водопадная модель разработки не была гибкой. Именно в этот момент и появился Agile.


# Agile — это группа методик для гибкого управления продуктом. Суть этой группы методик заключается в разбивке
# процесса на небольшие временные промежутки — спринты. Во время каждого спринта команда разработки создает часть
# продукта, которую можно протестировать. Такой подход позволяет вносить правки на любом этапе.
#
# В Agile работа над продуктом строится по следующей логике:
#
# - составление ТЗ;
# - проектирование;
# - разработка;
# - тестирование;
# - результат.


# Пример
# Рассмотрим нашу тему на примере производственного процесса:


# Waterfall завод мороженого
#
# Гендиректор поручает технологу разработать новый вид мороженого. В лучшем случае, технолог пойдет в отдел
# маркетинга, чтобы они провели исследования. Но обычно такие идеи возникают не от желания потребителей, основанного
# на маркетинговых исследованиях, а от желания самого директора. По результатам исследований технолог разработает
# мороженое на собственный вкус и приносит его директору. Он пробует новый продукт и решает — переделывать или нет.
# Далее после утверждения директором, варщикам выдают технологические карты, по которым они могут запускать продукт в
# производство. Затем продавцам для реализации – упакованное мороженое. Это стандартный подход. Сотрудники получают
# задания, а оценка производится одним (иногда несколькими) человеком.


# Agile завод мороженого
#
# Гендиректору приходит идея разработать новый вид мороженого, и вот тут начинается чудо. При создании продукции
# будут задействованы не только технологи и сотрудники маркетинга, но также менеджеры по продажам, логисты, повара и
# реальные покупатели. При этом в команде нет никакой иерархии (кроме генерального директора) и итогом работы будет не
# награда конкретного сотрудника, а получение нового вида мороженого для покупателей. При этом все участники команды
# оценивают результат и дают обратную связь для его улучшения.


# Манифест гибкой разработки ПО:
#
# - Люди важнее инструментов.
# - Качество продукта важнее документации.
# - Взаимодействие с заказчиком важнее контракта.
# - Готовность к изменениям важнее установленного плана.



# Непрерывная разработка
# В разработке любого софта есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.

# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.

# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.

# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.

# В рамках непрерывного подхода решаются следующие задачи:
#
# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.

# CI/CD чаще всего зависит от тестировщиков и девопсов:
#
# - Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# - Девопсы автоматизируют процесс доставки ПО.

# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# Расположите этапы жизненного цикла ПО в правильном порядке:

# - Анализ требований
# - Проектирование
# - Разработка
# - Тестирование
# - Техническая поддержка



# Task.
# Выберите принципы методологии Agile:

# - Качество продукта важнее документации
# - Взаимодействие с заказчиком важнее контракта
# - Люди важнее инструментов
# - Готовность к изменениям важнее установленного плана



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Девопсы
# - Тестировщики



# =============================== 2.3 Подходы к разработке ==============================


# -------------------------------------------------
# Подходы к разработке
# -------------------------------------------------
# В разработке любого ПО есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.


# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.


# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.


# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.


# В рамках непрерывного подхода решаются следующие задачи:

# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.
#
# CI/CD чаще всего зависит от тестировщиков и разработчиков:
#
# Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# Разработчики автоматизируют процесс релиза ПО.
# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Тестировщики
# - Разработчики



# ==========================================================================



