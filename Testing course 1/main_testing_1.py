# ========================== Начало =========================

# Программная ошибка (жарг. баг) — означает ошибку в программе или в системе, из-за которой программа выдает
# неожиданное поведение и, как следствие, результат. Большинство программных ошибок возникают из-за ошибок команды
# разработки.



# Тестирование программного обеспечения — процесс исследования, испытания программного продукта, имеющий своей целью
# проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе
# тестов, выбранных определённым образом. Тестировщик, в свою очередь, моделирует различные ситуации (тесты), которые
# могут возникнуть в процессе использования программы, чтобы разработчики смогли исправить обнаруженные баги.



# Мы воспользуемся популярной техникой тест-дизайна, позволяющей быстро и качественно проверить что-либо:
#
# - Техника выделения классов эквивалентности и граничных значений позволяет уйти от дублирующих проверок.
# Следовательно, мы сократим количество однотипных тестов.
#
# - Классы эквивалентности — это разбиение функционала на наборы данных, которые ведут себя в пределах этих наборов
# одинаково. Например, дети, взрослые и пенсионеры - это все классы эквивалентности.
#
# - Анализ граничных значений — это метод, который улучшает разделение классов эквивалентности. В нашем случае, самые
# близкие значения — это 17 и 66.



# Чек-лист– это список, содержащий ряд необходимых проверок во время тестирования программного продукта. Отмечая пункты
# списка, команда или один тестировщик могут узнать о текущем состоянии выполненной работы и о качестве продукта.

# ===================================================================



# ========================== Теория ==============================


# ------------------------ 2.2. Тестирование и качество ------------------------

# Качество программного обеспечения — способность программного продукта при заданных условиях удовлетворять
# установленным или предполагаемым потребностям.



# Quality assurance, Quality control и Testing. Who is who?

# 1. Testing (тестирование) — самый первый уровень. Это проверка программного продукта на соответствие требованиям
# этого продукта.

# То есть ожидаемый результат и фактический результат совпадают, и это тот минимум, без которого нельзя выпускать
# продукт. Возьмем для примера тестирование в интернет—магазине кнопки «Купить».
# В процесс тестирования будет входить проверка функционала и сверка с макетом. Кнопка нажимается, открывается нужное
# окно, кнопка находится в правом нижнем углу, окрашена в зеленый цвет и т.д.


# 2. QC (Quality Control, контроль качества) — второй уровень, включает в себя тестирование и контроль за соответствием
# заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшн.

# Основная задача контроля качества — предоставить объективную картину того, что происходит с качеством продукта на
# разных этапах разработки. Управление качеством (Quality control) — часть менеджмента качества, направленная на
# выполнение требований к качеству. Это означает, что необходимо выполнять требования, а как это будет
# происходить, зависит от корпоративной культуры.
# Вернемся к интернет-магазину. QC даст отмашку на релиз, если не заполнена страница благодарностей, на которую можно
# перейти из футера (подвала) сайта. Или, например, не даст добро, если страница благодарностей заполнена, а каталог
# пустой.


# 3. QA (Quality Assurance, обеспечение качества) — часть обеспечения согласованного уровня качества продукта. Это уже
# проактивная работа, т.к. основная задача обеспечения качества — это выстроить систему, которая будет работать на
# качество продукта, чтобы при тестировании количество дефектов было минимальным.
#
# В зависимости от специфики проекта сюда может входить тестирование документации, ревью кода на соответствие
# стандартам, внедрение каких-то методик по работе с качеством.
# Обеспечение качества (Quality Assurance) — часть менеджмента качества, направленная на создание уверенности, что
# требования к качеству будут выполнены.

# При более полном понимании можно обратиться к ГОСТ Р ИСО 9000-2015

# -------------------------------------------------------------------------------


# ---------------------------- 2.3. Принципы тестирования ---------------------------------

# Принципов тестирования всего 7. Как и большинство принципов, они редко напрямую используются на практике, но при
# этом любое тестирование предполагает их соблюдение:

# 1) Тестирование не может доказать отсутствие багов(только их наличие);
# 2) Исчерпывающее тестирование невозможно по определению;
# 3) Раннее тестирование позволяет сэкономить ресурсы;
# 4) Парадокс пестицидов;
# 5) Кластеризация багов;
# 6) Тестирование зависит от контекста;
# 7) Заблуждение об отсутствии багов;



# 1) Тестирование не может доказать отсутствие багов(только их наличие);

# Отсутствие багов во время проверки не может гарантировать отсутствия багов при подобных действиях в другое время. Из
# этого делаем вывод, что тестирование не может доказать отсутствие багов.

# Но с другой стороны, мы точно знаем, что баг может возникнуть у пользователя, раз он возник у нас. А раз баг есть,
# значит, что-то его вызывает. Следовательно, нужно найти причину этого бага и устранить ее.
#
# Исходя из этого, мы получаем вторую часть принципа — тестирование может доказать наличие багов.
#
# Здесь может показаться, что тестирование не так уж и нужно, раз не может ничего гарантировать. Да и тестировщик ни
# за что ответственности не несет — пропустил баг и ладно, отсутствие багов никто и не гарантировал. Все совсем не так.
# Как правило, для любого разрабатываемого ПО подразумеваются (и напрямую указываются) некие «нормальные условия», при
# которых оно должно работать, и именно в этих условиях проводятся проверки.

# P.S.
# Довольно хорошо иллюстрирует условия разработка мобильных приложений для устройств на iOS. Есть достаточно
# ограниченный список моделей айфонов и версий их операционной системы. Можно запланировать, что для запуска
# приложения нужна модель не старше определенной и версия iOS также не ниже определенной. При соблюдении этих условий
# приложение будет работать как задумано, в остальных случаях за результат никто не отвечает. И, соответственно,
# тестирование не проводится. С андроидом ситуация похожая, но там все чуть сложнее, т.к. у каждого производителя
# своя линейка моделей. Или вот еще пример: если вы напишете в техподдержку популярного баг-трекера Jira, что он
# некорректно работает на вашем макбуке, то получите ответ, что устройства от Apple официально не поддерживаются. В
# общем, это ваши проблемы, что у вас там не работает. Никто не будет разбираться до тех пор, пока не запустите на
# поддерживаемой конфигурации.



# 2) Исчерпывающее тестирование невозможно по определению;

# Тестировать можно бесконечно, проверяя различные сценарии поведения, но придется потратить оень много времени и
# ресурсов.

# На практике тестировщики выбирают наиболее эффективные проверки, руководствуясь знаниями о тестируемом ПО и здравым
# смыслом. Например, если у нашего поля в коде задано ограничение на ввод только цифр, то с ввода цифр и следует
# начать (положительные проверки всегда идут первыми!). Для негативных проверок достаточно будет несколько раз ударить
# по клавишам в русской раскладке. Ну и на английской, для успокоения совести. Ничего не появилось — ок, буквы не
# принимает. Теперь спецсимволы — как правило, в таком случае просто копируется и вставляется строка в
# духе `~@#$%^&*()_+|-=\{}[]:»;’<>?,./®©£¥¢¦§«»€. Если что-то из этого не заблокировано, оно появится в поле. Плюс надо
# быть особенно внимательным к точкам и запятым, ведь ими может отделяться дробная часть, поэтому попробовать
# ввести «2,» и «5.» тоже стоит. Вот и все, мы ужали годы проверок в пять минут и отправились тестировать следующее
# поле, спасибо второму принципу тестирования.



# 3) Раннее тестирование позволяет сэкономить ресурсы;

# Пожалуй, самый осязаемый, самый материальный принцип. Как вы позже узнаете, процесс тестирования программного
# обеспечения включает в себя не только работу с уже готовым или скорее полуготовым продуктом. По сути
# своей, тестирование сопровождает процесс разработки где-то с момента зарождения идеи. Когда на каждую мысль «Вот
# так будет очень хорошо!» появляется критическая оценка «А правда ли будет?» — это уже можно назвать тестированием.

# Но, возвращаясь к тестированию ПО, чем раньше была найдена ошибка (она же баг, она же дефект и т.д.), тем больше
# ресурсов будет сэкономлено. Ну или меньше потрачено, разницы нет. Под ресурсами мы понимаем, в первую очередь, время
# и деньги.

# Современные подходы говорят о том, что тестирование должно участвовать во всех этапах разработки ПО, а не просто
# получать на руки новую версию и протыкивать ее на предмет багов. Эффективность подобных практик доказана реальными
# результатами, поэтому в идеале команда тестирования должна быть на проекте уже на стадии первых обсуждений и планов.



# 4) Парадокс пестицидов;

# На практике возможна ситуация, когда программист, исправляя неоднократно найденный баг, изменит код таким образом, что
# баг на тех же самых данных перестанет повторяться, а на других продолжит. Предположим, в калькуляторе вместо
# умножения происходит сложение. Тестировщик всегда проверяет умножение, вводя 5х5 и получая 10 вместо 25. Тогда
# разработчик напишет код примерно такого содержания: если А=5 и В=5, то АхВ=25, во всех остальных случаях АхВ=А+В. В
# очередной раз введя 5х5, тестировщик наконец увидит 25 и подтвердит исправление бага. А если бы каждый раз вводил
# разное…
#
# Разумеется, ни один вменяемый разработчик никогда не поступит подобным образом. Но на этом тривиальном примере
# очевидна нелогичность решения. В большой сложной системе может быть непонятно, что новый код не исправляет реальную
# проблему, а лишь делает ее менее заметной.

# Итог:
# если одни и те же тесты повторяются снова и снова, в конечном итоге один и тот же набор тестов больше не обнаружит
# никаких новых дефектов. Чтобы преодолеть этот “парадокс пестицидов”, необходимо регулярно пересматривать и
# пересматривать тестовые примеры, а также писать новые и различные тесты для проверки различных частей программного
# обеспечения или системы на наличие потенциально большего количества дефектов.



# 5) Кластеризация багов;

# Закон Парето справедлив и для дефектов ПО. Это тот, который про 20% одного дает 80% другого. В нашем случае одним
# является функционал, а другим — баги. Ошибки при проверках имеют свойство складываться вместе, образовывая кластер.
# Или кучковаться в одном кластере разрабатываемого ПО — суть не меняется.
#
# Почему так получается? Причин может быть много, одно тянет за собой другое, а каждый случай индивидуален. Например,
# за «проблемный» модуль продукта отвечает программист, который ранее с подобными задачами не сталкивался. Учится по
# ходу дела и допускает много ошибок при выполнении задач. Или у заказчика нет четкого понимания как эта часть
# программы должна работать, он пытается менять решения на ходу, что сильно сказывается на уже сделанных частях. Или
# модуль плохо описан в документации, из-за чего возникает множество разночтений при выполнении.
#
# Докопаться до первопричины, устранить сразу множество имеющихся багов или хотя бы предотвратить появление
# будущих — это очень здорово. Но редко когда удается это сделать. Если разработчик только набирается опыта, он не
# наберется его моментально. На заказчика не снизойдет ясное видение готового продукта. А документация не изменится
# в одночасье.
#
# Для нас, как тестировщиков, важен один вывод из пятого принципа: нашел баг — поищи другой поблизости.
#
# P.S.
# Немного о другом, но все же важном на практике моменте. Согласно принципам программирования, похожие элементы не
# создаются каждый по отдельности. Вместо этого общая часть кода пишется в одном месте и используется уже в коде
# однотипных элементов в виде ссылки, а разнящиеся части дописываются после нее. Таким образом, если баг вызван ошибкой
# в общей части кода, сломаются все использующие общий код элементы. И, будучи найденным в одном элементе, этот баг
# может быть пропущен в другом. Об этом тоже надо помнить и сразу оценивать, что еще мог зацепить найденный баг.



# 6) Тестирование зависит от контекста;

# Это значит, что способ, которым вы тестируете сайт для e-commerce, будет отличаться от способа тестирования
# мобильного приложения. Софт бывает самый разный и подход к его тестированию тоже бывает самый разный. Необходимо
# применять разные подходы, методологии, техники и типы тестирования в зависимости от приложения.

# PS
# Уместна такая аналогия: спортсмен, готовящийся к соревнованиям, занимается спортом 6 часов в день. Офисный работник,
# заботящийся о своем здоровье, занимается спортом 6 часов в неделю.
# Все решают приоритеты, определяемые глобальными и текущими задачами, т.е. тот самый контекст.




# 7) Заблуждение об отсутствии багов;

# Отсутствие багов невозможно, но это мы знали и раньше, так о чем же седьмой принцип? Он о том, что отсутствие багов
# не смогло бы обеспечить серьезных преимуществ. Не надо бояться самого факта наличия багов в системе, баги — это
# нормально.
#
# P.S.
# И это опять-таки не значит, что тестировщик не несет ответственности за пропущенный баг, а на любые претензии может
# ответить «Баги — это нормально». Действительно, пропущенный краш приложения, повторяющийся при смене языка у 0,001%
# пользователей, это не так уж и страшно. Пропущенный краш приложения при запуске, повторяющийся у 99%
# пользователей — свидетельство того, что приложение никто не тестировал. Если хорошо поискать, баги найдутся в любом
# ПО, но очень важно, чтобы эти баги не мешали (ну хотя бы несильно) большинству пользователей.



# Task.
# Известно, что основной поток посетителей приходит по результатам запроса “.......”, сделанного с
# мобильного телефона. Используя сервис https://gs.statcounter.com/, необходимо выбрать три самых популярных браузера;
# на них будем осуществлять проверку.

# - Google Chrome
# - Safari
# - Samsung Internet



# Task.
# Предположим, мы в 1963 году тестируем поле ввода, которое может принимать только символы ASCII. Какое количество
# позитивных проверок будет исчерпывающим для поля, если известно, что ввести возможно только 3 символа?

# - 2 097 152
# (Согласно википедии, изначально (1963 год) ASCII была разработана для кодирования символов, коды которых
# помещались в 7 бит (128 символов; 2^7=128). Количество сочетаний из трёх символов вычисляется с помощью возведения
# общего количества возможных символов в третью степень. 128^3=2 097 152)



# Task.
# Что нужно делать, чтобы избежать парадокса пестицида?

# - Добавлять новые тесты
# - Пересматривать и улучшать тесты
# - Использовать разные тестовые данные



# Task.
# Предположим, у нашего сайта на 5 разных страницах встречаются селекты. Это такие выпадающие списки, вы их точно видели
# и не раз. При этом на 2 страницах селект представляет собой выпадающий список из нескольких вариантов. Назовем этот
# тип Селект 1.

# На 2 страницах список длинный и есть возможность искать по нему, вводя что-либо в поле селекта. Он будет - Селект 2.

# На последней странице при клике по селекту вместо выпадающего списка появляется подсказка «Введите не менее 3
# символов для поиска» и только после ввода появляется соответствующий поиску список возможных вариантов. А он будет
# Селект 3.

# При клике по Селекту 3 он не раскрылся. Какое предположение будет наиболее логичным для поиска аналогичной ошибки:

# - Имеет смысл проверить Селекты 1 и 2, т.к. выпадающий список при клике - общая функциональность всех селектов.



# Task.
# Отметьте виды тестирования, которые следует провести для мобильной игры с аудиторией 1 млн пользователей (в целях
# задачи считать, что ресурсов достаточно для любого объема тестирования):

# - тестирование безопасности
# - тестирование установки
# - тестирование удобства использования
# - функциональное тестирование
# - тестирование производительности
# - нагрузочное тестирование
# - тестирование совместимости



# Task.
# Перед вами требования заказчиков на разных проектах. Используя знание принципов тестирования отметьте те из них,
# которые, скорее всего, НЕ получится выполнить.

# - Да какая документация, приложение маленькое, его можно и так проверить;
# - Приложение должно соответствовать дизайну на любом устройстве;
# - Не выпустимся пока не выловим все баги;
# - Наше ПО рассчитано прежде всего на домохозяек, у них оно баговать не должно;
# - За пару часов до релиза передаём новую версию в тестирование, выпускаемся на всех возможных платформах.


# ====================================================================================



# ========================= 2.4 Методологии разработки =======================================

# SDLC, Waterfall, Agile и CI/CD. Who is who?

# Мы уже понимаем, что любое программное обеспечение создается по определенным правилам или «канонам», если хотите. В
# силу этого обстоятельства существует такое понятие как «жизненный цикл ПО».
#
# Жизненный цикл ПО (SDLC) – это период времени, который начинается с возникновения идеи продукта до прекращения его
# использования — вывода из эксплуатации.
#
# Жизненный цикл программного обеспечения состоит из последовательных этапов:
#
# - Анализ требований. На этом этапе составляется ТЗ(Техническое задание – это документ, содержащий информацию для
# постановки задач на разработку), обозначаются сроки по каждой задаче и план работ. Здесь также нужно учитывать все
# возможные риски. Как только все детали просчитаны и описаны – можно переходить к следующему этапу;

# - Дизайн системы. Разрабатывается прототип, дизайн-макет, платформа для программирования. Все члены команды должны
# быть расписаны по ролям, а также необходимо указать их обязанности;

# - Разработка. Команда пишет код продукта, согласно требованиям технического задания;

# - Тестирование. Проверка продукта, когда код написан. Если все благополучно, работу можно считать практически
# законченной;

# - Техническая поддержка. После релиза продукта, команда разработки поддерживает работу проекта на стабильном
# уровне, собирая обратную связь от пользователей и устраняя баги, если они возникают.



# Waterfall —  водопадная/каскадная модель разработки, описанная в 1970 году, дублирует этапы жизненного цикла ПО.
# Waterfall позволяет решать задачи по последовательному плану без возврата на предыдущие этапы.
#
# Принципы Waterfall:
#
# - Следуйте правилам;
# - Нет ТЗ — нет продукта;
# - Чем подробнее ТЗ, тем лучше продукт;
# - Следите, чтобы не было изменений.


# По мере развития и распространения ПО, нужно было максимально погружаться в проект, чтобы контролировать
# изменения, взаимодействовать с командой, предлагать новые решения. В рамках Waterfall это было невозможно, так как
# водопадная модель разработки не была гибкой. Именно в этот момент и появился Agile.


# Agile — это группа методик для гибкого управления продуктом. Суть этой группы методик заключается в разбивке
# процесса на небольшие временные промежутки — спринты. Во время каждого спринта команда разработки создает часть
# продукта, которую можно протестировать. Такой подход позволяет вносить правки на любом этапе.
#
# В Agile работа над продуктом строится по следующей логике:
#
# - составление ТЗ;
# - проектирование;
# - разработка;
# - тестирование;
# - результат.


# Пример
# Рассмотрим нашу тему на примере производственного процесса:


# Waterfall завод мороженого
#
# Гендиректор поручает технологу разработать новый вид мороженого. В лучшем случае, технолог пойдет в отдел
# маркетинга, чтобы они провели исследования. Но обычно такие идеи возникают не от желания потребителей, основанного
# на маркетинговых исследованиях, а от желания самого директора. По результатам исследований технолог разработает
# мороженое на собственный вкус и приносит его директору. Он пробует новый продукт и решает — переделывать или нет.
# Далее после утверждения директором, варщикам выдают технологические карты, по которым они могут запускать продукт в
# производство. Затем продавцам для реализации – упакованное мороженое. Это стандартный подход. Сотрудники получают
# задания, а оценка производится одним (иногда несколькими) человеком.


# Agile завод мороженого
#
# Гендиректору приходит идея разработать новый вид мороженого, и вот тут начинается чудо. При создании продукции
# будут задействованы не только технологи и сотрудники маркетинга, но также менеджеры по продажам, логисты, повара и
# реальные покупатели. При этом в команде нет никакой иерархии (кроме генерального директора) и итогом работы будет не
# награда конкретного сотрудника, а получение нового вида мороженого для покупателей. При этом все участники команды
# оценивают результат и дают обратную связь для его улучшения.


# Манифест гибкой разработки ПО:
#
# - Люди важнее инструментов.
# - Качество продукта важнее документации.
# - Взаимодействие с заказчиком важнее контракта.
# - Готовность к изменениям важнее установленного плана.



# Непрерывная разработка
# В разработке любого софта есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.

# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.

# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.

# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.

# В рамках непрерывного подхода решаются следующие задачи:
#
# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.

# CI/CD чаще всего зависит от тестировщиков и девопсов:
#
# - Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# - Девопсы автоматизируют процесс доставки ПО.

# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# Расположите этапы жизненного цикла ПО в правильном порядке:

# - Анализ требований
# - Проектирование
# - Разработка
# - Тестирование
# - Техническая поддержка



# Task.
# Выберите принципы методологии Agile:

# - Качество продукта важнее документации
# - Взаимодействие с заказчиком важнее контракта
# - Люди важнее инструментов
# - Готовность к изменениям важнее установленного плана



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Девопсы
# - Тестировщики



# =============================== 2.3 Подходы к разработке ==============================


# -------------------------------------------------
# Подходы к разработке
# -------------------------------------------------
# В разработке любого ПО есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.


# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.


# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.


# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.


# В рамках непрерывного подхода решаются следующие задачи:

# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.
#
# CI/CD чаще всего зависит от тестировщиков и разработчиков:
#
# Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# Разработчики автоматизируют процесс релиза ПО.
# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Тестировщики
# - Разработчики



# ================================ 2.5 Процесс тестирования ==========================================

# ISTQB - Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.
#
# Процесс тестирования
# Вопреки ожиданиям, процесс тестирования несколько шире, чем «садишься за комп и тестишь». Помимо непосредственного
# взаимодействия с объектом тестирования, существуют как подготовительные этапы, так и последующие. Для того, чтобы
# проверки стабильно давали точную информацию о качестве продукта, они документируются и регулярно актуализируются.
#
# Для измерения эффективности тестирования и отслеживания общего качества используются специальные метрики. На
# основании полученных результатов и рассчитанных метрик составляются отчеты. По разным оценкам, работа с документацией
# занимает от 50% до 70% времени тестировщика, на само же тестирование тратится оставшаяся часть.
#
# Настроенные процессы — залог успешной реализации проекта, и тестирование в этом успехе играет не последнюю роль.
#
# Четкое понимание того, что, как и в какой момент делать, экономит время, придает уверенность, устанавливает хорошие
# взаимоотношения в команде. Подобно фундаменту здания, который никто не видит, но на который все опирается. Сами по
# себе процессы не могут обеспечить успешность проекта, но могут существенно упростить ее достижение. Процесс
# тестирования не является чем-то отдельным, он плотно переплетается с другими процессами, входящими в разработку и
# выпуск программного обеспечения.
#
# Дисклеймер: в качестве основы для описания процесса тестирования была взята Программа подготовки базового уровня 2018
# года ISTQB, доступная для скачивания по ссылке https://www.rstqb.org/ru/istqb— downloads.html (на русском и
# английском языках)



# -------------------- Планирование -----------------------------
# Прежде всего оговоримся, что весь описываемый процесс не обязательно представляет собой жесткую последовательность.
# Разные этапы могут идти параллельно, потому что тут не успели, а там сделали раньше. Могут возникнуть непредвиденные
# обстоятельства, из-за которых придется возвращаться к сделанному ранее и переделывать по-новому.
#
# Процессы (в том числе тестирования) в разных компаниях или в одной компании на разных проектах могут существенно
# отличаться, поэтому данное описание не является догмой на все 100%. И, наконец, несмотря на то, что мы говорим о
# проекте в целом, процесс может применяться и отдельно к его частям. Например, выпуск новой версии вполне может пройти
# все описанные  здесь этапы. Обо всем этом надо помнить в процессе изучения и осмысления материала.
#
# Планирование тестирования — этап составления планов (внезапно!). Тест-план включает в себя всю общую информацию о
# проекте. Например, требования и дизайн продукта. Под требованиями подразумевается документ(ы), в котором
# сформулировано, какую функциональность продукт должен предоставлять пользователю. Техническое задание, спецификации,
# требования, юзер стори, любые аналогичные документы. Требования могут быть расписаны в разных формах, но они в любом
# случае включают в себя описание работы конечного продукта. Например:
#
# пользователь должен иметь возможность авторизоваться на сайте;
# авторизованный пользователь должен иметь возможность зайти в личный кабинет;
# в личном кабинете пользователь должен иметь возможность прикрепить банковскую карту с целью использования ее для
# будущих покупок на сайте.
#
#
# Дизайном называют макеты будущего продукта, отрисованные в графическом редакторе. Не так давно многое рисовалось в
# фотошопе, но сейчас чаще используются специальные программы, имеющие «заточенный» для этих целей интерфейс и
# функционал. Например, довольно популярна Figma — мы еще столкнемся с ней на следующих уроках, но можете погуглить
# ради интереса уже сейчас. Требования, дизайн и любые другие описывающие будущий продукт вещи называются «тестовым
# базисом».
#
# Помимо этого, план тестирования может включать в себя, например, расписание тестирования, т.е. когда будет
# тестироваться какая часть продукта. Откуда это может быть известно? Нельзя разрабатывать продукт по принципу «когда
# будет готово», все работы имеют временные оценки и установленные сроки реализации. Соответственно, когда будет
# готова конкретная функциональность, тогда и начнется ее тестирование.
#
# Еще к плану тестирования можно приложить анализ рисков, список метрик с формулами, бюджет, критерии начала и
# окончания тестирования, образцы тестовой документации, описание используемых техник и технологий. Вообще что угодно
# из того, о чем можно договориться «на берегу», когда разработка еще не начата. Вся общая информация, хоть как-то
# касающаяся тестирования — здесь.



# ------------------------------- Мониторинг и контроль -----------------------------------

# Этап мониторинга и контроля не является этапом «до» или «после», это этап «во время». Во время всего проекта, если
# быть точнее. Мониторинг и контроль тестирования подразумевают непрерывное отслеживание фактического хода работы и
# сверку его с тестовым планом. Помните, на этапе планирования мы говорили о расписании? Крайне важно не только иметь
# такой документ, но и регулярно к нему обращаться, а в случае расхождения вовремя принимать меры, чтобы
# скорректировать ход работ. Расчет метрик тестирования также входит в мероприятия данного этапа.
#
# Одной из метрик является процент пройденных проверок — завтра у нас выходит новая версия, а сегодня она
# протестирована только на 10% — значит, что-то идет не так. Например, новую версию установили только сегодня. Или
# ее установили неделю назад, а мы ничего не тестировали. Ищем причину, устраняем ее, продолжаем работу в штатном
# режиме.
#
# Разумеется, отчетность — тоже элемент данного этапа. Стандарт ISO/IEC/IEEE 29119-3 выделяет два вида отчетов: отчет
# о ходе тестирования и отчет о завершении тестирования. Форма и содержание отчетов могут сильно отличаться от проекта
# к проекту, а также в зависимости от целей, которые преследуют конкретные отчеты, и аудитории, для которой они
# составляются.
#
# Например, для сложных, формальных проектов с большим числом заинтересованных лиц может потребоваться более подробная
# и строгая отчетность. В гибкой разработке отчеты о ходе тестирования могут быть частью обсуждения на ежедневных
# встречах, поэтому составляются в автоматическом или полуавтоматическом режиме (например, путем выгрузки списка
# задач, по которым велись работы, из баг-трекера).
#
# В целом, для понимания того, что что-то идет не так, требуется отслеживать то, как оно идет в данный момент и знать,
# как оно должно идти. Мониторинг и контроль тестирования это в первую очередь задача руководства. Для рядового же
# сотрудника (как правило) данный этап заканчивается на выполнении регламентированных рутинных действий по ежедневному
# заполнению форм, если они не заполняются автоматически по мере его работы.



# ------------------------------------- Анализ ------------------------------------------------

# На этапе анализа занимаются… анализом (бадум тссс!). Крайне здравый вопрос: «Анализом чего»? И здесь мы приходим к
# фундаментальному принципу трассируемости, о котором будем упоминать постоянно и который красиво выстроится у нас к
# концу этого урока. Мониторинг и контроль стоит как бы в стороне, т.к. идет параллельно всем другим этапам. Но
# поставить его в самое начало или в самый конец списка было бы не очень логично.
#
# Из-за этого он вклинился на второе место и немного поломал последовательность, но это не страшно. Итак, на этапе
# анализа мы анализируем тестовый базис, собранный на этапе планирования. Напомним, что тестовым базисом у нас
# называются описывающие будущий продукт требования и дизайн.
#
# Анализировать их можно с двух сторон:
#
# Анализ базиса на наличие ошибок. Все документы, входящие в базис, тоже можно тестировать и выявлять такие баги, как
# неточность, неоднозначность, противоречивость, избыточность и т.д. Например, если на макете главной страницы
# кнопка «личный кабинет» расположена в десяти разных местах, это вполне может быть поводом уточнить, не стоит ли
# сократить это количество хотя бы до 9. Или требование нарисовать 7 перпендикулярных линий (погуглите, ролик веселый)...
# Анализ базиса с целью выявления тестовых условий. Под тестовыми условиями понимается конкретное утверждение, которое
# можно проверить. Например, «кнопка должна быть красивенькая» — не тестовое условие, а «кнопка должна быть 20х40,
# цвета FF0000, с надписью цвета FFFFFF «Старт» шрифтом Times new roman размера 9,5» — целый набор тестовых условий.
# Таким образом, по завершении этого этапа мы должны получить полностью непротиворечивые, абсолютно точные и
# максимально подробные документы тестового базиса и целый набор таких же качественных тестовых требований.



# --------------------- Проектирование----------------------

# И вот наступает этап проектирования, на котором мы будем… проектировать (никогда не надоест). Но
# вопросы: «Что именно?» и «Как?» здесь более чем уместны, давайте найдем на них ответ. Мы будем писать высокоуровневые
# тест-кейсы на основании тестовых условий. Для начала очень кратко разберем, что такое тест-кейс (подробно о
# тест-кейсах поговорим в модуле 3). Тест-кейс, он же тестовый сценарий, представляет из себя описание
# последовательности конкретных шагов (действий), которые следует пройти для проверки какой-либо функциональности. Как
# правило, для каждого шага прописывается ожидаемый результат, т.е. что должно произойти при выполнении действия,
# например:
#
# Нажать ЛКМ на иконку корзины в правой верхней части страницы — Страница корзины открыта.
#
# По сути своей, это уже тест- кейс — очень короткий, но все же. На практике тест-кейсы обычно длиннее. Например,
# открыть каталог, добавить товар в корзину, потом перейти в нее и убедиться, что товар добавился — уже вполне себе
# тест-кейс «Проверка добавления товара в корзину». Высокоуровневый тест-кейс характеризуется отсутствием привязки к
# конкретным данным — то есть мы не указываем какой именно товар из какого раздела каталога должен быть добавлен. Или,
# скажем, при проверке авторизации пишем «ввести корректный логин и пароль» вместо указания конкретных логина и пароля.
#
# Примечание: в других популярных источниках такое деление на высокоуровневые и обычные тест-кейсы отсутствует, но все
# же ISTQB достаточный авторитет, чтобы о нем рассказать.
#
# Тест-кейсы пишутся на основании тестовых условий. Вспомним нашу кнопку (которая «Старт», а не которая красивенькая),
# нам потребуется проверить ее цвета, надпись и шрифт. Так как тест-кейсы у нас высокоуровневые, мы просто укажем что
# ее параметры корректны, «соответствуют макету» (предположим, что мы взяли их с макета). В такой формулировке
# тест-кейс можно будет применить не только к конкретно этой кнопке, а вообще ко всем кнопкам, изображенным на
# макете (т.е. вообще ко всем кнопкам нашего продукта, т.к. макет должен отображать итоговый вид).
#
# И вот смотрите, как интересно у нас уже выстраиваются рабочие продукты каждого этапа по принципу
# трассируемости: сначала из макета, представляющего тестовый базис, были выделены тестовые условия, а уже на их
# основании написан высокоуровневый тест-кейс. То ли еще будет, идем дальше!



# ------------------------------- Реализация ---------------------------------------------

# На этапе реализации мы, как ни странно, не реализуем. Данный перевод английского implementation хоть и является
# самым распространенным, в данном случае крайне неудачен. В первоисточнике слово употребляется в значении «снабжение
# инструментами» и, собственно, именно это и происходит на данном этапе.
#
# Инструментами в нашем случае являются, например, все необходимые для тестирования вспомогательные программы.
# Баг-трекер, в котором будут описываться все найденные баги и отслеживаться прогресс их исправления. Сначала
# баг-трекер необходимо выбрать, затем оплатить его использование, после чего создать нужное количество учетных записей
# для всех, кто будет участвовать в процессе разработки.
#
# Также понадобится настроить баг-трекер —  уже упомянутая ранее Jira позволяет очень гибко кастомизировать набор
# полей, которые будут использоваться в ходе работы. Помимо банальных заголовка, описания, версии продукта и
# окружения, на котором воспроизводится баг, можно, например, добавить список компонентов продукта (отдельные разделы
# интернет— магазина — каталог, корзина, личный кабинет и т.д.). Или с помощью системы лейблов создать сложную
# детализацию функционала, который затрагивает баг (лучше не надо, но возможность есть). Также инструментами будет
# дополнительное ПО для выполнения каких-то специфических действий —  для работы с базой данных проекта, для
# проведения нагрузочного тестирования и т.д.
#
# Нельзя забывать о настройке стендов для тестировщиков, разработчиков, для других заинтересованных (менеджмента,
# инвесторов). Пусть вас не пугает слово «стенд» —  под ним подразумевается версия продукта, закрытая для доступа
# посторонних. То есть это банально тот же сайт интернет-магазина, что в итоге будет выпущен, но только его ранняя
# версия. С каталогом из 5 товаров, с регулярно отваливающейся корзиной и в принципе половиной функционала в
# состоянии «еще не готово». Зато имеющийся функционал уже надо тестировать.
#
# То есть, если нашим продуктом является сайт bestshop.org, то по адресу test-bestshop.org может располагаться стенд
# для тестировщиков, dev-bestshop.org —  стенд разработчиков, а manage-bestshop.org —  стенд для менеджмента.
#
# Разработчики пишут фичи и смотрят как они работают на своем стенде, потом набор фич объединяется вместе и составляет
# новую версию продукта —  ее раскатывают на стенде тестировщиков и она тестируется, а последняя стабильная
# протестированная версия устанавливается на менеджерский стенд, чтобы начальство могло отслеживать ход работ,
# показывать его заказчику, инвесторам и еще кому угодно, кто должен это увидеть.
#
# Сами стенды могут быть развернуты, например, во внутренней сети компании и извне на них зайти никто никогда не
# сможет. Устройство всей этой системы, в том числе и с «железной» стороны (программы должны запускаться на
# компьютерах, которые еще купить и настроить сначала надо) — тоже часть этапа реализации.
#
# Этот этап тоже мог бы выпасть из принципа трассируемости, если бы на этом его описание и окончилось, но нет. Также
# на этом этапе подготавливаются тестовые данные. Те самые тестовые данные, в отрыве от которых пишутся
# высокоуровневые тест-кейсы. То есть, если мы сложим эти два компонента, то получим что? Правильно, готовые к
# употреблению тест-кейсы.
#
# Тест-кейсы могут укладываться в последовательности в рамках этого этапа (логично сначала протестировать
# авторизацию, а потом личный кабинет — можно сэкономить немного времени).
#
# В целом, этап реализации можно было бы назвать этапом «настройки» или этапом «подготовки к выполнению», но
# первоисточник — есть первоисточник.



# ------------------------------------ Выполнение -----------------------------------------

# Ну что ж, мы прошли долгий путь и теперь, вооруженные до зубов спецификациями, установленными программами,
# настроенными доступами и целой кучей тест-кейсов мы переходим на этап выполнения, на котором будем
# ВЫПОЛНЯТЬ (вы же не думали, что эта шутка могла закончиться?) тестирование. Как мы будем это делать?
#
# Да, в общем-то, вот он, тот самый этап «протыкивания», этап «берешь и тестишь», с которым многие и ассоциируют
# профессию тестировщика (из тех, кто вообще о ней знает). У нас есть набор действий, ожидаемый результат которых
# заранее известен (тест-кейсы). Мы производим эти действия, отслеживая получаемый результат. Если полученный
# результат не совпал с ожидаемым, на это пишется баг-репорт, который уходит разработчикам. Результат каждого
# прохождения тест-кейсов (pass/fail) документируется на протяжении всего времени существования проекта.
#
# Остановимся чуть подробнее на этом моменте, чтобы процесс тестирования ПО стал немного понятнее. До сих пор мы
# описывали все этапы так, как будто однажды завершив один этап, мы переходим к следующему и больше назад не
# возвращаемся. В начале урока был дисклеймер о том, что последовательность не жесткая, вот его-то мы расширим и
# углубим.
#
# К нам на стенд приехала самая первая версия продукта, которую мы должны протестировать. Это маленький кусочек
# функционала, например, страница авторизации. При успешном вводе логина пароля нам показывается заглушка —  страница
# с надписью «авторизация успешна».
#
# Если же логин и пароль не подходят друг к другу, демонстрируется соответствующее сообщение. Функциональность
# протестирована, тест-кейсы пройдены, баг-репорты написаны. Приезжает новая версия, в которой исправлены баги
# предыдущей плюс добавлен новый функционал — вместо заглушки теперь показывается главная страница, только на ней
# ничего не работает (это прикрутят уже в следующей версии).
#
#  И вот важный момент, каковы наши действия:
#
# проверяем, исправлены ли баги предыдущей версии (те, которые разработчики пометили как исправленные и передали нам),
# в зависимости от результата переводим их в статус исправленных или возвращаем разработке на исправление;
# проводим тестирование нового функционала, проходим тест-кейсы, пишем баг-репорты;
# проводим полное тестирование оставшегося функционала (это называется регрессионное тестирование или сокращенно
# регресс), чтобы убедиться, что исправление багов и добавление новых фич его не сломало;
# в ожидании новой версии работаем с документацией, т.е. проверяем актуальность имеющихся тест-кейсов, пишем новые,
# считаем метрики и т.д.;
# Когда на наш стенд установят новую версию, все повторится по новой. Возможно, в какой-то момент будет внедряться
# фича, которая не была изначально запланирована, и в отношении нее весь тестовый процесс начнется сначала, при этом
# реализация запланированных фич прерываться не будет, они также будут выходить в рамках новых версий как было
# задумано изначально. Процессы будут идти параллельно, пока в определенный момент новая фича просто не станет частью
# новой версии продукта.
#
# Надеюсь, нам удалось передать, что процесс тестирования — это не лестница, это река.



# -------------------------------------- Завершение -------------------------------------------

# Этап завершения необязательно подразумевает под собой завершение всего проекта. Речь идет о завершении какой-то части
# работ, которую можно выделить. Это может быть банально выпуск новой версии. Что-то более крупное, например, выход
# продукта в релиз. Завершение проекта — тоже вполне себе подходящий повод, но все же он бывает один раз, а этапов
# завершения в процессе тестирования подразумевается гораздо больше.
#
# Это этап подведения итогов, учета возникших проблем и разработки способов их избежать в будущем. Тот момент, когда
# надо остановиться, оглянуться на проделанную работу и сказать «Хм, а ведь неплохо. Но в будущем можно поменять вот
# тут и тут и получится еще лучше». И обязательно сделать так в следующей версии, следующем релизе, следующем проекте.
# Ведь полученный опыт, дополнительно осмысленный на данном этапе, не позволит повторить допущенные ошибки. Время
# собирать камни.
#
# Вещественно этап воплощается в отчетах о проведенных проверках и их результатах, а также в изменениях в работе
# команды. Об изменениях говорить не будем — они индивидуальны для каждого проекта, каждой команды. А вот на отчетах
# остановимся, снова вспомнив принцип трассируемости в процессе тестирования. Возьмем отчет, в котором прописано, что
# баг А был обнаружен при прохождении тест-кейса Б, который в последней на данный момент версии продукта был пройден
# успешно. Тест-кейс Б был написан на основании тестового условия C, выделенного из пункта D документа E,
# представляющего собой список требований, выявленных аналитиком Ивановым при общении с заказчиком.
#
# На самом деле, правильно называть наш принцип «принципом двунаправленной трассируемости», ведь при его соблюдении
# мы можем проследить путь как от требования к результату в конечном продукте, так и от конечного продукта к
# конкретному требованию. И на этом мы ЗАВЕРШАЕМ теорию процесса тестирования (потому что никто не ждет испанскую
# инквизицию).



# Task.
# Поставь этапы тестирования в правильном порядке, с теоретической точки зрения:

# - Планирование
# - Мониторинг и контроль
# - Анализ
# - Проектирование
# - Реализация
# - Выполнение
# - Завершение



# Task.
# На каком этапе тестировщики получают все необходимое для начала тестирования продукта?

# - реализация



# Task.
# Как думаете, когда можно прекратить тестирование?

# - Если ущерб от незакрытого бага не превышает затрат на его исправление, то исправлять баг не надо
# - Если суммарный ущерб от всех известных незакрытых багов не превышает выгоды от внедрения существующей версии
# системы, то её надо внедрять (пусть даже и с известными незакрытыми багами)
# - Если ущерб от потенциального бага не превышает затрат на его поиск и исправление, то искать баг не надо



# ============================================================================



# =============================== 2.7 Пирамида тестирования =====================================


# --------------------------------------------------------
# Выделяют четыре уровня тестирования:
#
# - Модульное тестирование (Component/Unit testing);
# - Интеграционное тестирование (Integration testing);
# - Системное тестирование (System testing);
# - Приемочное тестирование (Acceptance testing).

# Задачи любого уровня тестирования:
#
# - Снижение риска;
# - Обнаружение дефектов;
# - Предотвращение перехода дефектов на более высокие уровни.



# -------------------------------------------------------------
# Модульное тестирование
# Для обозначения модульного тестирования используется множество синонимичных названий: модульное, юнит или
# компонентное.

# Модульное тестирование проводится, вызывая код,  и позволяет проверить, что отдельные части общего кода работают
# согласно требованиям документации.

# Модульное тестирование, как правило, проводится разработчиками. В качестве примера самого модуля может выступать
# любой отдельный компонент приложения, например, одна веб-страница, объект, функция или класс (страница авторизации,
# поиск товара в интернет магазине, перемещение товара в корзину).

# Например: разработано всего две страницы приложения: страница регистрации и страница авторизации. На этапе
# модульного тестирования нужно убедиться, что каждая страница в отдельности работает правильно, то есть на странице
# регистрации можно зарегистрировать нового пользователя, а на странице авторизации можно авторизоваться уже
# зарегистрированному пользователю.

# Т.е. сначала каждая страница проверяется по отдельности, а потом уже переходим к более высокому уровню
# тестирования - тестирование взаимодействия этих страниц друг с другом.

# Найденные дефекты, при модульном тестировании чаще всего исправляются самим разработчиком, без занесения в
# баг-трекинговую систему (место хранения отчетов о найденных багах).


# Типичные дефекты модульного тестирования:
#
# - Неправильное поведение модуля (несоответствующее документации и требованиям);
# - Неправильный код.



# ------------------------------------------------------------------------
# Интеграционное тестирование
# Это тестирование взаимодействия модулей системы или нескольких систем.
#
# Так как разные модули приложения могут разрабатываться разными программистами - необходимо проверить взаимодействие
# между ними.
#
# Один компонент (модуль) производит выходные данные, а другой компонент эти данные принимает на вход. Проверка
# правильности взаимодействия этих отдельных модулей или систем и называется интеграционным тестированием.
#
# В результате тестирования стоит ожидать, что все смежные системы и модули одной системы должны работать согласованно.
#
# Например, со страницы корзины при нажатии кнопки «Оплатить» происходит переход на страницу платежной системы и
# осуществляется оплата.
#
# Типичные тестовые объекты:
#
# - Подсистемы;
# - Базы данных;
# - Интерфейсы, с помощью которых взаимодействует система;
# - Микросервисы.

# Типичные дефекты:
#
# - Отсутствующие или неправильные данные;
# - Сбои связи между компонентами;
# - Нарушение обязательных правил безопасности.



# -----------------------------------------------------------
# Системное тестирование (System testing)
# Производится после окончания интеграционного. Сначала разработчики создают и тестируют модули, затем интегрируют и
# тестируют модули между собой. В результате получается некая завершенная система, базовая модель приложения.
#
# Цель системного тестирования: проверить все приложение целиком.
#
# На системном уровне тестирования проводится тестирование полного пути (end-to-end/E2E flow) использования продукта.
# Под путем использования понимается вся цепочка взаимодействия от запуска приложения до какого-то конечного результата.
#
# Пример сценария end-to-end для интернет магазина:
#
# - Незарегистрированный пользователь переходит на сайт интернет магазина;
# - Регистрируется на сайте;
# - Авторизуется на сайте;
# - Находит необходимый товар;
# - Добавляет его в корзину;
# - Статус заказа «Ожидает оплаты»;
# - Оплачивает заказ;
# - Деньги поступают на счет компании;
# - Статус заказа меняется на «Оплачен»;
# - После получения заказа пользователем статус заказа меняется на «Получен».

# Типичные дефекты:
#
# - Неожиданное или неверное поведение системы;
# - Система неспособна выполнять end-to-end задачи;
# - Система неспособна правильно работать в различных средах;
# - Система работает не в соответствии с пользовательским руководством.



# --------------------------------------------------------------------------
# Приемочное тестирование (Acceptance testing)
# Проверяет, выполнены ли все бизнес-требования перед выпуском приложения на рынок.
#
# На текущем уровне тестирования обязательно должны применяться реальные данные и реальное использование приложения.
# Такой подход делает приемочное тестирование очень важным этапом цикла выпуска приложения. Это окончательное
# тестирование, выполняемое после завершения модульного, интеграционного и системного тестирования
#
# Критерии приемки — это условия, которым должно удовлетворять приложение, чтобы быть принятым заказчиком.
#
# Приемочное тестирование включает следующие формы:
#
# Пользовательское приемочное тестирование (User acceptance testing)  —  производится пользователями конечного продукта;
# Операционные приемочные испытания (Operational acceptance testing) - как правило, проводят системные администраторы.
# Проверяются функции резервного копирования, установка/ удаление/ обновление системы, проверка безопасности и
# производительности приложения. Необходимо удостовериться, что приложение возможно обслуживать и сопровождать на
# требуемом уровне даже в экстремальных условиях;
# Контрактные и нормативные приемочные испытания (Contractual and regulatory acceptance testing )  —  проверка, что
# приложение соблюдает все нормативные требования, продукт не нарушает чью-то интеллектуальную собственность или не
# использует нелицензионный софт;
# Альфа и бета-тестирование (Alpha and beta testing ).
# Альфа тестирование  включает имитацию реального использования продукта штатными  или сторонними разработчиками, либо
# командой тестировщиков.
#
# Бета-тестирование  —  производится реальными пользователями, с целью получения от них обратной связи и выявления
# максимального числа ошибок для их последующего устранения перед окончательным выходом продукта на рынок (релизом).
#
# Например, в известной компании «WarGaming» есть несколько групп тестирования:
#
# Отдел тестирования WarGaming — сотрудники компании, занимающиеся львиной долей всего тестирования того, или иного
# продукта. Качество любимых танчиков зависит от них, в большей степени;
# Участники «Супертест» — группа опытных игроков, помогающая разработчикам со сбором статистики, которая оставляет
# комментарии и предложения, а главное — способная оценить изменения свежим, «незамыленным» взглядом и обнаружить
# неочевидные ошибки.
# Несложно догадаться, отдел тестирования проводят альфа -тестирование, а «Супертест» участвуют в бета-тестировании.



# ---------------------------------------------------------------
# Task.
# Отметьте четыре главных уровня тестирования:

# - Модульное
# - Интеграционное
# - Системное
# - Приемочное



# -----------------------------------------------------------------
# Task.
# Выберите все синонимы компонентного тестирования:

# - Юнит (Юнит-тестирование)
# - Модуль (Модульное тестирование)



# -------------------------------------------------------------------
# Task.
# В качестве одного модуля (компонента, юнита) могут выступать:

# - Маленькая независимая часть (компонент) приложения



# --------------------------------------------------------------------
# Task.
#   На чем нужно быть сосредоточенным, проводя Интеграционное тестирование (Integration Testing)?

# - На тестировании взаимодействия модулей



# ---------------------------------------------------------------------
# Task.
# Системное тестирование (System testing) проводится сразу после:

# - Интеграционного



# ---------------------------------------------------------------------


# =====================================================================


# ======================= 2.8 Методы тестирования =====================

# --------------------------------------------------------------------
# ISTQB - Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.
#
# White, black и grey box тестирование или «тестирование белого» (прозрачного, открытого, стеклянного), «черного или
# серого» (полупрозрачного) ящика — это методы тестирования, направленные на определение доступа к внутренней
# системе ПО.
#
# Проще говоря мы, как тестировщики, при проверке продукта можем или не можем иметь доступ к его коду. Рассмотрим
# далее каждый из методов
#
# ------------ Метод черного ящика (black box) -----------------

# Тестирование черного ящика ( отсутствие доступа к коду )  — также известное как тестирование, основанное на
# спецификации или тестирование поведения — техника, основанная на работе исключительно с внешними интерфейсами системы.
#
# Согласно ISTQB, тестирование черного ящика — это:
#
# тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента
# или системы;
# тест-дизайн, основанный на технике черного ящика — процедура написания или выбора тест-кейсов на основе анализа
# функциональной или нефункциональной спецификации компонента, или системы без знания ее внутреннего устройства.
# Преимущества:
#
# тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и противоречия в
# спецификации;
# тестировщику нет необходимости обладать дополнительными знаниями в программировании;
# можно начинать писать тест-кейсы, как только готова спецификация.
# Недостатки:
#
# тестируется только очень ограниченное количество путей выполнения программы;
# без четкой спецификации (а это, скорее, реальность на многих проектах) достаточно трудно составить эффективные
# тест-кейсы;
# некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне модульного
# тестирования.
# Пример: обычный калькулятор. У нас нет доступа к внутренней системе, но мы можем предположить как пользователь будет
# им пользоваться и на основе этого произвести тестирование функций: отображение цифр при нажатии на кнопки, работу
# операторов(сложение, вычитание и т.д.), удаление результата и т.д.



# -------------------------------------------------------
# --------------- Метод белого ящика (white box) ----------------------------

# Тестирование белого ящика ( полный доступ к коду / сам писал код ) — метод тестирования ПО, который предполагает, что
# внутренняя структура/устройство/реализация системы известны тестировщику.
#
# Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Так же мы знаем, каким
# должен быть результат этой обработки.
#
# В данном случае тестируемая программа для тестировщика — прозрачный ящик, содержимое которого он прекрасно видит.
#
# Как правило, таким видом тестирования на проектах занимаются сами программисты, ведь для использования этого метода
# тестировщик должен обладать достаточно высокой квалификацией.
#
# Согласно ISTQB, тестирование белого ящика — это:
#
# тестирование, основанное на анализе внутренней структуры компонента или системы;
# тест-дизайн, основанный на технике белого ящика — процедура написания или выбора тест-кейсов на основе анализа
# внутреннего устройства системы или компонента.
# Преимущества:
#
# тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского интерфейса;
# можно провести более тщательное тестирование с покрытием большого количества путей выполнения программы.
# Недостатки:
#
# для выполнения тестирования белого ящика необходимо большое количество специальных знаний;
# упор делается на код, без учета позиции конечного пользователя, вследствие чего могут пропускаться баги.
# Пример: двигатель автомобиля. Для водителя (особенно начинающего) двигатель автомобиля - черный ящик. Но, для
# механика нет. Он, словно программист, понимает логику работы компонентов двигателя и знает его слабые места.



# -----------------------------------------------------------
# --------------------- Метод серого ящика (grey box) -------------------------------

# Тестирование серого ящика ( частичный доступ к коду ) — метод тестирования ПО, который предполагает
# комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно лишь частично.
#
# Преимущества:
#
# Тестирование серого ящика включает в себя плюсы тестирования «черного» и «белого». Другими словами, тестировщик
# смотрит на объект тестирования с позиции «черного» ящика, но при этом проводит анализ на основе тех данных, что он
# знает о системе;
# Тестировщик может проектировать и использовать более сложные сценарии тестирования;
# Предоставляет разработчику достаточно времени для исправления дефектов.
# Недостатки:
#
# Возможность анализа кода и тестового покрытия ограничена, так как доступ к исходному коду ограничен.
# Тесты могут быть избыточными в том случае, когда разработчик также проверяет свой код Unit-тестами.
# Пример: разработчик, проверяющий программу, методом черного ящика ИЛИ тестировщик, ознакомившийся с архитектурой
# программы, проверяющий программу, методом черного ящика. Оба понимают логику работы программы, но проверяют ее, с
# точки зрения пользователя.
#
# P.S.
# ISTQB относит тестирование методами белого и черного ящика к методам проектирования тестов. Поэтому, ни о
# каком «среднем» или «промежуточном» методе в этом случае конечно и речи быть не может. Мы либо разрабатываем тесты,
# зная код, либо не зная его. То есть в классификации ISTQB такого вида тестирования не существует.



# ------------------------------------------------------------------
# Task.
# Соотнесите методы тестирования с их определениями:

# Метод черного ящика : Тестирование, основанное на спецификации или тестирование поведения — техника, основанная на
# работе исключительно с внешними интерфейсами системы.

# Метод белого ящика : Метод тестирования ПО, который предполагает, что внутренняя структура/устройство/реализация
# системы известны тестировщику.

# Метод серого ящика : Метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов. То есть,
# внутреннее устройство программы нам известно лишь частично.



# --------------------------------------------------
# Task.
# Какой метод не описан в ISTQB?

# - Метод серого ящика



# --------------------------------------------------
# Task.
# Из представленных утверждений выберите верное:

# - Тестирование методами черного ящика более близко к поведению пользователя, чем остальные.



# -----------------------------------------------


# =================================================


# ===================== 2.9 Подходы к тестированию ================================

# ----------------------------------------------------------
# Рассмотрим подходы к тестированию по степени формализации:
#
# Формальность —  это «иметь общепризнанную форму, структуру или набор правил».
#
# 1.  Тестирование на основе тест-кейсов (виды тестовой документации будут рассмотрены в 3 разделе
# курса) — формализованный подход, в котором тестирование производится на основе заранее подготовленных тест- кейсов
# и иной документации.
#
# Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых для проверки
# реализации функционала тестируемого программного обеспечения (ПО) или какого-то его свойства.
#
# Эта информация включает в себя четкое описание действий, которые нужно выполнить, шаг за шагом. После выполнения
# действий нужно сравнить ожидаемый результат работы приложения с тем, который получен.
#
# Это самый распространенный способ тестирования, который также позволяет достичь максимальной полноты исследования
# продукта за счет строгой систематизации процесса.
#
# 2.  Исследовательское тестирование (Exploratory testing) — это частично формализованный подход тестирования ПО, при
# котором тестовые наборы не создаются заранее, а тестировщик проверяет приложение «на лету».
#
# Тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, дорабатывается в процессе
# выполнения с целью более полного исследования приложения.
#
# Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, а не как на
# бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию ты сначала разрабатываешь
# тестовые случаи, а затем исполняешь их. Исследовательское тестирование — это одновременный процесс разработки и
# выполнения тестов.
#
# В качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться чек-листы.
#
# Также в результате исследовательского тестирования могут появиться новые тест- кейсы. То есть мы можем выполнять
# исследовательское тестирование и с целью написания новых тест-кейсов.
#
# 3.  Свободное (интуитивное) тестирование (Ad Hoc Testing или Monkey Testing) полностью неформализованный подход, в
# котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев.
#
# Тестировщик полностью опирается на свою интуицию для спонтанного выполнения с продуктом действий, которые, как он
# считает, могут обнаружить ошибку.
#
# В прямом смысле — «куда хочу, туда и кликаю, в порядке каком хочу».
#
# Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует придерживаться
# при выполнении тестирования. Таким образом, метод не структурирован, и, следовательно, дефекты, обнаруженные с
# помощью этого метода, может быть труднее воспроизвести, но и вместе с этим возможно найти «Хитрые баги».
#
# В свою очередь Интуитивное тестирование подразделяется на 2 вида:
#
# buddy testing (совместное тестирование) — когда 2 человека, как правило разработчик + тестировщик, работают
# параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять
# необходимые проверки, а программисту фиксить баги на ранних этапах.
#
# pair testing (парное тестирование) —  когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру,
# один может искать дефекты, а второй —  их документировать.
#
# Используя различные подходы к тестированию, можно выбирать один или комбинацию подходов, для более глубокого и
# обширного тестирования. Какой именно подход выбирать — зависит от конкретного проекта и целей поставленных перед
# тестировщиком.



# ------------------------------------------------------
# Task.
# Что такое Исследовательское тестирование?

# - Методика тестирования ПО, при которой тестовые наборы не создаются заранее, а тестировщик проверяет
# приложение "на ходу"



# --------------------------------------------------------
# Task.
# Дано требование для валидации поля для введения пароля: Длина поля не должна превышать 5 символов. Можно использовать
# любые буквы латинского алфавита и числа. Поле не может быть пустым. Выберите возможные варианты валидного пароля:

# - 58R44
# - 65
# - 98765



# ---------------------------------------------------------
# Task.
# Укажите вариант для обозначения текста ошибки при авторизации пользователя при неверно введенном логине и/или
# пароле, который считается самым безопасным с точки зрения недопущения раскрытия этих данных злоумышленнику:

# - Пароль или логин введены неверно



# -----------------------------------------------------------


# ===========================================================



# ======================= 2.10 Виды тестирования ===================================

# ---------------------------------------------------------
# Стоит начать с того, что по критерию запуска программы тестирование делится на два типа: Статическое и Динамическое.
# Статическое тестирование (Static Testing) — тип тестирования, при котором код программы не исполняется во время
# проведения тестов.
#
# Статическое тестирование включает тестирование спецификации и прочей документации, файлов, либо тестирование и анализ
# программного кода (code review) или скомпилированного кода без его запуска. Может производиться как вручную, так и с
# помощью специальных инструментальных средств, т.е .автоматизировано.
#
# Код-ревью (code review) может выполняться одним из участников команды разработчиков или тестировщиком. Как
# правило, на код-ревью проверяются качество кода, стандарты использования, решения реализации, оставляются
# комментарии. Это помогает предотвратить дефект на начальном этапе.
#
# Динамическое  тестирование (Dynamic Testing) — тестирование, при котором выполняется код программы и проверяется
# поведение приложения во время работы. Тут происходит взаимодействие с интерфейсом запущенной программы, ее формами,
# сервером, базой данных и т.д.
#
# Если проводятся тесты на работающем приложении — значит, это динамические тесты.
#
# По степени автоматизации тестирование делится на Ручное и Автоматизированное.
# Ручное тестирование - это вид тестирования, при котором тестировщики вручную выполняют тесты без использования
# инструментов автоматизации.
#
# Каждое приложение должно быть протестировано вручную, прежде чем тесты можно будет автоматизировать. Это делается
# для того, чтобы определить, нужно ли вообще внедрять автоматизацию. Для проведения ручного тестирования необязательно
# владеть навыками использования какого-либо инструмента. Один из основных принципов тестирования заключается в
# том, что 100% автоматизация невозможна. Поэтому ручное тестирование неизбежно во всех проектах.
#
# Автоматизированное тестирование - это вид тестирования, при котором тесты проверяются автоматически с помощью
# специальных инструментов. Например, Selenium или Appium.
#
# Как только тесты автоматизированы, человек практически не принимает участие в выполнении тестов. Поэтому
# автоматизированное тестирование является эффективным видом тестирования. Цель автоматизации - сократить количество
# тестов, которые необходимо выполнять вручную, чтобы сократить время на тестирование.
#
# По ожидаемому поведению тестирование разделяется на:
# Позитивное тестирование (Positive Testing) — тестирование с применением сценариев, которые соответствуют ожидаемому
# поведению приложения.
#
# Позитивные тестовые сценарии проверяют, что приложение работает соответственно требованиям, если пользователь
# предоставляет допустимые, валидные данные или выполняет предусмотренные действия.
#
# Пример позитивного сценария: для Авторизации в системе уже зарегистрированного пользователя необходимо ввести
# существующий логин, правильный пароль, нажать кнопку «Войти». Ожидаемый результат — произошел вход в систему.
#
# Негативное тестирование (Negative Testing) — тестирование с применением сценариев, которые соответствуют внештатному
# поведению приложения.
#
# Негативные тестовые сценарии проверяют, как приложение справляется с данными, которые выходят за границы,
# предусмотренные требованиями, или неожиданными действиями пользователя.
#
# Пример негативного сценария: для Авторизации в системе уже зарегистрированного пользователя ввести несуществующий
# логин, или неправильный пароль, нажать кнопку «Войти». Ожидаемый результат – появляется сообщение о неправильности
# введенных данных.



# --------------------------------------------------
# По хронологии тестирование разделяют на:
# Дымовое тестирование (Smoke Testing) - включает в себя минимальный набор тестов на самые очевидные ошибки. Дымовое
# тестирование проверяет работоспособность критически важных функциональных частей приложения.
#
# Например, регистрация нового пользователя, создание нового заказа, выставление счета клиенту, получение оплаты. Это
# базовый функционал, который регулярно контролируется Smoke-тестами.
#
# Санитарное тестирование (Sanity Testing) — проводится после незначительных изменений в функционале, коде или починке
# багов. Проверяет, что исправленный код или новый функционал работает, как и ожидалось.
#
# Как пример, программисты устранили дефект на странице создания нового заказа. В этом случае санитарные тесты должны
# проверить общее состояние приложения и нацелены на то, чтобы избежать потерь времени и усилий, чтобы быстрее
# определить возможные недостатки ПО и их критичность, а также стоит ли переходить в фазу более тщательного
# тестирования. Обычно выполняется вручную.
#
# Регрессионное тестирование (Regression Testing) — тестирование приложения, направленное на обнаружение ошибок в уже
# проверенных участках программ (или исходных кодах). Помогает убедиться, что недавние изменения не сломали работающую
# функциональность приложения. Регрессионные тесты должны проводиться при любых изменениях кода, потому полная
# автоматизация — лучшая практика в этом типе тестирования.
#
# В регрессию включаются тесты, которые покрывают тестирование безопасности, критических и важных функций. Включаются
# те области, которые часто меняются в ходе разработки, где высока вероятность ошибки.
#
# Повторное тестирование (Retesting) — проводится после устранения дефекта в части функционала с целью подтверждения
# исправления ошибки.  Перепроверяет и подтверждает то, что ранее неудачные тест-кейсы успешно проходятся после
# того, как эти дефекты были исправлены. При этом используются те же самые тест-кейсы, которые выявили дефект — с
# использованием тех же данных, на том же окружении, но с различным набором входных данных.
#
# Тестирование делится также на Функциональное тестирование и Нефункциональное тестирование.
# Функциональное тестирование (Functional Testing) включает в себя тесты, оценивающие функции приложения. Функции
# системы — это то, «что» должна делать система.
#
# С помощью этого вида приложение проверяется на способность выполнять свои функции. Сюда входят: модульное,
# интеграционное, системное и приемочное тестирование. Кроме того, регрессионное и дымовое тестирования тоже являются
# подвидами функционального. Исполняется функциональное тестирование на основании требований в виде спецификаций или
# пользовательских историй.
#
# Нефункциональное тестирование (Non-functional Testing) оценивает характеристики систем и программного обеспечения,
# такие как надежность, производительность, удобство использования, эффективность работы или его безопасность.
# Нефункциональное тестирование — это проверка того, «насколько хорошо» ведет себя система.



# --------------------------------------------------------
# Рассмотрим Нефункционального тестирование подробнее:
#
# - Тестирование пользовательского интерфейса (User interface testing) — проверка соответствия интерфейса ПО требованиям
# дизайна. Например, проверка наличия всех требуемых элементов на странице, их размеров и расположения, тестирование
# шрифтов, цветов, изображений.
#
# - Тестирование удобства пользования (Usability Testing) — определение удобства использования приложения. Проверяется
# эргономичность интерфейсов. Например, оформление и графические элементы с точки зрения удобства восприятия, удобство
# навигации. В этот вид входит Тестирование доступности.
#
# - Тестирование Доступности (Accessibility Testing) — проверка доступности приложения для пользователей с нарушением
# слуха, зрения и цветовосприятия, а также людей, у которых нет возможности использовать клавиатуру. Например,
# использование определенной цветовой гаммы, добавление субтитров на видео или озвучивание всей страницы.
#
# - Тестирование производительности (Performance Testing) — тестирование скорости работы приложения под определённой
# нагрузкой.
#
# - Нагрузочное тестирование (Load testing) — данный тип тестирования позволяет оценить поведение системы при нормальных
# условиях и возрастающей нагрузке, целью нагрузочного тестирования является также определение максимальной нагрузки,
# которую может выдержать система. Например, мы рассчитываем, что одновременно приложением будет пользоваться 500
# пользователей, и через специальные программы (например Jmeter) создаются условия, которые моделируют использование
# приложения одновременно чуть менее 500 пользователями.
#
# - Стресс-тестирование (Stress testing) — используется для определения устойчивости системы или модуля при пороговых
# значениях рабочей нагрузки или за ее пределом. К примеру моделируются условия одновременного использования 500 или
# немногим более пользователей.
#
# - Объемное тестирование (Volume testing) — тестирование позволяет оценить производительность системы при увеличении
# объемов данных как самого приложения, так и его базы данных. Когда те же 500 пользователей отправляют одновременно
# какой-то объем информации.
#
# - Тестирование надежности  (Reliability Testing) — проверка работоспособности приложения при длительном тестировании
# с ожидаемым уровнем нагрузки.
#
# - Тестирование безопасности (Security Testing) — оценка уязвимости приложения к различным атакам. Оценка безопасности
# пользовательских данных, на сколько просто неавторизованный пользователь может получить доступ к системе или данным.
#
# - Тестирование установки  (Installation Testing) — проверка успешной инсталляции, настройки, обновления и удаления.
#
# - Тестирование совместимости (Compatibility Testing) — проверка корректной работы приложения в определенном окружении,
# например, устройстве, операционной системе (кроссплатформенное тестирование) или браузере (кроссбраузерное
# тестирование).
#
# - Тестирование на отказ и восстановление (Recovery Testing) — проверка насколько хорошо приложение может оправиться от
# аварий и сбоев оборудования.
#
# - Тестирование локализации (Localization Testing, l10n) — тестирования локализованной версии приложения: проверка
# правильности перевода интерфейса пользователя, системных сообщений и ошибок, раздела "Помощь"/"Справка",
# документации, контроль формата даты и времени.
#
# - Тестирование интернационализации (Internationalization Testing, i18n) — Насколько продукт может адаптироваться для
# той или иной локали при выходе на другие рынки. Например, возможность поддержки вертикального текста Азиатских
# стран, чтение справа налево в арабских странах.
#
# В целом, можно сказать, что нет строгой системы распределения по видам и типам тестирования. Есть «скелет», а
# остальные виды могут мигрировать.



# ----------------------------------------------------------------
# Task.
# Что такое нефункциональное тестирование?

# - Проверка того, "насколько хорошо" ведет себя система



# ----------------------------------------------------------------
# Task.
# К какому типу тестирования относятся модульное, интеграционное, системное, приемочное?

# - Функциональное



# ----------------------------------------------------------------
# Task.
# Дайте определение тестированию пользовательского интерфейса

# - Проверка соответствия интерфейса ПО требованиям дизайна



# ----------------------------------------------------------------
# Task.
# Выберите опции, которые необходимо проверить в рамках тестирования доступности

# - Соответствует ли звуковое воспроизведение информации, указанной в приложении
# - Удобны ли для восприятия цвета, используемые в приложении



# -----------------------------------------------------------------
# Task.
# Что такое стресс-тестирование?

# - Определение устойчивости системы или модуля при пороговых значениях рабочей нагрузки или за ее пределом



# -----------------------------------------------------------------
# Task.
# Какой вид тестирования отвечает за проверку работы базового/критичного функционала?

# - Дымовое



# ------------------------------------------------------------------
# Task.
# Что такое статическое тестирование?

# - Тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться



# ------------------------------------------------------------------
# Task.
# Выберите действия, которые относятся к статическому тестированию

# - Инспекция проектной документации
# - Анализ программного кода



# --------------------------------------------------------------------
# Task.
# На какие виды подразделяется тестирование по критерию запуска программы?

# - Статическое
# - Динамическое



# --------------------------------------------------------------------



# ====================================================================


# ======================================================================================================================
# 3. Планета артефактов
# ======================================================================================================================


# ================== 3.2 Спецификация и альтернативные источники ожидаемого результата ====================

# ----------------------------------------------------------------------------------------------------------------------
# Как мы выяснили, основная задача тестирования - это проверка ПО на соответствие между реальным поведением программы и
# её ожидаемым поведением на конечном наборе тестов, выбранных определенным образом. Ожидаемое поведение описывается в
# спецификации - это документ, описывающий реализацию программы в виде требований. Спецификация должна соответствовать
# следующим критериям:
#
# - Корректность — точное описание.
#
# - Проверяемость — описание требований таким образом, чтобы можно было однозначно понять, выполнено все в соответствии
# с требованиями или нет.
#
# - Полнота — в требовании должна содержаться вся необходимая информация для реализации.
#
# - Недвусмысленность — требование должно однозначно описываться.
#
# - Непротиворечивость — требования не должны противоречить другим требованиям и документам.
#
# - Приоритетность — у каждого требования должен быть приоритет, что позволит грамотно управлять ресурсами на проекте.
#
# - Атомарность — требование нельзя декомпозировать на отдельные части без потери деталей.
#
# - Модифицируемость — каждое требование можно изменить без потери цели требования.
#
# - Прослеживаемость — требование должно иметь уникальный идентификатор, по которому на него можно сослаться.


# Бывают ситуации, когда спецификация отсутствует. Помимо спецификации, есть и другие источники ожидаемого результата.
# Рассмотрим основные:
#
# 1) Общие требования к ПО на рынке:
#
# - Функциональная пригодность - программа должна решать заявленные задачи пользователя.
# - Надежность - программа должна работать стабильно, так как любой сбой потенциально приносит убытки.
# - Защищенность - программа должна сохранять пользовательские данные в безопасности.
# - Удобство использования - программа должна быть приятна и эффективна.

# 2) Гайдлайн - это руководство по использованию фирменного стиля, которое содержит инструкцию о том, как работать с
# элементами дизайна. Например, у iOS и Android есть свои гайдлайны.
#
# 3) Здравый смысл. Бывают баги и в самой спецификации, связанные с нерациональным использованием или реализацией
# определенной функциональности. В случае расхождения предполагаемой реализации функциональности со здравым
# смыслом, необходимо предложить улучшения продукта.
#
# 4) Конкуренты. Исследование конкурентов — постоянный процесс. Суть конкурентного анализа — всегда знать, куда движется
# рынок, что делают конкуренты, как меняются интересы аудитории. Результаты анализа нужно обновлять регулярно, раз в
# квартал или в год.



# -------------------------------------------------------------
# Пример спецификации

# https://disk.yandex.ru/i/rRvnCIMPdag-jw



# --------------------------------------------------------------



# ==============================================================



# ======================= 3.3 Тест-кейс =============================

# -------------------------------------------------------------------
# Тестовая документация — один из важнейших атрибутов в работе тестировщика. Мы расскажем вам, зачем она нужна и чем
# может быть полезна.


# Для чего нужна тестовая документация?

# В процессе тестирования любого продукта создается документация, которая помогает организовать работу отдела
# тестирования и держать всех членов команды в курсе дела. Такая документация создается до начала или в процессе
# тестирования. В хорошо оформленной документации любой член команды может найти всю необходимую информацию.


# Какая бывает документация?

# Наиболее распространенные документы, которые должен знать и уметь писать тестировщик уровня «джуниор» это:
#
# - тест-кейс;
# - чек-лист;
# - баг-репорт;
# - отчет о тестировании.



# ----------------------------------------------------------------------
# Что такое тест-кейс?
# Тест-кейс — это документ с описанными четкими действиями, которые нужно выполнить, чтобы проверить какую-либо функцию
# продукта. Эти действия направлены на проверку того, что функция работает должным образом и соответствует стандартам,
# и требованиям клиента.
#
# Простыми словами тест-кейс — это проверка получения ожидаемого результата. Тест-кейс «Проверить ввод отрицательных
# чисел в поле "Возраст"» означает, что нужно попробовать ввести отрицательные числа в указанное поле и в ответ,
# например, получить сообщение, что такие данные вводить недопустимо.
#
# Тест-кейсы, проверяющие одну функциональность, могут быть объединены в тест-сьюты (тест-наборы).
#
# Из чего состоит тест-кейс?
# Тест-кейс имеет определенный набор атрибутов. Некоторыми тестировщик пользуется регулярно, а какой-то частью он может
# не воспользоваться ни одного раза за всю свою карьеру. Все зависит от тестируемого продукта.
#
# 1. ID — обязательный атрибут. Это номер тест-кейса.
#
# Его используют для организации и навигации по всем тест-кейсам.
#
# Может создаваться как автоматически системой управления тестированием, в которой создается и будет
# храниться тест-кейс, так и вручную, если не используется такая система.
#
# Номер может быть представлен, например, в числовом виде: так - «345», или так - «1-45». Но может быть представлен в
# смешанном - «П-45», где буква обозначает какой-то функционал в продукте.
#
# Главное, чтобы эти номера были уникальные.
#
# 2. Заголовок (название) — обязательный атрибут.
#
# В заголовке отражается суть тест-кейса, то есть описывается что будет проверяться.
#
# Заголовок должен быть понятным, но и не сильно длинным.
#
# 3. Предусловия — необязательный атрибут.
#
# Здесь указываются действия, которые необходимо выполнить перед выполнением основных действий тест-кейса. Эти действия
# не имеют прямого отношения к проверке.
#
# Например, найти книгу на сайте может только зарегистрированный пользователь. Для того, чтобы выполнить тест-кейс
# проверки поиска, пользователь должен предварительно авторизоваться. То есть в предусловии необходимо указать, что
# пользователь должен быть зарегистрирован и  авторизован.
#
# Также здесь можно указать тестовые данные для авторизации, если эти данные не вынесены в отдельный документ.
#
# 4. Шаги — обязательный атрибут.
#
# В этом блоке описывается последовательность действий, которые необходимы для проверки.
#
# Последовательность нумеруется начиная с 1. Если шаг всего один, его принято не нумеровать.
#
# Действия должны быть описаны понятно.
#
# Должны использоваться безличные глаголы. Правильно: перейти, открыть, нажать. Неправильно: перейди, откройте, нажми.
#
# 5. Постусловия — необязательный атрибут.
#
# Аналогично блоку «Предусловия» в этом атрибуте указываются действия, не связанные с основной проверкой тест-кейса, но
# необходимые для возврата системы в исходное состояние.
#
# 6. Ожидаемый результат — обязательный атрибут.
#
# Здесь описывается результат, который ожидается получить в результате успешно выполненных действий из блока «Шаги».
#
# Ожидаемый результат может быть общим для всего тест-кейса.
#
# Но может быть и несколько, на каждый выполняемый шаг из блока «Шаги».
#
# 7. Требования к среде — необязательный атрибут.
#
# Тут можно указать специальное оборудование, программное обеспечение и т.д., которое будет необходимо для прохождения
# данного тест-кейса.
#
# 8. История редактирования — необязательный атрибут.
#
# Краткий журнал, в котором будет указываться кто, когда и почему внес изменения в тест-кейс.



# ----------------------------------------------------------------
# Примеры тест-кейсов.
# Давайте вместе с вами рассмотрим сайт, на котором публикуются рецепты приготовления блюд resept_test_site.ru (сайт
# выдуман).
#
# На данном сайте есть фильтр по дате публикации рецепта.


# Напишем проверки выборки рецептов за указанный период.


# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период (дата начала меньше даты окончания)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке «Фильтр» указать дату окончания периода, которая больше даты начала;
# 4) Нажать кнопку «Выбрать».

# Ожидаемый результат:
#
# На странице отображаются только рецепты, у которых дата публикации входит в указанный период.
#
#
#
# ID: Ф-2
#
# Заголовок: Проверить выбор рецептов за указанный период (даты равны)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке «Фильтр» указать дату окончания периода равную дате начала;
# 4) Нажать кнопку «Выбрать».

# Ожидаемый результат:
#
# На странице отображаются только рецепты, которые были опубликованы в указанный день.
#
#
#
# ID: Ф-3
#
# Заголовок: Проверить выбор рецептов за указанный период (дата начала больше даты окончания)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке Фильтр» указать дату окончания периода, которая меньше даты начала;
# 4) Нажать кнопку «Выбрать».

# Ожидаемый результат:
#
# На странице отображается сообщение о некорректности ввода дат.



# ---------------------------------------------------------------------
# «Ожидаемый результат» в тест-кейсе — один или много?
# В тест-кейсах может быть один или много ожидаемых результатов. Сколько их указать, решает сам автор. Главное, чтобы это было правильно и понятно оформлено.
#
# Для примера, перепишем тест-кейс Ф-1 с несколькими ожидаемыми результатами.
#
#
#
# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период (дата начала меньше даты окончания)
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# в прошлом относительно указанного периода;
# в текущем периоде;
# в будущем относительно указанного периода.
# №
#
# Шаги:
#
# Ожидаемый результат:
#
# 1
#
# Открыть главную страницу сайта.
#
# Главная страница сайта открыта.
#
# 2
#
# В блоке «Фильтр» указать дату начала периода.
#
# В поле отображается введенная дата.
#
# 3
#
# В блоке «Фильтр» указать дату окончания периода, которая больше даты начала.
#
# В поле отображается введенная дата.
#
# 4
#
# Нажать кнопку «Выбрать».
#
# На странице отображаются только рецепты, у которых дата публикации входит в указанный период.
#
# Если переписать наши тест-кейсы в таком виде и если вдруг что-то измениться в каком-либо результате, то придется исправлять данные во всех остальных тест-кейсах. Очевидно, что это займет много времени.
#
# Один из недостатков тест-кейсов — это много похожих тест-кейсов. Если присмотреться к приведенным примерам тест-кейсов Ф-1, Ф-2, Ф-3, то все действия в блоке «Шаги» скопированы и исправлены только даты.
#
# В таких случаях есть смысл переписать эти 3 тест-кейса в один, но с разными входными данными и несколькими ожидаемыми
# результатами.
#
#
#
# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:                                                                    Ожидаемый результат:
#
# 1) Открыть главную страницу сайта;                                       Главная страница сайта открыта.

# 2) В блоке «Фильтр» указать дату начала периода;                         В поле отображается введенная дата.

# 3) В блоке «Фильтр» указать дату окончания периода из таблицы данных;    В поле отображается введенная дата.

# 4) Нажать кнопку «Выбрать».                                              На странице отображаются только рецепты, у
#                                                                          которых дата публикации входит в указанный
#                                                                          период.


# Если переписать наши тест-кейсы в таком виде и если вдруг что-то измениться в каком-либо результате, то придется
# исправлять данные во всех остальных тест-кейсах. Очевидно, что это займет много времени.
#
# Один из недостатков тест-кейсов — это много похожих тест-кейсов. Если присмотреться к приведенным примерам
# тест-кейсов Ф-1, Ф-2, Ф-3, то все действия в блоке «Шаги» скопированы и исправлены только даты.
#
# В таких случаях есть смысл переписать эти 3 тест-кейса в один, но с разными входными данными и несколькими
# ожидаемыми результатами.


# ID: Ф-1
#
# Заголовок: Проверить выбор рецептов за указанный период
#
# Предусловие: В базе рецептов должны быть рецепты опубликованные:
#
# - в прошлом относительно указанного периода;
# - в текущем периоде;
# - в будущем относительно указанного периода.

# Шаги:
#
# 1) Открыть главную страницу сайта;
# 2) В блоке «Фильтр» указать дату начала периода;
# 3) В блоке «Фильтр» указать дату окончания периода из таблицы данных;
# 4) Нажать кнопку «Выбрать».


# Входные данные:                                                          Ожидаемый результат:
#
# 1) В блоке «Фильтр» указать дату окончания периода, которая больше       На странице отображаются только рецепты, у
# даты начала.                                                             которых дата публикации входит в указанный
#                                                                          период.

# 2) В блоке «Фильтр» указать дату окончания периода равную дате начала.   На странице отображаются только рецепты,
#                                                                          которые были опубликованы в указанный день.

# 3) В блоке Фильтр» указать дату окончания периода, которая меньше даты   На странице отображается сообщение об
# начала.                                                                  некорректности ввода дат.


# В таком виде избавляемся от большого количества копирования и трудностей поддержки уровня актуальности документации.
#
# ----------------- Инструменты для хранения тест-кейсов --------------------

# Для хранения тест-кейсов существуют системы управления тестирования (TMS - Test Management System).
#
# На сегодняшний день их довольно много. Есть как полностью бесплатные, так и платные, и каждая система имеет свои
# недостатки и преимущества.
#
# Вот несколько известных и популярных:
#
# - Azure DevOps
# - Test IT
# - TestRail
# - Qase
# - Allure TestOps
# - Zephyr Scale
# - Zephyr Squad
#
#
# Для первого знакомства с подобными системами можно попробовать создать тест-кейсы в бесплатном Testlink. Но, также
# можно организовать хранение тест-кейсов и в Гугл Таблице. Это будет менее удобно, но совсем бесплатно.
#
# Преимущества и недостатки тест-кейсов
# На тему преимущества и недостатков тест-кейсов на проекте ведется множество споров, написана куча статей.
#
# Давайте посмотрим, что же может быть записано в преимущество,  что в недостаток.


# Преимущества:
#
# - уже написанные тест-кейсы можно использовать для ознакомления новичков  с проектом, независимо от его опыта;
# - всегда можно посмотреть, как и что делать, если вдруг забыли (все мы живые люди, а не роботы);
# - Иногда приходится тестировать то, с чем не очень хорошо знакомы;
# - Существование тест-кейса (или кейсов) позволяет быстро вникнуть в то, что важно проверить. Так же при нехватке
# тестировщиков на проекте, можно привлечь коллегу из соседнего проекта в помощь.


# Недостатки:
#
# - много копирования одинаковой информации из тест-кейса в тест-кейс. Если пишутся тест-кейсы, например, на одно поле,
# то многие шаги будут повторяться;
# - сложность поддержки большого количества тест-кейсов. Например, изменение названия одной кнопки. Нужно будет найти
# все тест-кейсы где, есть старое название, и заменить его на новое. А если таких кнопок не одна и еще парочка полей?
# - неактуальные тест-кейсы. Если нет времени и  часть изменений не было внесено в тест-кейсы, то сотрудник, который уже
# давно на проекте, пройдет их как нужно. А вот для новичка это будет затруднительно.


# Для того чтобы документация помогала в работе, ее нужно поддерживать в актуальном состоянии и постоянно дорабатывать.
# Но, к сожалению, это отнимает много времени и сил. Релиз никто не отложит, потому что вы еще не поправили все нужные
# тест-кейсы или не дописали новые.
#
# -------------- Когда нужно использовать тест-кейсы? ------------------

# Но при наличии довольно существенных недостатков тест-кейсы в некоторых случаях буквально необходимы.
#
# Если тестируемый продукт жизненно важен и ошибки в нем могут привести к непоправимым последствиям. Например,
# медицина, ПО для атомных станций и т.д.:
# Если продукт очень сложный. Для того чтобы не вспоминать каждый раз как строится отчет, лучше зафиксировать это в
# тест-кейсе;
# Если у вас в команде идет постоянная ротация, то удобнее знакомить с продуктом с помощью прохождения тест-кейсов.

# --------------- P.S. ------------------

# 1. Тест-кейсы должны быть понятными и конкретными.
#
# Для проверки этого можно дать пройти их любому члену команды, который не знаком с продуктом.
#
# Этими тест-кейсами в дальнейшем придется пользоваться вашим коллегам. Если тест-кейс непонятен, то это плохой
# тест-кейс, а значит его надо переписывать.
#
# 2. Девиз для написания заголовка - «Кратко, но ёмко!». Из заголовка тест-кейса должно быть понятно какую проверку
# необходимо провести, не читая последовательность в блоке «Шаги». Можно использовать сайт http://bugred.ru/.
#
# 3. Девиз для тест-кейсов «Не доверяй, но проверяй». Для проверки необходимо подготовить тестовые данные, по которым
# можно точно сказать работает ли проверяемая функция или нет.



# ------------ Task. ----------------------
# Выбрать верное определение тест-кейса:

# - это документ, содержащий последовательность действий направленную на проверку какого-либо функционала, описывающий
# как прийти к ожидаемому результату.



# ----------- Task. ----------------------
# Правильно расположить атрибуты тест-кейса:

# - ID
# - Заголовок
# - Предусловие
# - Шаги
# - Постусловия
# - Ожидаемый результат
# - Требования к среде
# - История редактирования



# ------------------ Task. ---------------------------
# Выбрать верные утверждения для “хорошего тест-кейса”

# Тест-кейс должен быть понятным и конкретным



# ---------------- Task. ----------------------------
# Выбрать обязательные атрибуты тест-кейса:

# - Заголовок
# - Ожидаемый результат
# - Шаги
# - ID



# ----------------------------------------------------


# =====================================================



# ======================= 3.4 Чек-лист ==========================

# ---------------------------------------------------------------

# -------------- Что такое чек-лист, и чем он отличается от тест-кейса? ----------------

# Чек-лист — это список с кратким описанием того, что нужно проверить.
#
# Благодаря такому списку, процесс тестирования будет проходить более организованно, что уменьшает шансы что-то забыть.
#
# Чек-лист для тестирования — это как список продуктов, которые надо купить, написанный перед походом в магазин.
#
# В отличии от тест-кейсов, чек-листы используются для простых систем (например, интернет-магазин), где нет сложных
# процессов, которые необходимо документировать. Проще написать список проверок для нужных функций, чем писать
# полноценные тест-кейсы, а потом еще и поддерживать их в актуальном состоянии.
#
# Чек-листы могут быть разного уровня детализации. Уровень детализации будет зависеть от сложности продукта, от знаний
# сотрудников тестируемого продукта и требований к отчетности о его статусе.
#
# Чек-листы можно составлять как «верхнеуровневые» проверки, которые помогут выявить в каком блоке/разделе/направлении
# нужно будет двигаться для создания тест кейсов.
#
# ------------- Из чего состоит чек-лист? ----------------

# У чек-листа намного меньше атрибутов, чем у тест-кейса.
#
# 1) ID — обязательный атрибут. Номер чек-листа. Используется для организации и навигации по всем чек-листам. Номер
# чек-листа может отражать степень детализации и может быть представлен в таком виде «3.2.6»;
# 2) Описание проверки — обязательный атрибут. Краткое описание того, что должно быть проверено. Здесь так же
# применяется принцип краткости и информативности;
# 3) Пример — необязательный атрибут. Если используются специфические данные для проверки функционала, здесь можно
# указать их;
# 4) Окружение — необязательный атрибут. Указывается вся необходимая информация о сборке, устройствах, платформах
# и т.д., на которых должна проходить проверка;
# 5) Результат — обязательный атрибут. Здесь описывается результат, который ожидается получить в ходе успешной проверки.



# ----------------------------------------------------------------

# ------------------- Пример чек-листа ---------------------

# Разберем сайт с рецептами resept_test_site.ru. На нем есть фильтр по дате публикации рецепта.
#
# При тестировании новой версии нам важно не забыть проверить работу фильтра.
#
# 1 Проверить работу фильтра по дате публикации.              Выбираются статьи соответствующие указанным датам.
#
# Но данный фильтр у нас встречается в разных разделах сайта. Немного детализируем нашу проверку.

# 1. Проверить работу фильтра по дате публикации.

# 1.1. На «Главной» странице
# 1.2. В разделе «Авторы»                          Выбираются статьи соответствующие указанным датам.
# 1.3. В разделе «Рецепты»


# С такой детализаций уже будет трудно забыть проверить в других разделах. Этот чек-лист можно детализировать глубже,
# если есть необходимость.
#
# ------------------- Как составить хороший чек-лист? --------------------

# Для составления хорошего чек-листа есть несколько рекомендаций.
#
# 1. Один пункт — одно действие. Один пункт чек-листа должен представлять собой одну минимальную полную операцию.
#
# Чек-лист в таком виде «Проверить работу фильтра на «Главной» странице, в разделе «Авторы» и «Рецепты» лучше не
# использовать;
#
# 2. В названиях пунктов чек-листа используйте принципы, общие для всех членов команды. Например, использовать глаголы
# в инфинитиве «проверить», «отправить», или существительные «проверка», «добавление»;
#
# 3. Понятные и конкретные формулировки. При прохождении чек-листа тестировщик не должен вспоминать, что имелось в
# виду. Если такая ситуация повторяется неоднократно, то стоит подумать про изменение формулировки описания проверки;
#
# 4. В зависимости от сложности функционала детализируйте чек-лист;
#
# 5. Объединяйте чек-листы в таблицы. В таблицах можно добавить столбцы с дополнительными данными (платформа, версия
# продукта, сотрудник и т.п.) и статус проверки.



# ------------- Инструменты для хранения чек-листов -----------------------

# Для хранения и прохождения чек-листов есть инструменты, как и для тест-кейсов.
#
# Список нескольких популярных:
#
# - TestRail, TestLink — и прочие системы управления тестированием;
# - Jira;
# - Trello;
# - Гугл Таблицы — при правильной настройке, можно сделать довольно удобную систему прохождения чек-листов и сбора
# информации для отчетности. Главное преимущество — это бесплатно;
# - Sitechco — бесплатная программа, в которой можно попрактиковаться в создании и прохождении чек-листов.

# ----------------------- Преимущества и недостатки чек-листов -------------------------------

# Как и у тест-кейсов, так и у чек-листов есть свои плюсы и минусы.


# Преимущества:
#
# - проверка в одну строку легко читается и не долго пишется;
# - проходить чек-листы быстрее: в тест-кейсе нужно отмечать прохождение каждого шага, а в чек-листе достаточно одной
# строки;
# - статус прохождения чек-листа это источник результатов для отчета: можно быстро посчитать сколько проверок
# выполнено, и в каком они статусе, узнать количество открытых репортов;
# - легко можно поменять порядок проверок, если это необходимо;
# - так как одни и те же проверки разные люди могут проходить по-разному, то в некоторой степени можно избавиться
# от «эффекта пестицида».


# Недостатки:
#
# - каждый тестировщик выполняет проверки чек-листа по-своему;
# - недостаточность детализации;
# - для обучения новых сотрудников не подходит: проверки описывают то, что нужно сделать, без привязки к интерфейсу.


# Чек-листы хорошо использовать на начальном этапе тестирования. Накидать начальный список проверок и потом, при
# необходимости, детализировать займет не так много времени, как написание полноценных тест-кейсов.
#
# Также можно использовать смешанную документацию. Для простого функционала чек-листы, а для более сложного
# полноценные тест-кейсы.



# ------------------- Task. --------------------------
# Верно ли, что чек-лист — это список того, что должно быть проверено?

# - Да



# --------------------- Task. -----------------------------------
# Правильно расположить атрибуты чек-листа:

# - ID
# - Описание проверки
# - Пример
# - Окружение
# - Результат



# ------------------------------- Task ---------------------------------------------
# Выбрать обязательные атрибуты чек-листа:

# - ID
# - Описание проверки
# - Результат



# ------------------------------------------------------------------------


# ==================================================================


# ============================ 3.5 Баг-репорт ==============================

# --------------------------------------------------------------------------
# В процессе тестирования продукта могут обнаруживаться ошибки, о которых должны узнать разработчики, чтобы их
# исправить. Но информацию о существующей ошибке надо донести в удобном и понятном виде. Для этого используют
# баг-репорт. Это еще один документ, который составляется тестировщиком.
#
# ---------------------- Что такое баг-репорт? ----------------------
# Баг-репорт - это документ, в котором описана последовательность шагов, приводящая к неверному поведению функционала,
# а также описан ожидаемый результат.
#
# Вернемся к нашему сайту с рецептами. На сайте есть фильтр, с помощью которого мы можем выбрать опубликованные рецепты
# за определенный промежуток времени.
#
# Мы хотим увидеть все рецепты за 2021 год.
#
# Вводим данные и нажимаем кнопку “Выбрать”.


# И видим результат выборки: пусто.
#
# Очевидно, что фильтр работает неверно. Мы ожидали получить список рецептов за 2021 год, но не получили нужного нам
# результата.
#
# Для того, чтобы сообщить об этой ошибке, в работе фильтра необходимо написать баг-репорт. Так, в нем нужно описать
# действия, которые привели к ошибке, указать, в чем состоит ошибка и что ожидалось.
#
# ----------------- Из чего состоит баг-репорт? ------------------------

# У баг-репорта, как и у всех документов рассмотренных ранее, есть атрибуты. Часть из них обязательна для заполнения,
# часть - не обязательна.
#
# 1) ID — обязательный атрибут. Это номер баг-репорта. В большинстве случаев, автоматически создается баг-трекинговой
# системой.
# 2) Заголовок — обязательный атрибут. С помощью одного предложения описывается суть бага. Для написания заголовка
# используют вопросы “Что? Где? Когда?”. Эти вопросы помогают написать понятный для всех членов команды заголовок, не
# слишком длинный, но отражающий суть бага.
# 3) Шаги  — обязательный атрибут. Здесь описывается последовательность действий, которые необходимо выполнить для
# воспроизведения бага. На этом этапе указывается минимум необходимых действий.
# 4) Фактический результат — обязательный атрибут. Описывается полученный результат после выполнения описанных шагов.
# 5) Ожидаемый результат — обязательный атрибут. Описывается результат, который мы ожидали увидеть после выполнения
# указанных шагов.
# 6) Серьезность — обязательный атрибут. Указывается уровень серьезности бага и насколько это критично влияет на общую
# функциональность тестируемого продукта.
# 7) Приоритет — необязательный атрибут. Указывается очередность исправления бага.
# 8) Скриншот или видео — обязательный атрибут. Видео или скриншот должны четко демонстрировать баг. Можно сделать
# выделение бага, сделать короткие поясняющие надписи, если это необходимо.
# 9) Тип бага — необязательный атрибут. Исходя из этой информации, можно составить отчет и провести анализ о слабых
# местах в продукте, чтобы потом их исправить.
# 10) Статус — необязательный атрибут. Указывается статус бага в его “жизненном цикле”.
# 11) Требование — необязательный атрибут. Указывается ссылка на требование, в котором прописано ожидаемое поведение.
# При наличии такого документа, можно избежать споров (если возникнут) баг или фича.
# 12) Дополнительная информация — необязательный атрибут. Дополнительной информацией может быть файл с тестовыми
# данными,данные для авторизации (тестовый логин и пароль) и т.д.
# 13) Окружение — необязательный атрибут. Если нужно, то можно указать версию браузера, операционную систему и т.д.
# 14) Автор — необязательный атрибут. Указывается тестировщик, который обнаружил и создал баг-репорт. У разработчиков
# могут возникнуть дополнительные вопросы и так будет понятно, к кому надо обратиться.
# 15) Исполнитель — необязательный атрибут. Указывается человек, который продолжит работу над исправлением бага.
# 16) Версия обнаружения — необязательный атрибут. Указывается версия продукта, в которой был обнаружен баг.
# 17) Комментарии — необязательный атрибут. В комментариях происходит обсуждение бага после создания баг-репорта.


# ---------------- Серьезность и приоритет -------------------------

# Прежде чем оформить наш баг-репорт на найденную ошибку на сайте, рассмотрим подробнее несколько моментов:
#
# какие бывают степени “серьезности” и “приоритета”,
# что такое “жизненный цикл” бага и какие есть статусы.
# Для уровней серьезности бага нет единых стандартов. Количество и названия отличаются в разных компаниях. Рассмотрим
# один из используемых набором уровней.
#
# - Блокирующий (Blocker) —  этот уровень выставляется, когда из-за описанного бага продукт совсем не работает.
# Например, на нашем сайте с рецептами открывается главная страница и зависает, не реагирует на клики и другие действия.

# - Критический (Critical) — этот уровень указывается, когда описанный баг влияет на главный  функционал. Например, для
# нашего сайта критическим функционалом будет создание и публикация рецепта. Если у пользователей не будет возможности
# создавать и публиковать свои рецепты, то он может уйти на другой работающий сайт.

# - Серьезный (Major) — этот уровень выставляется, когда баг создает неудобства, но не влияет на критический функционал.
# Например, у вновь созданного и опубликованного рецепта не появляется плашка “Новый”.

# - Незначительный (Minor) — этот уровень указывается для бага, который не влияет на “логику” приложения. Чаще всего это
# баги, возникающие при верстке, локализации и т.д. Например, цвет шрифта всех кнопок должен быть темно-синий (согласно
# макету), а разработчики забыли про одну кнопку и сделали ее с зеленым шрифтом.

# - Тривиальный (Trivial) — баги этого уровня не влияют на работу и качество продукта. Такие баги не исправляют
# специально, а обычно делают правку в ходе реализации функционала, который находится рядом. Например, на нашем сайте в
# футере отображается прошедший год.

# Серьезность в баг-репорте выставляет тестировщик. А вот приоритет выставляется руководителем или менеджером проекта.
#
# Уровни приоритета также могут различаться в разных компаниях.
#
# - Высокий (High) —  баг с таким статусом, будет исправляться в первую очередь.
# - Средний (Medium) —  баг будет исправляться после всех багов с высоким статусом.
# - Низкий (Low) —  баг будет исправляться в последнюю очередь, когда все ошибки более высокого приоритета будут
# исправлены.



# ------------------------------ Жизненный цикл -----------------------------------
# “Жизненный цикл” бага —  это последовательность этапов, которые проходит баг-репорт с момента его создания до
# окончательного закрытия.
#
# Нагляднее этот цикл отображать в виде блок-схемы, на которой отображается статус, как можно к нему перейти и на что
# может быть изменен.
#
# В разных компаниях может быть разный жизненный цикл. Это связано с использованием разных систем баг-трекинга. В
# одних —  этапы цикла уже настроены и их нельзя изменить, а в других —  предоставляется возможность настройки “под
# себя”, если это необходимо.


#  Рассмотрим немного подробнее каждый этап.
#
# - Новый — баг найден и при создании баг-репорта в системе, этот статус устанавливается автоматически.
# - Отклонен — если баг был уже ранее внесен или не будет правиться по каким-либо причинам или не воспроизводится
# больше, то руководителем команды может быть выставлен данный статус. Далее можно или переоткрыть (с новыми
# доказательствами и доводами, что это баг), или закрыть.
# - Открыт — устанавливается после проверки руководителем и принятия решения об исправлении. Может быть переведен в
# статус Отсрочен, Исправлен или Отклонен.
# - Отсрочен — если нет необходимости исправлять данный баг в данной итерации. В последующих итерациях может быть
# переведен в Открыт или Закрыт.
# - Исправлен — статус выставляется после исправления бага разработчиком и перевода его на проверку тестировщику. Может
# быть Повторно открыт или Закрыт.
# - Повторно открыт — статус означает, что при проверке исправления, проблема все еще воспроизводится. Можно перевести
# в статус Исправлен, Отсрочен или Отклонен.
# - Закрыт - баг исправлен и не воспроизводится.



# ------------------- Пример баг-репорта ------------------------------
# № 1. Нет данных в результате выборки фильтра при указании данных за год
#
# Статус: Новый
#
# Окружение: Win 10, Google Chrome Версия 100.0.4896.75 (Официальная сборка), (64 бит)
#
# Серьезность: Серьезный (Major)
#
# Предусловие: в базе должны быть созданы рецепты до 2021 г, в 2021 г и после 2021 г.
#
# Шаги:
# 1) Открыть главную страницу: resept_test_site.ru.
# 2) В блоке “Фильтр” заполнить поля дат значениями: “01.01.2021”, “31.12.2021”.
# 3) Нажать кнопку “Выбрать”.
#
# Ожидаемый результат:
# Пользователь видит результат выборки - все рецепты созданные за 2021 г.
#
# Фактический результат:
# Пользователь видит пустой результат выборки - нет ни одного рецепта.
#
# Cкрин_ошибки.jpg


# В приведенном примере Ожидаемый результат написан первым, а затем Фактический результат. Но может быть и наоборот.
#
# Чаще всего пишут сначала Фактический результат, а потом Ожидаемый, т.к. наша задача описать проблему и такой порядок
# читается логичнее и проще для усвоения.
#
# Но когда на проекте добавляется очень много данных в блок Дополнительная информация, логично описать Ожидаемый
# результат, Фактический результат и к нему Дополнительная информация.
#
# Все! Наш баг описан и его можно передавать разработчикам. Но, на самом деле, есть еще один важный момент перед тем
# как передавать его разработчикам — локализовать проблему.


# ----------------------- Локализация --------------------------------

# В чем же будет состоять локализация нашего бага?
#
# - Хорошо было бы выяснить, проблема только с 2021 годом или с остальными тоже есть сложности?
# - А есть ли проблема с другими периодами (день, неделя, месяц и т.д.), то есть работает ли вообще фильтр по датам?
# - А если ввести только одну дату для фильтра?
# - Такой баг во всех заявленных для тестирования браузерах?
# - Фильтр так работает на всех страницах, где присутствует или это только на главной странице сайта?


# Это приблизительный список вопросов, ответы на которые помогут понять, где проблема:
#
# - это 2021 год проблемный;
# - возможно, фильтр не работает совсем;
# - визуально кнопки фильтра могут быть одинаковые на всех страницах сайта, но на главной может отличаться реализация и
# вот она как раз и сломалась.


# После локализации, возможно придется отредактировать баг-репорт или вообще переписать его.  Поэтому лучше найти
# границы проблемы до написания баг-репорта.


# ------------------------- Инструменты для управления дефектами ----------------------------
# Чаще всего можно услышать название для таких инструментов как “баг-трекинговая система”.
#
# Такие системы используются в процессе разработки продукта, для документации багов, а также предложений для
# улучшения. В этих системах удобно получать данные  для анализа о процессе исправления ошибок и выполненных улучшений.
#
# Список из наиболее известных:
#
# - Atlassian JIRA
# - Redmine
# - Mantis


# Для тренировки можно воспользоваться Гугл Таблицей.



# ----------------------------------------------------------------------------

# ------------------ Алгоритм написания --------------------------

# - Проверить, что баг воспроизводится 2-3 раза;
# - Локализовать проблему;
# - Проверить, что вы не создадите дубликат в системе управления дефектами;
# - Написать заголовок (должен отвечать на вопросы “что? где? когда?”);
# - Заполнить обязательные поля отчета;
# - Заполнить необходимые необязательные поля отчета;
# - Перечитать баг-репорт;
# - Пройти написанные шаги и проверить, что все понятно, ссылки корректны;
# - Сохранить отчет;
# - Назначить отчет либо на разработчика функционала, либо на руководителя.


# --------------------------- Частые ошибки начинающих тестировщиков -----------------------------
# - В заголовке не используется правило трех вопросов;
# - Присутствует лишняя информация в заголовке (окружения, учетные данные пользователей, версия и т.д.);
# - Нет шагов для воспроизведения бага;
# - Описано слишком много лишних шагов для воспроизведения;
# - Пропущено описание фактического и / или ожидаемого результата;
# - Нет обоснования почему это баг;
# - Отсутствует скриншот / видео бага или на нем нет фиксации бага.



# ---------------- Task. ----------------------
# В логотипе указано неправильное название компании. Какой уровень приоритета будет у этого бага?

# - High



# ------------------ Task. ---------------------------
# В логотипе указано неправильное название компании. Какой уровень серьезности будет у этого бага?

# - Trivial



# ------------------- Task. -----------------------------
# Выбрать обязательные атрибуты баг-репорта:

# - Серьезность
# - Скриншот или видео
# - ID
# - Шаги
# - Ожидаемый результат
# - Фактический результат
# - Заголовок



# -----------------------------------------------------------------------


# ========================================================================


# ========================== 3.6 Отчет по тестированию ==================================

# ---------------------------------------------------------------------------------------
# И вот, наконец, тест-кейсы или чек-листы написаны на новую функциональность, тестирование завершено, баг-репорты
# созданы в баг-трекинговых системах и переданы разработчикам. Теперь можно спокойно попить чай, но есть еще один
# документ, который пишут тестировщики по окончании процесса тестирования — это отчет о результатах тестирования. Этот
# документ помогает провести анализ результатов как промежуточного, так и финального тестирования.
#
# Не все компании практикуют написание отчета, не везде этот документ имеет обязательный характер. Но иметь хотя бы
# минимальное представление о том, что такое отчет о результатах, было бы полезно.


# ------------------- Что такое отчет о  результатах тестирования? -----------------------------

# Отчет о тестировании — это документ, который содержит описание процесса тестирования, общую информацию о том, что
# было протестировано за отчетный период, результаты тестирования и данные, которые необходимы для оценки текущего
# или финального состояния продукта.
#
# Представленная таким образом информация должна помочь заинтересованным лицам в проекте увидеть полную и объективную
# картину о качестве программного продукта.
#
# Отчет создается по расписанию, которое оговаривается в команде. Это может быть как календарная привязка (раз в
# неделю), так и привязка к окончанию тестирования билда или функциональности.


# ---------------- Содержание отчета о тестировании -------------------

# Отчет составляется по шаблону предоставленному заказчиком. Если же шаблона нет, а отчет нужен, то можно
# придерживаться следующего списка:
#
# 1) Информация о проекте — краткое описание содержания отчета. Например, название проекта, тестируемая версия и т.д.;
#
# 2) Команда тестировщиков — список людей, которые задействованы в тестировании. Если был один человек, то можно
# опустить этот пункт;
#
# 3) Описание процесса тестирования — какие использовались техники, методы и инструменты;
#
# 4) Краткое описание результатов — что было протестировано (версия, номер сборки); что тормозит процесс тестирования
# (критичные дефекты, недоработанная функциональность, пробелы в требованиях);
#
# 5) Расписание — временные сроки тестирования функционала;
#
# 6) Статистика по багам — баги, обнаруженные за отчетный период, степень их важности и срочности.
#
# 7) Список новых багов — список багов, впервые обнаруженных в данном отчетном периоде.
#
# 8) Список устраненных дефектов — список багов, исправленных разработчиками в отчетном периоде.
#
# 9) Рекомендации — выводы по результатам тестирования и рекомендации по повышению его эффективности в будущем.
#
# 10) Приложения — графики, таблицы, диаграммы, демонстрирующие числовые характеристики процесса тестирования.



# --------------------------------------------------------------------------------
# Пример отчета
# https://disk.yandex.ru/i/Rl4R2AyeGccvlg



# =================================================================================



# ======================== 4.2 Зачем "дизайн" тестировщику? ======================================

# --------------------------------------------------------------

# ------------------- Что такое тест дизайн? -----------------------

# Если говорить формально, то тест-дизайн — это процесс создания тестов. Каждый тест предназначен для проверки
# определенного предположения.
#
# Задача специалиста — найти баланс и выявить максимальное количество ошибок при необходимом минимуме тестовых
# сценариев. При этом нужно проверить все наиболее важные кейсы, поскольку время тестирования ограничено.
#
# Например, если нам необходимо протестировать калькулятор: сколько же может быть проверок?
#
# Целые и дробные числа, положительные и отрицательные… Это все надо сложить, разделить, возвести в степень и тд.
# Здесь не хватит времени, а чем быстрее продукт готов к релизу, тем быстрее компания начнет зарабатывать деньги.
#
# Именно тут нам на помощь приходят техники тест-дизайна.
#
# - Классы эквивалентности;
# - Граничные значения;
# - Попарное тестирование;
# - Диаграмма состояния и переходов;
# - Таблица принятия решений.

# Более подробно основные техники мы будем рассматривать в следующих уроках.
#
# Но будем помнить о том, что они часто используются в комплексе. Недостаточно одной техники, потому что она не сможет
# обеспечить максимальный охват тестового сценария.
#
# Разумеется, этот список далеко не полон и дает только самое общее представление о принципах тестирования и техниках
# тест-дизайна.
#
# Например, исчерпывающее тестирование, покрывающее все возможные сценарии и обнаруживающее все ошибки, существует
# только в теории, а на практике это невозможно. Это связано с тем, что проверка всех параметров и состояний займет
# слишком много времени (вспомним пример с калькулятором).
#
# Однако, чем опытнее специалист, тем лучших результатов он может добиться, и для этого важно уметь правильно подбирать
# и комбинировать техники.
#
# Здесь можно вспомнить еще одну из техник тест дизайна: предугадывание ошибок.
#
# Предугадывание ошибок — это способ предотвращения ошибок, дефектов и отказов, основанный на знаниях тестировщика,
# включающих:
#
# - Историю работы приложения в прошлом;
# - Наиболее вероятные типы дефектов, допускаемых при разработке;
# - Типы дефектов, которые были обнаружены в схожих приложениях

# Эта техника всегда идет в комбинации с какой-то другой (только пользуясь предугадыванием качественного тестирования
# не будет), а также с большим опытом тестировщика плюс отличное знание тестируемого продукта.
#
# Также, стоит упомянуть прием "4 действия с объектом". Например, нам необходимо протестировать объект "Пользователь"
# в социальной сети:
#
# - Создание аккаунта;
# - Просмотр страницы аккаунта;
# - Редактирование информации аккаунта;
# - Удаление аккаунта.



# ----------------------- Task. ---------------------------
# Что такое тест-дизайн?

# - Это планирование и проектирование тест-кейсов согласно критериям качества, требованиям к проекту и целям
# тестирования



# ----------------------------------------------------------------
# Как вы думаете в чем заключается суть следующих техник тест-дизайна?
#
# Классы эквивалентности - классы смежных тест кейсов, которые можно объеденить;
# Граничные значения - это значения, в которых один класс эквивалентности переходит в другой;
# Попарное тестирование- тестирование все возможных комбинаций;
# Причина и следствие - тестирование вида запрос - ответ;
# Таблица принятия решений - список тест-кейсов для полного тестирования.


# Общий мотив: выловить максимум критичных багов при минимальном количестве тестов. Для первых двух техник это
# абсолютно справедливо.
#
# У попарного тестирования есть глубокая основа, которая не всем очевидна, лучше сразу обратиться к классике Lee
# Copeland: "Почему попарное тестирование так хорошо работает? Неизвестно. Здесь нет "физики ПО", лежащей в основе,
# которая требует этого. Одна из гипотез заключается в том, что большинство дефектов являются либо
# одиночными (тестируемая функция просто не работает и любой тест на эту функцию найдет дефект), либо двойными (это
# пара из функции/модуля, с которыми функция/модуль проваливаются, хотя все остальные пары выполняются успешно)."
# Попарное тестирование сокращает количество возможных комбинаций параметров в разы, но не стоит этим злоупотреблять
# когда тестируется оплата (то, с чего бизнес получает доход), в данном случае нужно перебрать абсолютно все возможные
# варианты.
#
# Причина/следствие и таблица принятия решений - это по сути логика работы приложения, упрощенная в наглядных схемах,
# которая позволяет хорошо видеть как должно и как не должно работать приложение.



# -------------------------------------------------------------


# ============================================================



# ======================== 4.3 Классы эквивалентности и граничные значения ===========================

# ---------------- Классы эквивалентности и граничные значения ---------------------------

# Классы эквивалентности — это разделение функциональности системы или обрабатываемых  данных на определенные группы
# значений (диапазоны), с которыми тестируемое приложение должно обрабатывать данные одинаково.
#
# Лучше всего разобрать это утверждение на примере.
#
# В данном уроке мы будем рассматривать минимальное количество проверок, исключая большое количество негативных и
# расширенных (например, дробный возраст и т.д.). Мы это делаем для более пристального внимания к примерам, касающихся
# урока.
#
# Предположим, у нас есть сайт винного магазина. Нам необходимо протестировать, что лиц, возрастом до 18 лет сайт не
# пускает, в то время как для пользователей с 18 (включая 18) доступ открыт.
#
# Чтобы проверить данный интервал, необходимо будет провести проверки возраста от 0 до 18 (это вроде не сильно много),
# с 18 сайт должен пускать. И тут уже проверок гораздо больше от 18 и как минимум до 100.
#
# Ну в принципе всего 100 раз ввести число и нажать кнопку — это не должно быть трудно, но представим, что на этом
# сайте еще и скидка при покупке от 3000 р.
#
# То есть сначала 100 проверок на возраст, а потом всего 3000 (если без копеек) проверок для теста отсутствия скидок,
# ну и до бесконечности проверок, что наш покупатель получит свою скидку в 10 %.
#
# Теперь понятно почему на собеседованиях спрашивают: как вы относитесь к монотонной работе?
#
# Именно для этого и существуют эквивалентные значения. Исходя из нашей задачи, мы можем определить 2 группы
# эквивалентных значений для наших проверок:
#
# Возраст:
#
# 0-17
# 18- ∞

# Так как данные внутри этих групп эквиваленты, нам нет смысла проверять их все. Нам достаточно проверить, что хотя бы
# 1 значение из группы работает корректно.
#
# То есть из бесконечного количества проверок мы делаем всего 4:
#
# - Проверяем любое значение от 0-17. Например, 9;
# - Проверяем любое значение от 18-100. Например, 55;
# - Проверяем отрицательные значения. Возраст не может быть отрицательным;
# - Проверяем дробные значения. Возраст не может быть дробным (по ТЗ от разработчиков сайта).

#
# Граничные значения — это значения, в которых один класс эквивалентности переходит в другой диапазон. .
#
# Разберем на уже знакомом примере.  Если мы визуально изобразим классы (промежутки значений), которые мы проверили
# ранее, то увидим, что у нас есть точки вне проверки. Именно эти точки и являются граничными значениями. То есть в
# наш список добавляем две проверки на 0 и на 18.
#
# Путем долгого наблюдения за разработкой и анализа багов, специалисты пришли к выводу, что большинство ошибок
# возникает именно на границах между классами эквивалентности. То есть нам, в первую очередь, важно проверить переходы
# на стыке границ каждого класса, так как именно там велик риск возникновения ошибок.
#
#
#
# На каждой границе диапазона следует проверить по три значения:
#
# - граничное;
# - шаг внутрь границ;
# - шаг за границы.
#
# Теперь смотрим на наш график и понимаем, что необходимо проверить:

# В итоге благодаря технике тест-дизайна классы эквивалентности и граничные значения мы получаем вместо 100+ проверок
# всего 10.



# ----------------------- Task. -------------------------------------
# Необходимо выбрать классы эквивалентности для тестирования формы возраста для покупки GTA 5:

# - 0-17
# - 18-∞



# ------------------ Task. -----------------------------------
# Необходимо выбрать граничные значения для тестирования формы возраста для покупки GTA 5:

# - 17
# - 18
# - 19



# -------------------------------------------------------------



# ==============================================================



# ============================== 4.4 Попарное тестирование ===================================

# ---------------------------------------------------------------
# --------------- Попарное тестирование --------------------------

# Попарное тестирование (Pairwise Testing) — техника тест-дизайна, при которой тестовые сценарии разрабатываются таким
# образом, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.
#
# Данная техника тест-дизайна нужна, чтобы сразу продумать, что и как проверять, а потом тратить намного меньше времени
# на исполнение и поиск багов, сокращать общее количество тест-кейсов, тем самым уменьшая время и расходы, затраченные
# на тестирование.
#
# Этот метод был придуман после многих лет наблюдений за багами, так сказать. Было замечено, что большинство дефектов
# вызвано взаимодействием не более двух факторов (дефекты, которые возникают при взаимодействии трех и более факторов,
# как правило, менее критичны) и нет никакого смысла проверять все возможные комбинации значений для всех факторов.
# Поэтому создается подмножество комбинаций, чтобы удовлетворить все факторы.
#
# Метод попарного тестирования очень полезен при разработке тестов для приложений, включающих несколько параметров.
# Тесты разработаны таким образом, что для каждой пары входных параметров системы существуют всевозможные комбинации
# этих параметров. Набор тестов охватывает все комбинации, не является исчерпывающим, но очень эффективен для поиска
# ошибок.
#
# Рассмотрим попарное тестирование на примере приложения «Музыка», которое:
#
# - работает на iOS и Android;
# - имеет два режима громкости: «Низкая» и «Высокая»;
# - имеет две скорости воспроизведения: «Нормальная» и «Ускоренная».

# Для того чтобы получить все возможные комбинации, создадим таблицу:

# №      ОС     Громкость      Скорость

# 1     IOS     Низкая         Нормальная
# 2     IOS     Низкая         Ускоренная
# 3     IOS     Высокая        Нормальная
# 4     IOS     Высокая        Ускоренная
# 5    Android  Низкая         Нормальная
# 6    Android  Низкая         Ускоренная
# 7    Android  Высокая        Нормальная
# 8    Android  Высокая        Ускоренная


# Для упрощения минимизации количества тест-кейсов необходимо сделать так, чтобы два любых столбика (в нашем случае это
# параметры ОС, Громкость и Скорость) содержали в себе все возможные комбинации только один раз:


# №      ОС     Громкость      Скорость

# 1     IOS     Низкая         Нормальная
# 2     IOS     Высокая        Ускоренная
# 3    Android  Низкая         Ускоренная
# 4    Android  Высокая        Нормальная


# Как видно, если брать попарно любые 2 столбика с параметрами, то в таблице есть все возможные комбинации и нет
# необходимости проверять 8 тест-кейсов вместо 4.
#
# На сайте https://www.pairwise.org/tools  представлены все инструменты, которые помогут качественно и быстро создать
# тест-кейсы из большого количества параметров. Самые популярные  из них:
#
# - PICT – Попарное независимое комбинаторное тестирование от Microsoft Corp.;
# - IBM FoCuS – Единое решение для функционального покрытия от IBM;
# - ACTS – Расширенная комбинаторная система тестирования от NIST, агентства правительства США;
# - Hexawise;
# - Jenny;
# - Pairwise от Inductive AS;
# - VPTag – бесплатный инструмент попарного тестирования



# -------------------------- Task. ---------------------------------------
# Какую методику вы примените в случае большого количества входных параметров с целью уменьшить возможное количество
# тестовых наборов и получить максимальную уверенность в качестве ПО?

# - Попарное тестирование (Pairwise Testing)



# ------------------------- Task. --------------------------------------------
# Выберите подходящий формат для адреса электронной почты

# - test_523@mail.ru
# - test-523@mail.ru



# ------------------------------------------------------------


# ============================================================


# ===================4.5 Диаграмма состояния и переходов ===============================

# -----------------------------------------------------------------------------------
# Диаграмма состояния и переходов — это техника для визуализации ТЗ. Эта диаграмма наглядно показывает, как некий
# объект системы переходит из одного состояния в другое. Переход от одного состояния к другому обычно чем-то
# обусловлен, например, каким-нибудь действием над объектом.
#
# Пример.
#
# У вас есть мессенджер со следующими функциями:
#
# Сразу после получения сообщения чат помечается как непрочитанный.
#
# Когда пользователь нажимает на чат, чтобы открыть его содержимое, чат помечается как прочитанный.
#
# Пользователь может пометить ранее прочитанный чат как непрочитанный.
#
# Пользователи могут удалять чаты (как прочитанные, так и непрочитанные), при этом чаты не могут быть восстановлены
# после их удаления.


# Сначала нарисуем диаграмму процесса:

# Потом напишем контекст таблицы:

# Напоследок, заполним таблицу:
#
# - Зеленый цвет - возможные переходы.
# - Красный - невозможные переходы.
# - Черный - главная диагональ.


# Итак, вы видите, что всего необходимо протестировать шесть сценариев - четыре положительных и два отрицательных.
#
# ------------ Инструменты для создания диаграмм: -------------------
# - miro
# - draw.io
# - XMind
# - MindJet
# - Mindmanager
# - Mindmeister
# - FreeMind



# ------------------------------- Task. ------------------------------------------
# Для какой задачи можно применить технику "Диаграмма состояния и переходов"?

# - Тестирование статуса заказа товара



# -----------------------------------------------------------------------------


# =============================================================================



# ============================= 4.6 Таблица принятия решений ====================================

# -------------------------------------------------------------------------------------
# ---------------- Таблицы принятия решений -------------------

# Знаете ли вы, что такое комбинаторика и как ей пользоваться? Если да, то вы — красавчики, и нам понадобится лишь
# небольшая часть ваших знаний. Если же нет, то не переживайте, мы пробежимся по самым-самым верхам, чтобы у вас
# появилось представление. И конечно, сходим в википедию.
#
# Комбинато́рика (иногда называемая комбинаторным анализом) — раздел математики, посвященный решению задач, связанных с
# выбором и расположением элементов некоторого (чаще всего конечного) множества в соответствии с заданными правилами.
#
# Итак, у нас есть конечное множество, то есть, говоря по-простому, несколько штук чего-то. Чего конкретно, не столько
# важно: яблок, бананов, машин или людей. Просто конечное множество — сколько-то штук, причём мы знаем, сколько именно.
# И нам из этого количества штук надо либо выбрать несколько, либо расположить их в нужном порядке.
#
# «В соответствии с заданными правилами» — что это значит? Представьте, что нам дали несколько штук чего-то, а еще дали
# правило, по которому их надо выбрать или расположить. Звучит не так уж и сложно, но всё же немного непонятно, как
# именно это делается. Давайте рассмотрим простой пример:
#
# В классе учится 16 мальчиков и 10 девочек. Сколькими способами можно назначить одного дежурного?
#
# Формулировка вопроса интуитивно понятна. Есть конечное множество (26 детей), есть применяемое к нему
# правило (назначить дежурного). Здесь мы подключаем эрудицию, бытовой опыт, космические силы и понимаем, что
# «назначить одного дежурного» означает «выбрать одного ребёнка». Сколько разных детей можно выбрать из 26?
#
# У нас есть 26 детей, из них одного дежурного можно назначить 26 способами. Разными способами. Как только попробуем
# назначить 27-ым способом, повторим один из предыдущих 26-ти (назначим ребёнка, которого уже назначали).



# ----------------------- Task. ------------------------------
# Попробуйте самостоятельно решить более сложную задачу.
#
# Есть два шестигранных кубика (грани пронумерованы): черный и белый. Сколькими способами можно выбросить результат,
# бросая их вместе?


# - 36



# ---------------------------------------------------------------
# Итак, таблица принятия решений состоит из возможных условий (входных данных, ввода), правил (сочетания входных
# данных) и действий, определяемых правилами.
#
# Знакомая терминология, не правда ли?
#
# Рассмотрим простейший пример ввода пароля. Пароль может быть либо верным, либо неверным — нам дано два условия.
# Соответственно, при вводе верного пароля пользователь получит доступ, а при вводе неверного пароля — не получит
# доступ. Так, мы получаем условие «правильность пароля» (верный/неверный) и действия «дать доступ» и «не дать доступ».
#
# Условие
# Правильность пароля	Пароль верный	Пароль неверный
# Действие
# Дать доступ	            Да 	              Нет


# «Да» и «Нет» здесь заменяют «дать доступ» и «не дать доступ», позволяя сократить строки с действиями до одной. Также
# можно использовать и другие обозначения, например, 1 и 0, или Y и N от английских Yes и No, или T и F от True и
# False — ваш выбор.
#
# Таблица выглядит всё ещё не очень интересно. К тому же, в ней только условие и действие, а правила-то где? Правилами
# мы назвали сочетания условий, а какими могут быть сочетания, если условие только одно? Правильно, никакими. А давайте
# добавим второй пароль! Вот такая у нас система: сначала надо ввести один пароль, потом второй пароль, и только потом
# система даёт доступ. Очевидно, у второго пароля условие то же самое — верный/неверный.
#
# Но пароль уже другой, поэтому его надо вынести отдельно. Плюс должны появиться правила. А правила — это сочетания
# условий. Поэтому мы вынесем возможные сочетания в таблицу. Для удобства используем «1» и «0» — для обозначения
# положительного и отрицательного результата (верный/неверный, дать/не дать).


# Условия	               Правило 1	Правило 2	Правило 3	Правило 4
# Правильность пароля №1	   1	        1	        0	        0
# Правильность пароля №2	   1	        0	        1	        0
# Действие
# Дать доступ	               1	        0	        0	        0


# Красивое. И наглядное. Давайте попробуем расписать текстом то, что мы видим в таблице. Спойлер: получится муторно и нечитабельно.
#
# Правило 1: если пароль 1 верный и пароль 2 верный дать доступ.
#
# Правило 2: если пароль 1 верный, а пароль 2 неверный не давать доступ.
#
# Правило 3: если пароль 1 неверный, а пароль 2 верный не давать доступ.
#
# Правило 4: если пароль 1 неверный и пароль 2 неверный не давать доступ.
#
# Представьте, что вам нужно проверить эти правила, сверяясь с документацией. Куда удобнее смотреть — в таблицу или в
# текст? Большинству в таблицу. К тому же, это в нашем примере условия тривиальные, а правила очевидные. А представьте,
# что вам нужно протестировать схожее поведение в системе, правила которой абсолютно неинтуитивные и взяты из
# написанной сухим языком документации.



# ------------------------------------------------------------------------
# --------------- Практическое задание --------------------------------
# Составление таблицы принятия решений - не самая тривиальная и распространенная задача, в связи с чем реализовать её
# проверку с помощью интерфейса платформы нам не удалось. Возможно, в будущем мы это исправим, а сейчас правильный
# ответ на подобные задания приложен в виде ссылки на таблицу, с которой можно свериться для проверки своего решения.
# Приносим извинения за неудобства.
#
# Мы должны протестировать автоматизированную систему контроля результатов медицинских анализов. Задача системы в том,
# чтобы по результатам нескольких анализов одного пациента определять его либо здоровым, либо больным. Пациент сдаёт 3
# анализа, результат каждого может быть определён как норма или патология (не норма). Пациенты без патологий или одной
# патологией в анализах определяются системой как здоровые, с двумя или тремя патологиями — больные.
#
# Составьте таблицу принятия решений данной системой (анализы обозначьте анализ 1, анализ 2, анализ 3 или по
# собственному желанию)


# Условия	 Пациент 1	Пациент 2	Пациент 3	Пациент 4  Пациент 4   П 5    П 6   П 7
# Анализ 1	   1	        1	        0	        1         1         0      0     0
# Анализ 2	   1	        1	        1	        0         0         1      0     0
# Анализ 3	   1	        0	        1	        1         0         0      1     0
# Действие
# Здоров?      1	        1	        1	        1         0         0      0     0


# ответ: https://docs.google.com/document/d/1bTdoy21s14aIEjUSc1GvUciDEpsQpCYgR57gAZJ17oU/edit

# ----------------------------------------------------------------------------
# Давайте рассмотрим на конкретном примере, как применять правила из наших таблиц.
#
# Начнем с того, что не только условий, но и действий может быть много, гораздо больше 1 или 2. Возьмем систему с двумя
# паролями из предыдущего урока. Давайте предположим, что если пользователь ввел неверный первый пароль, то вводить
# второй ему уже не дают — сразу же отказывают в доступе. Таким образом, у нас добавляется новое действие, назовём
# его: Ввести пароль №2.


# Теперь на основе этой таблицы нужно протестировать систему. Каждое правило — это набор шагов с ожидаемым результатом.
# Ввели в систему сочетание условий (правил), получили результат, сравнили с ожидаемым результатом (действиями).
#
# Но, если подумать, то 4 теста для проверки нам будет много. Давайте рассуждать логически: как только пользователь
# ввел неверный пароль №1, ему тут же не дают вводить пароль №2. То есть Правило 3 и Правило 4 при реальных проверках
# дадут один и тот же результат. Так, до ввода пароля №2 дело не дойдёт. Давайте изменим формулировки и распишем нужные
# проверки.


# Шаги	                           Тест 1	Тест 2	Тест 3
# Пароль №1 введён правильно	      1	       1	  0
# Пароль №2 введён правильно	      1	       0
# Ожидаемые результаты
# Появилось поле ввода пароля №2	  1	       1	  0
# Пользователю дан доступ	          1	       0	  0


# Вот мы и увидели, как на основе таблицы решений составлять тесты.


# ----------------------------------------------------------------------
# ----------------- Практическое задание -------------------------
# Мы говорили о том, что и условий, и действий может быть много. В нашем случае легко представить, что добавился третий
# пароль, а за ним четвертый, пятый и т. д. Но давайте всё же выйдем из этой плоскости. Предположим, что в нашей
# системе есть пароль суперадмина, который надо вводить в качестве первого пароля, тогда без ввода второго пользователю
# будет дан доступ в систему. И более того, доступ будет с правами суперадмина.
#
# Составьте полную (содержащую невозможные в реальности сочетания условий) таблицу решений для такой ситуации. Для
# целей задачи считать, что доступ суперадмина дается только при сочетании условий «Первый пароль введён правильно»
# и «Введён пароль суперадмина».
#
# Правильный ответ: Таблица пароль суперадмина
# https://docs.google.com/document/d/1wtnNixzG4aIz8IyQpuIfSgzEh5wqMOmLcHtU4Teg2pg/edit



# -------------------------------------------------------------------------------
# Пожалуй, таблицы решений уже изучены нами вдоль и поперёк. Осталось добавить лишь пару мелких нюансов, способных
# сделать их применение ещё более удобным.
#
# Начнём с того, что таблица решений — лишь один из инструментов, и она необязательно должна использоваться всегда и
# везде. Любой инструмент приспособлен для выполнения одних задач и не очень полезен для других.
#
# Таблицу решений удобно применять в тех случаях, когда поведение системы определяется несколькими параметрами, у
# каждого из которых может быть несколько значений. Как только видите множественные формулировки типа: «если A такое,
# а B вот такое, то C, иначе D», «при A больше стольки и B меньше стольки происходит C, в обратном случае D» — это тот
# случай, когда вам пригодится навык создания таблиц решений.
#
# Количество сочетаний (количество правил, количество столбцов/ширина таблицы) определяется перемножением количества
# возможных вариантов каждого параметра.
#
# Помните задачу с двумя кубиками, где мы получили, что общее количество сочетаний равно 36? Аналогично в примере с
# суммами перевода (3 варианта) и статусами клиентов (тоже 3 варианта). Итоговое количество правил оказалось равным 9.
# Если у нас есть 3 параметра, у первого из которых два возможных значения, у второго три, а у третьего четыре, то
# количество правило будет равно 2×3×4 = 24. Сразу можно задать нужную ширину таблице, чтобы не пропустить правило.
#
# Любую таблицу решений можно представить в виде бинарных параметров, но далеко не всегда это удобно. Использование
# конкретных значений каждого условия повышает читаемость таблицы.
#
# Разные правила могут приводить к одному и тому же действию (сочетанию действий), но это далеко не всегда означает,
# что при тестировании какое-то правило можно пропустить, как в нашем примере с двумя паролями. К подобным моментам
# всегда важно подходить аккуратно и с особой тщательностью, чтобы не «отрезать лишнего».
#
# Итак, мы закончили изучать таблицы решений. Впереди много практики, которая сделает из вас настоящих мастеров
# составления таблиц решений, удачи!



# -------------------------------------------------------------------------------------
# ------------------- Практическое задание ----------------------------
# Задание 1
#
# В стране N действует прогрессивная ставка подоходного налога. Если налогоплательщик зарабатывает менее 25 000 в год,
# его доход облагается по ставке 5%, если от 25 000 до 75 000, то по ставке 10%, если более 75 000, то 20%. При этом
# налоговая ставка изменяется в зависимости от отрасли, в которой работает налогоплательщик: торговля увеличивает
# ставку на 2 процента, сельское хозяйство уменьшает на 1 процент, здравоохранение уменьшает на 3 процента. Остальные
# отрасли не меняют ставку налога.


# Составить таблицу решений.
#
# Правильный ответ: Таблица подоходный налог
# https://docs.google.com/document/d/1H-acYy8pw6yQLsV1zdLbAH1rnGQboB7yt9rdOOgqykM/edit


# ------------------- Практическое задание ----------------------------
# Задание 2.
#
# Составьте таблицу решений для результатов броска двух трехгранных кубиков (на каждом кубике можно выбросить
# цифры 1, 2, 3). Результатом броска считается выброшенная сумма.
#
# Правильный ответ Таблица трёхгранные кубики
# https://docs.google.com/document/d/1u9bo2T10Kpo3yBNJBA47cKmahInuDXN8__eO-v4RxhM/edit



# ------------------- Практическое задание ----------------------------
# Задание 3.
#
# При регистрации на сайте пароль обязательно должен содержать цифры и большие буквы. В противном случае пользователю
# показывается сообщение с просьбой изменить пароль. Если в пароле содержится хотя бы один спецсимвол, пользователю
# показывается сообщение, что использование спецсимволов в паролях — отличное решение. Составьте таблицу решений.
#
# Правильный ответ Таблица символы в пароле
# https://docs.google.com/document/d/1MaUpZZ09GgkjmM307tewwg5ONkG1YdLWKc8ZkLKY1y4/edit



# -------------------------------------------------------------------------


# =========================================================================



# ======================================================================================================================
# 5. Планета фронтенда
# ======================================================================================================================


# ======================= 5.2 Тестирование дизайна на примере DevTools и PixelPerfect =====================

# --------------------------------------------------------
# Что такое тестирование дизайна. Тестирование дизайна в широком смысле
# Как мы уже упоминали ранее, дизайном в разработке программного обеспечения называют внешний вид программы, т.е. то,
# что видит и с чем взаимодействует пользователь. Не так важно, говорим мы о сайте, мобильном приложении или отдельной
# программе. Вопросы в духе «Как лучше изобразить управляющие кнопки?», «Где  уместно расположить кнопку главного
# меню?», «Какая цветовая гамма более привлекательна для пользователя?» актуальны всегда.
#
# В зависимости от целей, для которых разрабатывается программа, ответы могут быть самыми разными. Например,
# профессиональное ПО всегда выглядит более аскетично, чем программное обеспечение, рассчитанное на массового
# пользователя, т.к. внешний вид в нем приносится в жертву функциональности - никаких ярких эффектов и анимаций,
# главное — эффективность и результат.
#
# Под тестированием дизайна можно понимать два процесса. Первый — внесение корректив со стороны отдела тестирования на
# этапе разработки дизайна, второй — проверка на соответствие внешнего вида приложения макетам. Обычно, говоря о
# тестировании дизайна, подразумевают второй вариант, однако вкратце рассмотреть первый все же стоит.
#
# На этапе планирования, когда только-только обсуждается каким будет будущее приложение, дизайнер рисует его макеты,
# которые впоследствии должны пройти согласование. Кем именно они будут согласовываться — зависит от конкретной
# компании и проекта. В том случае, если на обсуждение макетов приглашают тестировщиков (довольно редкая практика), в
# их задачи войдет оценка уровня удобства использования приложения.
#
# Вполне возможно, что команда разработки закопается в нюансы реализации интерфейса, а дизайнер будет делать прежде
# всего красиво. Именно в этот момент тестирование должно встать и сказать что-то в духе «Ребята, анимация главного
# меню на 10 секунд — это просто потрясающе, но пользователю понадобится просмотреть ее трижды, прежде чем он сможет
# перейти к оформлению заказа. Мы точно хотим этого? Большинство людей сбежит, так ничего и не оформив».
#
# Однако, чаще всего, когда вы слышите «тестирование дизайна», подразумевается, что надо открыть ваш продукт и
# проверить, насколько он похож на согласованные кем-то другим когда-то давно макеты. И похож он должен быть на
# все 100%, не меньше. Можно еще назвать такое тестирование дизайна тестированием верстки, и о нем мы поговорим
# поподробнее.



# --------------------------------------------------------------------------
# Тестирование дизайна как тестирование верстки
# Итак, у нас есть макет, а как он выглядит? Очевидно, что это некий рисунок, но не на бумаге же? Неужели просто
# картинка, которая каким-нибудь .jpeg файлом лежит на вашем диске? Нет-нет, так мы максимум можем сказать, что в
# принципе похоже получилось, а нам надо быть уверенными в стопроцентном совпадении реализации с макетом. Конечно, макет
# можно сохранить в виде картинки и использовать, например, в презентации для обсуждения. Но для проверки нам надо
# знать размер шрифтов, цвета элементов (и не просто «красный» или «зеленый», а точный оттенок в rgb или hex формате),
# толщину линий и т.д. и т.п. При чем хотелось бы иметь всю информацию об элементе, просто наведя на него указатель
# мыши. В этом помогают графические редакторы.
#
# Для создания макетов используются графические редакторы и до недавнего времени довольно распространенным решением
# был Adobe Photoshop. Функционал всем известного фотошопа (здесь и далее название некоторых программ будет писаться
# по-русски) позволяет без проблем отрисовать страницы/экраны. Проблема заключается в том, что фотошоп не заточен под
# создание именно макетов, это универсальный инструмент для создания графики, поэтому он умеет все, но кое-где может
# быть не так удобен для выполнения конкретных задач. На платформе Apple используется Sketch, но не всем он может
# подойти из-за отсутствия на других платформах.
#
# Наиболее распространенным инструментом на данный момент является Figma, поэтому «как оно работает» мы рассмотрим
# именно на ее примере. Если же вам в работе встретится другой инструмент, вы уже будете понимать, зачем он нужен и
# сможете быстро вникнуть в работу с ним. Сразу оговоримся, что нашей задачей не является написать полный гайд по
# Фигме (таких гайдов можно нагуглить сколько угодно) или подробно рассмотреть ее функционал. Мы максимально коротко
# покажем популярный инструмент, чтобы словосочетание «тестирование дизайна» не вызывало у вас ступора.
#
# Итак, Фигма. Доступна как онлайн, так и десктопным приложением. Как правило, тестировщику приложение не требуется
# (разве что вам удобнее работать именно через него), достаточно просто пройти по ссылке на проект. В этом, кстати,
# заключается главное удобство - благодаря «облачности» сервиса работа команды упрощается, т.к. всегда известно где
# лежат актуальные макеты. Выглядит страничка проекта в браузере вот так.


# На картинке высокохудожественно выделены 4 области страницы. Верхняя панель 1 позволяет добавлять элементы, надписи и
# комментарии, включает элементы управления проектом в целом. Для легкости восприятия пропустим 2 и сразу посмотрим
# на 3 — здесь расположены сразу все макеты, что может поначалу сильно удивить. Перемещение к конкретному макету
# осуществляется обыкновенным зумом. Вернемся к левой панели, обозначенной 2 — на ней в иерархическом виде
# представлены все макеты. В связи с тем, что область, в которой они расположены, одна, каждый макет представляет
# собой родительский элемент (более правильно в данном случае элементы называть фреймами), в который входят дочерние.
#
# Такая иерархия сохраняется у всех фреймов. Например, представим себе макет страницы интернет-магазина. У
# родительского фрейма «страница» (главный элемент макета) есть дочерний фрейм «главная панель», являющийся
# родительским элементом для фрейма кнопки «корзина». Подобную иерархию можно увидеть на панели 2. Очень удобно,
# например, для перемещения целого элемента в процессе создания дизайна. Так, можно перенести сразу целиком кнопку,
# вместе с тенями и надписью на ней. Но это нужно дизайнерам, а не тестировщикам. Мы ничего не двигаем, мы только
# смотрим. И помогает нам в этом правая панель 4. Кликнув по элементу (в данном случае кнопка «Продолжить»), мы сможем
# увидеть его характеристики именно на панели 4.


# На данном скриншоте мы видим размеры кнопки, ее расположение относительно левого верхнего угла экрана, цвет, ширину
# границ. В самом низу Фигма предлагает даже готовый CSS-код для этого элемента (при желании можно получить код
# для iOS или Android, но нам все это не нужно). При наведении мыши на другие фреймы можно увидеть расстояние между
# ними и выделенным фреймом.


# Теперь у нас есть понимание, что такое макет, как он выглядит и как с ним можно взаимодействовать. Это здорово, но
# помимо данных с макета нам потребуются данные об имеющейся реализации и помочь нам в этом должны инструменты
# тестирования дизайна.
#
# P.S.
# «Не могу не упомянуть такую штуку как прототип! Современные инструменты создания дизайна, в том числе фигма,
# позволяют делать «связки» между макетами через конкретные элементы. То есть, когда вы укажете, что при клике по
# объекту экрана 1 «кнопка Регистрация/Вход» следует показать экран 2, в режиме прототипа кнопка станет интерактивной
# и начнёт реагировать на клик - очень наглядно для демонстрации работы приложения».



# -----------------------------------------------------------------------------

# ------------------- Инструменты тестирования дизайна --------------------------
# И здесь мы начнем с очередного дисклеймера о том, что задачей данного урока является общее описание инструментов и
# принципов тестирования дизайна, а не подробное руководство по тестированию. Конкретные инструменты могут отличаться
# в зависимости от платформы и требований проекта, но общее понимание, как они работают, помогут вам быстро влиться в
# процесс тестирования.
#
# Итак, у нас есть макет и данные с него. У нас есть приложение в браузере/на компьютере/на телефоне. Как их
# сопоставить. Упомянем самый очевидный способ — смотрим на макет и на реализацию, визуально подмечаем разницу,
# проверяем. С помощью этого способа вы вряд ли заметите, что толщина определенной линии составляет 6 пикселей вместо
# задуманных 5. Но вот то, что кнопка «Продолжить» зеленая, а не красная и вообще уехала с середины куда-то вправо,
# приклеившись к краю — легко. Разумеется, все грубые ошибки вылавливаются  именно этим способом, но что делать с более
# тонкими моментами (те самые 6 пикселей)? Здесь нам и помогут инструменты тестирования дизайна.
#
# Всю информацию можно взять из кода проекта. К примеру, можно использовать встроенный в браузер
# инструмент Devtools(нажмите F12 или FN и F12, чтобы открыть его), отображающий всю информацию о каждом элементе
# страницы на вкладках Elements и Styles.


# Здесь мы можем увидеть размеры элемента, его границы, отступы, используемые шрифты. Однако, это уж очень точечный
# инструмент, который позволяет скорее посмотреть характеристики проблемного элемента уже после его нахождения, чем
# найти его.
#
# Пожалуй, самым мощным инструментом для нахождения несоответствий страницы макету является PerfectPixel —
# устанавливается в качестве расширения для браузера, после чего позволяет на готовую страницу наложить полупрозрачный
# макет. Все несоответствия сразу будут видны.


# Размеры элементов или расстояние между ними можно измерить расширениями-линейками, быстро определить шрифты,
# цвета, проверить орфографию на странице также можно отдельными расширениями. В случае веб-приложений вообще на любой
# случай жизни советуем сначала поискать расширение — наверняка с вашей проблемой кто-то столкнулся ранее и уже решил
# ее.
#
# Отдельно отметим адаптивность верстки. На сегодняшний день существует огромное количество гаджетов, способных
# отображать ваше приложение — десктопы, ноутбуки, планшеты, телефоны. Разумеется, страница должна хорошо смотреться
# и сохранять функциональность на большинстве из них, подстраиваясь (адаптируясь) к используемому разрешению экрана.
# Пропустить можно разве что совсем экзотические разрешения, встречающиеся крайне редко. Для этого можно
# воспользоваться как встроенным инструментом в Devtools, так и найти расширение-resizer, которое позволит
# просматривать страницу в заданном разрешении.
#
# Если же мы говорим о мобильном или десктопном приложении, принцип решения проблем не меняется, только вместо поиска
# по расширениям следует обратиться с соответствующим запросом к поисковику. Говоря в целом, умение гуглить — чуть ли
# не главный навык в IT, не стоит им пренебрегать. Ну и, наконец, ситуации, когда неопытного новичка оставляют один на
# один с проблемой, крайне редки — не стесняйтесь просить помощи у более опытных коллег.



# --------------------- Task. ----------------------------------------
# Выбери верное утверждение. Тестирование дизайна это:

# - Проверка на соответствие внешнего вида приложения макетам



# -------------------- Task. ----------------------------------------
# Попиксельное сравнение...

# - Показывает несоответствия с макетом



# ------------------------------------------------------------------------------------------


# =========================================================================================


# ================================== 5.3 Тестирование элементов интерфейса ===============================

# ------------------------------------------------------------------------------

# -------------------- Элементы интерфейса ---------------------------

# Когда мы открываем какой-либо сайт или интернет-приложение, то видим кнопки, ссылки, раскрывающиеся меню, поля ввода
# и еще много других элементов -  все они составляют графический интерфейс сайта.
#
# Для начала рассмотрим общую структуру страницы:
#
# - header (или «шапка»);
# - контентная часть;
# - footer (или подвал).

# Блок шапки располагается в самом вверху страницы. От типа контента сайта зависит, что будет располагаться в этом
# блоке. Обычно отображают контакты, логотипы (эмблемы, лозунги, девизы и т.д.), верхнее меню (для помощи в навигации
# пользователя), картинки или группы картинок (слайдеры).
#
# Далее следует контентная часть сайта. В этом блоке указывается подробная информация о владельце сайта, бизнесе или
# организации. Эта информация может быть представлена в виде текста (например, о бренде, который представлен на сайте),
# галерей с очень популярными товарами или новинками и т.д. Самое главное, чтобы посетителям было понятно, о чем ваш
# сайт или как можно заказать / купить товар.
#
# Подвал —  это самая нижняя часть сайта. В этом блоке располагают меню со ссылками на все важные страницы (так
# называемая карта сайта), включая те ссылки, которые не представлены в шапке. Также указывается адрес, номер
# мобильного телефона и другая контактная информация, то есть все данные для связи с клиентами.  Присутствует блок
# ссылок на социальные сети —  списком или в виде миниатюрных иконок.
#
# Во всех частях сайта используются одни и те же элементы графического интерфейса.
#
# Кнопки, поля ввода, ссылки, изображения, блоки текста, радиобаттоны, чекбоксы, выпадающие и раскрывающиеся списки,
# календари и еще много других веб-элементов. Рассмотрим подробнее эти элементы.


# -------------------------------------------------------------------
# ------- Кнопка ---------------
# При нажатии на этот элемент происходит какое-то действие на сайте.
#
# При тестировании кнопки необходимо обратить внимание на:
#
# - расположение относительно других элементов;
# - размер кнопки;
# - цвет фона и шрифта;
# - название кнопки соответствует логике или макету (если есть);
# - доступность, что кнопку можно нажать всегда или при определенных условиях;
# - после нажатия есть определенный результат.

# Для примера рассмотрим кнопку “Найти” рядом с поисковой строкой в любом браузере.


# Пройдемся по нашему чек-листу тестирования:
#
# - расположение относительно других элементов должно соответствовать макету или здравому смыслу - кнопка расположена
# рядом с поисковой строкой;
# - размер кнопки должен соответствовать макету или здравому смыслу - кнопка расположена рядом с поисковой строкой,
# одной высоты;
# - цвет фона и шрифта - должно соответствовать макету или здравому смыслу -  цвет фона и шрифта подобраны так, что
# надпись хорошо читаема;
# - название кнопки соответствует логике - текст “Найти”;
# - кнопку можно нажать всегда;
# - если строка ввода пустая, то результата нажатия не будет;
# - если в строке ввода что-то ввели, то результат будет в виде списка подходящих сайтов.



# ------------------------------------------------------------
# ------------ Поле ввода ----------------
# Данный элемент предназначен для ввода информации.
#
# Например, ввод имени пользователя, телефона, е-мейла, пароля, ссылки и т.д.
#
# При тестировании необходимо обратить внимание на:
#
# - расположение относительно других элементов;
# - размер поля;
# - цвет фона и шрифта;
# - ввод данных в зависимости от контекста поля;
# - как можно ввести данные;
# - можно ли ввести многострочный текст;
# - редактирование введенных данных.

# Вернемся к примеру поисковой строки в браузере и пройдемся по составленному чек-листу:
#
# - расположение относительно других элементов - должно соответствовать макету или здравому смыслу;
# - размер поля - должно соответствовать макету или здравому смыслу как и для кнопки “Найти”;
# - цвет фона и шрифта  - должно соответствовать макету или здравому смыслу;
# - проверить поле применяя техники тест-дизайна в зависимости от контекста вводимой информации в поле (например, в поле
# можно вводить только телефон, только е-мейл, текст не больше 100 символов, дату, время и т.д.);
# - проверить можно ли скопировать данные и вставить их в поле, переместить откуда-то и так далее (если такие возможности
# описаны в документации);
# - если можно вводить многострочный текст, то проверить как обрабатывается нажатие Enter;
# - после редактирования, результат поиска должен соответствовать введенному.

# Обратим внимание еще раз на проверку ввода данных. Составлять проверки следует в зависимости от того, как потом будут
# использоваться введенные данные.
#
# Для ввода имени пользователя - это будет один набор проверок, а для ввода пароля, номера телефона или даты
# рождения - свои чек-листы проверок.



# ------------------------------------------------------------
# --------------- Радиобаттон (Radiobutton) -----------------------

# С помощью данного элемента можно выбрать одну из предложенных опций.
#
# Опции выбора собраны в блок. У блока есть общее название и названия для каждой опции. Выбранная опция отмечается
# закрашенным кружком, не выбранная - незакрашенным.
#
# При тестировании блока необходимо обратить внимание на:
#
# - цвет фона;
# - наличие рамки вокруг блока;
# - названия общее и каждой опции (размер, шрифт);
# - расположение опций относительно друг друга;
# - одновременно выбор возможен только одной опции;
# - выбранная опция выделена;
# - есть ли опция “по-умолчанию”.

# Пример радиобаттона.
#
# На рисунке представлен пример радиобаттона из двух опций, пройдемся по составленному чек-листу:
#
# - цвет фона - должно соответствовать макету;
# - наличие рамки - должно соответствовать макету;
# - названия общее и каждой опции (размер, шрифт) - должно соответствовать макету;

# расположение опций относительно друг друга - все это должно соответствовать макету;
#
# - выбрать опцию можно кликнув на нее, при этом выбор с другой опции снимается;
# - у выбранной опции закрашивается черным кружок рядом с названием, возможно меняется фон опции для большего выделения
# сделанного выбора;
# - “по-умолчанию” выбрана одна из опций.



# -----------------------------------------------------------------------
# ------------------ Чекбокс (Checkbox) -------------------------

# Этот элемент похож на Радиобаттон, но есть несколько отличий - он позволяет выбрать несколько опций одновременно,при
# этом  выбор отмечается “галочкой” в квадрате рядом с названием. Опции так же собраны в один блок с общим названием.
#
# При тестировании блока также обращаем внимание на:
#
# - цвет фона;
# - наличие рамки вокруг блока;
# - названия общее и каждой опции (размер, шрифт);
# - расположение опций относительно друг друга;
# - одновременно выбор возможен одной или нескольких опций;
# - снятие выбора с одной опции не влияет на выбор для других;
# - выбранная опция выделена;
# - снятие выбора - это клик по “галочке”.

# Для примера рассмотрим фильтр в любом интернет-магазине. Можно выбрать как одну категорию товара, так и несколько.

# Тестируем по нашему чек-листу:
#
# - цвет фона - должно соответствовать макету;
# - наличие рамки - должно соответствовать макету;
# - названия общее и каждой опции (размер, шрифт) - должно соответствовать макету;
# - расположение опций относительно друг друга - все это должно соответствовать макету;
# - можно выбрать 1, 2 или 3 опции одновременно;
# - выбрать опцию можно кликнув на нее, при этом выбор с других опции не снимается;
# - у выбранной опции появляется “галочка” в квадрате рядом с названием, возможно меняется фон опции для большего
# выделения сделанного выбора;
# - отмена выбора - аналогично выбору: клик на опции, “галочка” пропадает, действие также никак не отражается на выборе
# других опций.



# ----------------------------------------------------------------------
# Ссылка
# При клике на этот элемент происходит отправка пользователя на другую страницу в интернете, на сайте, на
# странице и т.д.
#
# При тестировании обращаем внимание на:
#
# - выделение элемента (подчеркивание, цвет шрифта);
# - курсор при наведении на элемент;
# - адрес куда происходит переход при клике на ссылку;
# - отсутствие ошибки 404;
# - открытие в новом окне или на той же странице.

# Пример ссылки представлен на рисунке
#
# Возвращаемся к чек-листу проверок:
#
# - шрифт элемента отличается от остального текста и должен соответствовать макету, возможно подчеркивание элемента;
# - курсор при наведении меняет свой вид на “палец”;
# - адрес, куда нас перенаправило при клике на ссылку, совпадает с указанным в документации;
# - ошибки 404 нет;
# - открытие в новой вкладке или на той же странице должно соответствовать документации.



# --------------------------------------------------------------------------------
# --------------- Выпадающие списки --------------------------------

# Этот элемент позволяет пользователю выбрать одну опцию из выпадающего списка. Элемент состоит из поля (отображается
# выбранная опция) и выпадающей части со всем списком.
#
# При тестировании этого элемента надо обратить внимание на:
#
# - размер поля, выпадающей части;
# - размер шрифта;
# - присутствие скролла, если элементов в списке больше, чем размер выпадающего элемента;
# - упорядочивание элементов списка (по алфавиту строки, по возрастанию числовые значения);
# - отображение выбранного элемента в поле;
# - возможность поиска (если такой функционал реализован);
# - появление выпадающей части при клике на поле или “\/” (справа в поле);
# - скрытие выпадающей части при выборе элемента или “\/” (справа в поле)  или клик вне элемента.

# Пример выпадающего списка:
#
# Пользуясь составленным чек-листом проверяем:
#
# - размер поля - должно соответствовать макету;
# - размер выпадающей части - должно соответствовать макету;
# - размер шрифта - должно соответствовать макету;
# - скроллинг присутствует, работает корректно, все элементы доступны;
# - элементы списка упорядочены в определенном порядке (например, по алфавиту);
# - выбранный элемент отображается в поле, выпадающей части;
# - в поле можно начать вводить часть нужного элемента, в выпадающем списке отображаются подходящие (если такой механизм
# реализован);
# - появление выпадающей части при клике на поле;
# - скрытие выпадающей части при выборе элемента или клик вне элемента.


# --------------------------------------------------------------------
# ----------------------- Календарь -----------------------------

# Этот элемент позволяет выбрать один день или период. Состоит из поля (отображается выбранное значение) и выпадающий
# календарь, в котором делаем выбор.
#
# При тестировании такого элемента стоит обратить внимание на:
#
# - размер поля, выпадающей части;
# - размер шрифта;
# - наличие и отображение иконки календаря в поле;
# - возможность перехода по месяцам, по годам;
# - возможность выбора дня или периода;
# - отображение выбранного значения в поле;
# - возможность ввода даты в поле;
# - формат ввода даты (например, дд.мм.гггг)

# Пример календаря для выбора периода:

# Проверим указанный календарь:
#
# - размер поля - должно соответствовать макету;
# - размер выпадающей части - должно соответствовать макету;
# - размер шрифта - должен соответствовать макету;
# - наличие и отображение иконки календаря в поле соответствует макету;
# - можно переходить по месяцам, по годам с помощью “<” и “>”  в зависимости от контекста (например, дату рождения
# нельзя выбрать в будущем);
# - можно выбрать день или период в прошлом / будущем в зависимости от контекста (даты не только в одном месяце, но и в
# разных);
# - выбранное значение в выпадающем календаре отображается правильно в поле;
# - выбранное значение выделяется в календаре;
# - при вводе дат в поле все правильно отображается в календаре;
# - даты отображаются в поле в привычном формате - дд.мм.гггг.



# --------------------------------------------------------------------------
# -------------------- Форма ------------------------------

# Одним из важных элементов интернет-приложений являются формы.
#
# В формах размещают все те элементы, которые были рассмотрены ранее: поля ввода, выпадающие списки, чекбоксы,
# календари, кнопки и т.д.
#
# Проверка форм включает в себя проверку отдельных элементов, которые описаны выше, а также работу формы в целом:
#
# - взаимное расположение элементов;
# - расположение элементов в границах формы;
# - сообщения о заполнении обязательных полей;
# - связь между элементами формы;
# - доступность элементов.

# Для примера рассмотрим форму оформления страховки:

# - взаимное расположение элементов должно соответствовать макету;
# - элементы располагаются внутри формы, не выступая за ее границы;
# - обязательное поле не заполнено - красная надпись напоминает об этом;
# - доступ к некоторым элементам или значениям (например, элементы выпадающих списков) могут быть связаны с другими
# элементами формы;
# - элементы не перекрывают друг друга, ко всем есть доступ.



# -------------------------- Task. -------------------------------------
# Какое количество символов должно содержать поле для ввода e-mail?

# - В соответствии с документацией



# --------------------------- Task. -----------------------------------
# В футере расположены две ссылки, первая ссылка адресует на сайт партнера, и открывается в новой вкладке, вторая
# ссылка на нормативные документы открывается в этой же вкладке. Какое поведение является корректным?

# - Обе ссылки должны открываться в новой вкладке



# --------------------------------------------------------------------------------


# ==============================================================================



# ======================================================================================================================
# 6. Планета бэкенда
# ======================================================================================================================


# ======================================== 6.2 Как работает интернет =================================

# ----------------------------------------------
# Интернет - система связанных между собой устройств, благодаря которой эти устройства могут отправлять друг другу
# данные. Давайте узнаем,  как выглядит процесс передачи данных.
#
# Сегодня мы рассмотрим, как работает интернет, начиная от передачи данных сетевым устройством, заканчивая получением
# этих данных пользователем. Чтобы разобраться в этом, нам понадобится модель.
#
# Так, нам поможет модель OSI - Open Systems Interconnection. Как раз модель OSI описывает процесс передачи данных.
# Данный процесс разделен на семь уровней. Первый уровень - физический,  а последний - прикладной. Начнем по порядку.


# 1) Физический уровень (physical layer)
# На первом уровне OSI  данные передаются в виде физических сигналов. Сигналы бывают электрические или оптические.
# Железу не дано оценить ваш любимый мем, так как для него - это набор нулей и единиц, то есть биты.


# 2) Канальный уровень (dat link layer)
# Проверяются и исправляются ошибки передачи первого уровня. Единицы и нули эволюционируют из битов в фреймы. А эти
# фреймы, как посылки дальним родственникам, получают два адреса - адрес отправителя и адрес получателя. Их
# называют MAC-адресами. Формат MAC-адреса напоминает имя ребенка Илона Маска - 00:AB:CD:EF:11:22.

# Важнейший стандарт технологий первого и второго уровней - Ethernet, описывающий кодирование и передачу данных.


# 3) Сетевой уровень (network layer)
# Здесь наши данные не перестают эволюционировать. На этот раз, фреймы становятся пакетами. Также наши данные получают
# IP-адреса по тому же принципу - адрес отправителя и адрес получателя.


# 4) Транспортный уровень (transport layer)
# обеспечивает передачу данных по сети. В этом ему помогают два протокола - TCP и UDP. TCP протокол гарантированно
# осуществляет доставку запроса и целостность его передачи. Он используется когда пользователь серфит в интернете,
# пользуется сервисам, соц. сетям и прочим. UDP протокол не имеет такой гарантированной передачи данных, как TCP, но у
# него есть свое преимущество - это скорость. UDP широко используется для пересылки голосовых и видео в реальном
# времени. А именно, в IP-телефонии и видео звонках. К примеру, звонки в Telegram используют транспортный протокол UDP.


# 5) Сеансовый уровень (session layer)
# Сеансовый уровень отвечает за поддержку сеанса или сессии связи. Службы сеансового уровня применяются в средах
# приложений, требующих удаленного вызова процедур, т.е. чтобы запрашивать выполнение действий на удаленных компьютерах
# на одном устройстве. За это отвечает протокол PAP. Также примером такой работы является онлайн-трансляция на
# площадке Twitch. Во время онлайн-трансляции необходимо, чтобы два потока данных (аудио и видео) шли синхронно.


# 6) Уровень представления (presentation layer)
# Это уровень представления отвечает за кодирование и сжатие данных, для этого используется протокол ASCII. Именно на
# этом уровне, твой любимый мем обретает человеческий вид, то есть преобразуется в файлы с расширением .jpeg или в
# подобные. Также шестой уровень отвечает за преобразование видео и аудио в понятные форматы для людей. Помимо
# перечисленного, уровень представления переводит текст из одной кодировки в другую, и шифрует данные, чтобы их
# защитить.


# 7) Прикладной уровень (application layer)
# Прикладной уровень - уровень “для людей”. Его главная задача - отобразить пользователю данные в понятном ему виде.
# Благодаря протоколам прикладного уровня, мы можем серфить по просторам интернета. К основным протоколам передачи
# данных относятся:
#
# - HTTP - используются для передачи данных в браузере твоих гаджетов;
# - SMTP - используются для передачи электронных писем;
# - FTP - используются для передачи файлов между компьютерами.

# Также, прикладной уровень переводит IP-адрес в знакомый для нас формат - https://kavichki.com/. Это URL-адрес. В
# этом ему помогает технология DNS


# Данный подход передачи данных лежит в основе клиент-серверной архитектуры. Данная архитектура позволяет разграничить
# логику работы приложения на два раздела: клиент и сервер. Клиент делает запрос к серверу. Сервер отправляет ответ
# клиенту.


# Например, мы хотим открыть главную страницу “Google”.
#
# Наш компьютер подключен к интернету через роутер. Роутер на основании MAC-адреса компьютера выделяет ему IP-адрес.
#
# Набираем в браузер URL-адрес - https://www.google.com. Браузер, с помощью DNS, узнал, что IP-адрес у
# веб-страницы google.com - 173.194.44.40. После, браузер просит наш компьютер отправить запрос на айпишник гугла.
#
# Компьютер упаковывает данные в пакет, указывая IP-адреса отправителя и получателя. Он отправляет пакет нашему роутеру
#
# Роутер отдает запрос провайдеру, через цепочку сетевых устройств. Провайдер перенаправляет запрос на определенный
# сервер компании “Google”, на котором хранится программа, отвечающая за работу главной страницы. Программа обращается
# в базу данных. Получив необходимые данные, формируется ответ.
#
# Далее пакет данных главной страницы отправляется обратно на наш компьютер, пройдя тот же путь. Браузер отображает
# главную страницу, на основе полученных данных. На все ушло меньше одной секунды - магия!
#
# Получается, что клиент - система, запрашивающая нужную пользовательскую информацию, а сервер - система, которая
# обрабатывает полученную информацию и составляет ответ.



# --------------------------- Task. ---------------------------------------
# Расположите уровни модели OSI в правильном порядке, начиная с 1 уровня.

# - Физический
# - Канальный
# - Сетевой
# - Транспортный
# - Сеансовый
# - Уровень представления
# - Прикладной



# ------------------------ Task. -------------------------------------
# Сопоставьте протокол с его сетевым уровнем.

# Физический - Wi-Fi
# Канальный - Ethernet
# Сетевой - IP
# Транспортный - TCP
# Сеансовый - PAP
# Представления - ASCII
# Прикладной - HTTP



# ------------------------- Task. ----------------------------
# Какой из уровней OSI ближе всего к пользователю?

# - Прикладной



# ----------------------- Task. -------------------------------
# Правда ли то, что Тим Бернс-Ли является создателем Интернета?

# - Да



# ------------------------------------------------------------------------------------------


# ==========================================================================================


# ================================ 6.3 Как работает API =================================

# ------------------------------------------------------------------------
# ------------ Как работает веб-приложение ------------------

# Веб-приложение - это программное обеспечение, которое работает на веб-сервере. В отличие от компьютерных программ,
# которые запускаются локально в операционной системе устройства, веб-приложения используют мощности другого
# оборудования. Например, Excel компьютерная программа, а поисковик Яндекс - веб-приложение.
#
# Доступ к веб-приложениям осуществляется пользователем через браузер с помощью интернета.

# Как мы помним, именно браузер отправляет запросы на сервер, получает и  обрабатывает ответ. Результат отображается на
# странице веб-приложения.
#
# Веб-приложение основано на клиент-серверной архитектуре. Значит, принцип работы веб-приложения - запрос и ответ.  Как
# на клиенте, так и на сервере находятся программы. Программы на клиенте называют фронтендом, а программы на
# сервере - бэкендом. Также на стороне сервера находится база данных.
#
# Проще говоря, фронтенд - это все, что видит юзер, открывая страницу веб-приложения, и с чем он взаимодействует.В
# своей работе фронтенд-разработчики используют:
#
# - HTML - “скелет” страницы: структура, данные для браузера;
# - CSS - “стиль” страницы: цвета, шрифты и ее внутреннее наполнение;
# - JavaScript - логика страницы: слайдеры, калькуляторы, анимации;
# - Фреймворк - инструмент, упрощающий разработку. Например, React.
#
#
# Бэкенд - это фактически то, что скрыто от глаз пользователя и происходит вне его браузера. В это же время база данных
# хранит данные каждого конкретного пользователя. Бэкенд-разработчики используют:
#
# - Язык программирования в зависимости от задачи: от C++ до Ruby;
# - SQL - язык запросов в базы данных, и саму систему управления базами данных;
# - Как и фронтенд-разработчики - фреймворки.


# Представьте, что мы заходим в Uber, чтобы заказать такси. Взаимодействие фронтенда и бэкенда будет выглядеть
# следующим образом:
#
# - мы совершаем заказ, заполняя все поля и нажимая кнопку “Заказать”;
# - фронтенд оформляет нашу пользовательскую информацию;
# - браузер отправляет информацию на сервер;
# - бэкенд обращается в базу данных, за нужной ему информацией;
# - бэкенд обрабатывает полученную информацию заказа;
# - бэкенд оформляет обработанную информацию в ответ;
# - сервер отправляет ответ в браузер;
# - фронтенд обрабатывает информацию;
# - мы получаем информацию вида “Водитель найден. Будет через 5 минут”.


# Все знают, что пользователи общаются с приложениями через экран своего гаджета, т.е. через интерфейс. А как общаются
# фронтенд и бэкенд? Чтобы сделать запрос к бэкенду, фронтенд обращается к API бэкенда.

# API - это интерфейс, с помощью которого одна программа общается и обменивается данными с другой.

# Данные запроса и ответа API передается в определенном формате, через протокол HTTP.  Формата два - JSON и XML. Давай
# посмотрим на структуру каждого из них



# ---------------- HTTP ----------------------------

# Это протокол прикладного уровня, изначально предназначенный для передачи HTML-документов. Кстати, HTML - это основа
# каждого сайта и приложения. Сейчас по HTTP передаются и другие данные: наши любимые мемы и забавные видео.
#
# HTTP состоит из стартовой строки, заголовков, пустой строки и тела сообщения.


# В стартовую строку запроса указывают URL-адрес и метод протокола.

# URL-адрес состоит из различных частей:
#
# - протокол - наш друг HTTP или его расширение HTTP(S)
# - доменное имя - тот самый, человеческий, адрес
# - порт - отображает технический параметр, используемый для доступа к ресурсам на сервере. Обычно подразумевается, что
# веб-сервер использует стандартные порты 80 и 443
# - путь - это тоже адрес, но в рамках нашего веб-приложения. Например, раздел сайта
# - параметры - это дополнительные данные, которые браузер отправляет серверу. Параметры имеют формат “ключ=значение” и
# разделяются между собой знаком &. Каждый сервер имеет свои правила обработки этих параметров.
# - якорь - это тоже адрес, но в рамках параметра. Например, ссылка на заголовок


# К основным методам запроса относятся:
#
# - GET - получение. Например, при открытии страницы Вконтакте;
# - POST - создание. Например, при создании нового аккаунта;
# - PUT - обновление. Например, при редактировании профиля;
# - DELETE - удаление. Например, при удалении аккаунта.


# Есть пять типов статусов ответов:
#
# - 1ХХ - дают информацию о процессе передачи. Например, мы отправляем связанные между собой запросы. Данный код
# сообщает, что сервер вошел в режим хатико;
# - 2ХХ - дают информацию об успешной передаче. Появляется, когда все работает корректно;
# - 3ХХ - дают информацию о перенаправлении запроса. Также называют редиректом. Используются, чтобы перенаправить
# пользователя с одной страницы на другую;
# - 4ХХ - дают информацию об ошибке на стороне клиента. Например, если зайти на несуществующую страницу;
# - 5ХХ - дают информацию об ошибке, на стороне сервера. Например, если сервер приложения отключили от питания. В
# заголовок HTTP-протокола указывают служебную информацию запроса. Например, информация о нашем браузере и о
# пользователе.


# Между заголовками и телом ставятся пустая строка, чтобы браузер смог отличать блоки. А в тело запроса указываем
# данные переданные серверу, а в тело ответа данные, которые отправляет нам сервер.
#
# Важно помнить, что HTTP передает данные в открытом виде. Поэтому придумали расширение HTTP(S), позволяющий шифровать
# отправленные и полученные данные.



# ------------------- Task. --------------------
# Расположите порядок запросов и ответов авторизации пользователя:

# - Пользователь ввел логин и пароль, нажал на кнопку "Войти"
# - Фронтенд формирует пользовательские данные
# - Браузер отправляет пользовательские данные
# - Бэкенд обращается в базу данных, за нужными данными
# - Бэкенд обрабатывает полученные данные
# - Бэкенд оформляет обработанные данные
# - Сервер отправляет обработанные данные
# - Фронтенд обрабатывает полученные данные
# - Пользователю открывается личный кабинет



# --------------------- Task. ----------------------------
# Переведите указанный текст из формата JSON в формат XML, используя конвертер:
#
# {
#     "id": 123,
#     "data":{
#         "full_name": "Иванов Иван Иванович",
#         "birth_day": "12.12.2000"
#     }
# }
# Полученные данные скопируйте в ответ


# <?xml version="1.0" encoding="UTF-8" ?>
# <root>
#   <id>123</id>
#   <data>
#     <full_name>Иванов Иван Иванович</full_name>
#     <birth_day>12.12.2000</birth_day>
#   </data>
# </root>



# -------------------- Task. -----------------------------
# Как думаете, кто создал HTTP?

# - Тим Бернерс-Ли



# -------------------- Task. ----------------------------
# Какой метод следует использовать для создания нового аккаунта?

# - POST



# ----------------- Task. ----------------------------------
# Сервер упал. Какой код ошибки получит пользователь?

# - 5ХХ


# ----------------- Task. ----------------------------------
# Расположите порядок блоков данных HTTP протокола:

# - Стартовая строка
# - Заголовки
# - Пустая строка
# - Тело сообщения



# --------------------------------------------------------


# =========================================================



# ===================== 6.4 API на примере DevTools и Postman ===============================

# ----------------------------------------------------------------------
# Валидация - это процесс проверки данных, введенных пользователем, на соответствие заданным критериям (например, на
# отсутствие ошибок в данных).
#
# Данные - это введенная пользователем информация, которая будет провалидирована (ФИО, адрес, город, номер телефона,
# ИНН и др.).
#
# Теперь можно поговорить и об тестировании API.
#
# Как мы знаем, API —  это интерфейс, с помощью которого одна программа общается и обменивается данными с другой.
# Основная цель API-тестирования —  проверить функциональность, надежность и безопасность интерфейсов
# программирования. Тестирование API проводится на уровне интеграционного тестирования.
#
# Типичные ошибки при тестировании API:

# - Отсутствие валидации данных;
# - Отсутствие или дублирование функционала;
# - Отсутствие валидации вредоносного кода;
# - Проблемы с производительностью;
# - Неправильная обработка ошибок;
# - Данные ответа не структурированы правильно (JSON или XML).
#
# А как отслеживать передачу данных между API фронтенда и бэкенда? Все просто. С помощью DevTools.


# ---------------- Вкладка Network -------------------------------

# В Devtools каждого браузера есть замечательная вкладка - Network. Благодаря ей можно узнать, сколько времени заняла
# загрузка страницы, какие данные подключились или не подключились к странице, и так далее. Для открытия нажать F12.
# При первом открытии вкладка будет пустой, поэтому необходимо перезагрузить страницу.
#
# После перезагрузки появится таблица с записями взаимодействия клиента и сервера. Чтобы включить/выключить мониторинг
# трафика, необходимо нажать/отжать кнопку Recorder:


# Здесь можно узнать тип запроса, статус ответа, размер данных и многое другое.

# Обычно вкладку Network используют, чтобы узнать причину отсутствия данных, которые должны быть. Если есть ошибка, то
# запись будет красного цвета.


# Также сообщение об ошибке отобразится и на вкладке Console.

# Можно отфильтровать записи по имени запроса и формату данных  — например, картинки или код.

# В левом нижнем углу отображается информация о количестве запросов, трафике и времени загрузки. Также можно выбрать
# скорость соединения и проверить, как сайт работает при 3G.

# Также, можно узнать подробную информацию каждого запроса, нажав на него:

# - Headers - заголовки ответа и запроса;
# - Payload - полезная нагрузка запроса;
# - Preview - сводка по телу ответу запроса.
# - Response - тело ответа запроса в "чистом" виде;
# - Initiator - инициатор запроса;
# - Timing - время запроса и ответа;
# - Cookies - личная информация пользователя.

# Как отследить передачу данных понятно, а как самостоятельно отправить запрос с нужными данными, минуя браузер? Для
# этого дела придумали классный инструмент - Postman.



# ---------------------- Postman ------------------------------
# Postman – это приложение для работы с API. Он является популярным API клиентом, позволяющий разрабатывать,
# тестировать и документировать API. С помощью Postman мы можем отправлять запросы к серверу и получать от него ответ.
#
# Если опыта работы с API клиентами нет, то рекомендуем пользоваться базовыми возможностями, которые мы и рассмотрим.
#
# Последняя версия Postman доступна для загрузки по ссылке: https://www.postman.com/downloads/.


# ------------- Рабочее пространство ---------------------
# Домашняя страница отображает информацию о работе пользователя. Для выполнения первого запроса необходимо создать
# рабочее пространство. Для этого необходимо нажать на кнопку “Create Workspace” в выпадающем списке “Workspace”.


# Далее даём произвольное название, выбираем уровень доступа и снова нажимаем “Create Workspace”.


# ------------- Коллекция запросов ---------------
# Начнем с создания коллекции. В коллекцию можно поместить несколько запросов, которые будут запускаться поочередно.
# Таким образом, можно создавать коллекцию для каждого тест-кейса и просто их запускать, что сэкономит уйму времени.
# Также, коллекцию можно отправить своему другу, чтобы он оценил ваши навыки :)
#
# Для этого нажмем кнопку “Create Collection”.


# Коллекции, как и рабочему пространству, можно задать произвольное имя.


# --------------- Первый запрос ------------------------
# Мы будем тренироваться, благодаря юмору Чака Норриса! Для этого перейдем на сайт —  https://api.chucknorris.io/.
# Методы этого сервиса отправляют отборные шутки Чака.


# Настал час первого запроса к серверу. Сначала нажмем кнопку “Add request”.


# Запросам можно задать произвольное имя.

# В выпадающем списке “METHOD” необходимо выбрать метод нужного нам сервиса. Мы воспользуемся сервисом для получения
# рандомной шутки Чака Норриса - https://api.chucknorris.io/jokes/random, поэтому выбираем “GET”.


# В следующее поле необходимо указать сам URL-адрес нужного сервиса.


# Готово! Осталось проверить запрос на корректность составления. Нажимаем на «Send».


# Победа! Код 200, шутки за 300. Именно это мы и хотели получить :)


# P.S.
# На этом наше знакомство с Postman завершено. Postman позволяет указывать параметры, заголовки и тело запроса. Также,
# в самом Postman можно писать авто-тесты. В данном уроке мы сделали лишь краткий обзор. Чтобы освоить Postman в
# полной мере, советуем пройти обучение в разделе “Bootcamp”, который расположен в нижнем правом углу.


# ----------------------- Task. ----------------------
#   Найдите метод https://api.chucknorris.io/ для получения категорий шуток. Укажите на какие темы умееть шутить Чак :)

# - travel
# - dev
# - career



# ----------------------------------------------------------------


# ==================================================================



# ======================== 6.5 SQL на примере MySQL ====================================

# --------------------------------------------------------------------
# Когда мы будем тестировать веб-приложение — например интернет-магазин, блог или игры с вероятностью в 100% наверняка
# мы столкнемся с базой данных. В базах данных хранят различную информацию, в зависимости от типа приложения.
#
# Например:
#
# - Если это компьютерная игра, то в базе данных будут типы и локации врагов, их уровень урона и здоровья, и так далее;
# - Если это маркетплейс, то в его базе данных будет храниться имя клиента, его заказы, номер телефона, бонусы.

# Тестировщику необходимо понимать устройство БД, чтобы проверять корректность записи данных.
#
# База данных — это набор данных, организованных определенным способом. Для работы с БД необходимы определенные
# инструменты:
#
# - SQL - язык структурированных запросов, созданный для того, чтобы получать необходимую информацию.
# - Система управления базами данных - ПО, позволяющий работать с БД. По сути, это аналог веб-браузера.


# Существуют различные модели баз данных, но мы рассмотрим только реляционные. Реляционные БД представлены в виде
# таблиц, где данные связаны между собой.
#
# Теперь давайте рассмотрим основные понятия реляционной модели:
#
# 1. Отношение — это двумерная таблица, состоящая из столбцов и строк.
# 2. Атрибут — столбец в таблице, который содержит определенный параметр. Например: название, тип, дата, стоимость и
# так далее.
# 3. Домен — это допустимые значения для каждого атрибута. Например, в столбце “Логин” значения должны представлять
# собой набор буквенных символов, но они обязательно должны содержать символ “@”.
# 4. Значение — это элемент таблицы, находящийся на пересечении столбцов и строк.
# 5. Кортеж — это табличная строка с порядковым номером, содержащая информацию об одном конкретном объекте.
# 6. Ключ — это самый важный столбец в таблице, так как он связывает таблицы между собой.

# Ключи бывают нескольких видов:
#
# - Первичный ключ — идентификатор объекта;
# - Потенциальный ключ — другое уникальное значение, которое может служить идентификатором;
# - Внешний ключ — столбец-ссылка, использующийся для связи между таблицами;

# Внешний ключ обязательно соответствует первичному ключу в другой таблице.
#
# Например, пользователь хочет получить песни своего аккаунта:

# Это пример связи one-to-many (один-ко-многим) - один пользователь и много песен. Также, есть и другие типы связей:
#
# - one-to-one (один-к-одному). Например, для хранения паспортных данных в отдельной таблице - один человек и один
# паспорт;
# - many-to-many (много-ко-многим). Например, для записей бронирования клиента в отеле - каждую комнату может снять
# каждый клиент.



# В предыдущем уроке мы узнали, что SQL или Structured Query Language (язык структурированных запросов) — язык
# программирования, предназначенный для управления данными в СУБД.
#
# Язык SQL очень похож на естественный язык.
#
# Например, чтобы вывести на экран все данные из таблицы страны, необходимо сделать запрос:
#
# SELECT * FROM 'countries';
# Вместо перечисления всех столбцов можно использовать знак звездочки — *.
#
# Теперь напишем запрос на добавление в таблицу страны новую страну:
#
# INSERT INTO 'countries' SET 'name' = 'George';

# Эта команда создаст в таблице страны новую запись, где полю имя страны будет присвоено значение Грузия.
#
# Также, с помощью SQL можно:
#
# - удалять и обновлять данные в таблицах;
# - создавать и редактировать таблицы;
# - производить операции над данными;
# - настраивать работу сервера СУБД.
#
# Установка
# Последняя версия MySQL доступна для загрузки по ссылке: https://dev.mysql.com/downloads/mysql/.
#
# - Откройте командную строку. Например, cmd в Windows.
# - Перейдите в каталог с установленной MySQL: cd /d <каталог установки>/bin.
# - Выполните: mysql -uroot -p.
# - Введите пароль, заданный при установке.
#
# В MySQL с настройками по умолчанию (версия 8.0.32.0) используется язык JS, а не SQL. Необходимо переключить
# командой:  \sql. В противном случае, при попытке создать базу данных командная строка будет ругаться на ошибку
# синтаксиса.
#
# В командной строке запустится клиент для работы с MySQL . С этого момента можно вводить любые SQL запросы с точкой
# с запятой ; на конце.
#
# Первая БД
# Начать следует с создания новой базы данных. Новая БД в MySQL создаётся следующей командой:
#
# CREATE DATABASE <имя базы данных>;
# После создания базы данных её невозможно переименовать, поэтому давайте имена осознанно.
#
# Прежде чем начать работать с нашей БД, необходимо сообщить об этом MySQL:
#
# USE <имя базы>;
# Первая таблица
# Давайте создадим нашу первую таблицу - “countries”, как в примере выше! Наша таблица будет состоять из первичного
# ключа id типа “целое число” и имени страны типа “символ”:
#
# CREATE TABLE countries(
#   id INT AUTO_INCREMENT PRIMARY KEY,
#   name CHAR(128)
# );
# Чтобы добавить данные, необходимо использовать команду:
#
# INSERT INTO  <название таблицы> SET <имя столбца1> = <значение2>, <имя столбца2> = <значение2>...
# Добавим пару стран в нашу таблицу:
#
# INSERT INTO countries SET name = 'George';
# INSERT INTO countries SET name = 'Canada';
# INSERT INTO countries SET name = 'Germany';
# Чтение данных
# Теперь нам необходимо проверить, а правильно ли создалась наша таблица? Сохранились ли в ней данные?
#
# Чтобы прочесть данные из таблицы, нам необходимо воспользоваться командой SELECT:
#
# SELECT <перечисление столбцов> FROM <имя таблицы>
# Давайте получим список всех доступных стран:
#
# SELECT * FROM countries;
# А что если нам нужно получить id конкретной страны? Для этого нам понадобится оператор WHERE:
#
# SELECT <перечисление столбцов> FROM <имя таблицы> WHERE <условие>
# Например, мы хотим узнать id Канады:
#
# SELECT id FROM countries WHERE name="Canada";
# P.S.
# На этой ноте мы завершаем знакомство с SQL. Само собой, это не всё, и нужно ещё многое изучить, однако данный
# туториал даст вам толчок для дальнейшего изучения.


# -------------------------------- Task. --------------------------------------
# Есть приложения для оформления полиса ОСАГО онлайн. Разработчики хранят пользовательские данные(ФИО, номер телефона,
# адрес электронной почты) и данные паспорта в разных таблицах базы данных. Какой тип связи используются между ними?

# - Один-к-одному



# --------------------------- Task. -------------------------------------------
# Выбери скрипт, который вычислит id компании кафе "Только так" с помощью SQL.
#
# Таблица "CAFE":
#
# id	name	         cuisine
# 0001	Только так	     Американская
# 0002	Весело и вкусно	 Итальянская
# 0003	Тот самый	     Американская
# 0004	Свободная касса	 Японская


# - SELECT id FROM CAFE WHERE name="Только так";



# -------------------------- Task. --------------------------------------
# Выбери скрипт, который получит кухню кафе "Только так".
#
# Таблица "CAFE":
#
# id	name	          cuisine
# 0001	Только так	      Американская
# 0002	Весело и вкусно	  Итальянская
# 0003	Тот самый	      Американская
# 0004	Свободная касса	  Японская


# - SELECT cuisine FROM CAFE WHERE name="Только так";


# -----------------------------------------------------------------------------------


# ===============================================================================


# ======================================================================================================================
# 7. Планета смартфонов
# ======================================================================================================================

# ==================== 7.2 Основы тестирования мобильных приложений ==========================

# ------------------------ Мобильные приложения ----------------------------

# Мобильное приложение – программное обеспечение, приспособленное для работы на мобильных платформах О статистике
# использования мобильных приложений можно почитать в этой статье. Если говорить коротко: мобильные приложения лидируют
# почти во всех отраслях жизни человека.
#
# --------------- Основные ОС ---------------------------

# Android - ОС от Google, основанная на Linux. Код Android является открытым, поэтому её адаптируют под разные типы
# устройств:
#
# - смартфоны
# - планшеты
# - IoT приложения
# - SmartTV
#
# iOS - ОС от Apple. В отличие от Android, у неё закрытый код, поэтому iOS есть только на устройствах Apple.
#
# -------------------- Виды мобильных приложений -------------------------------

# На данный момент можно выделить три основных вида мобильных приложений:
#
# - Веб-приложения, адаптированные под мобильные устройства. Эти приложения также являются кроссплатформенными, не
# требуют установки и очень просты в использовании.
# - Нативные приложения. Такие приложения разрабатываются исключительно для конкретной платформы и максимально
# используют возможности конкретной операционной системы. Как правило, нативные приложения характеризуются широким
# набором функций и высокой скоростью работы. Нативные приложения необходимо устанавливать.
# - Гибридные приложения комбинируют свойства двух предыдущих. Такие приложения необходимо устанавливать, как нативные.
# Но, в отличие от нативных, гибридные приложения разрабатываются одновременно для нескольких платформ. Также, для
# обновления таких приложений достаточно добавить изменения на сервер.



# ------------------------------------------------------
# Жизненный цикл приложения
# Ключевым компонентом для создания визуального интерфейса в приложении Android является activity (активность). Нередко
# activity ассоциируется с отдельным экраном или окном приложения, а переключение между окнами будет происходить как
# перемещение от одной activity к другой. Приложение может иметь одну или несколько activity.


# На различных ОС у приложений разный жизненный цикл.
#
# Давайте рассмотрим жизненный цикл приложения для андроид:
#
# onCreate() — первый метод, с которого начинается выполнение activity. В нем производится первоначальная настройка
# activity. В частности, создаются объекты визуального интерфейса.
#
# После того как метод onCreate() завершил выполнение, activity переходит в состояние Started, и система вызывает метод
# onStart()
#
# onStart() — осуществляется подготовка к выводу activity на экран устройства. После завершения работы метода activity
# отображается на экране, вызывается метод onResume, а activity переходит в состояние Resumed.
#
# onResume() — при вызове метода onResume activity переходит в состояние Resumed и отображается на экране устройства, и
# пользователь может с ней взаимодействовать. И собственно activity остается в этом состоянии, пока она не потеряет
# фокус, например, в следствии переключения на другую activity или просто из-за выключения экрана устройства.
#
# onPause() — если пользователь решит перейти к другой activity, то система вызывает метод onPause, а activity
# переходит в состояние Paused. В этом методе можно освобождать используемые ресурсы, приостанавливать процессы,
# например, воспроизведение аудио, анимаций, останавливать работу камеры (если она используется) и т.д., чтобы они
# меньше сказывались на производительность системы. После выполнения этого метода activity становится невидимой, не
# отображается на экране, но она все еще активна. И если пользователь решит вернуться к этой activity, то система
# вызовет снова метод onResume, и activity снова появится на экране.
#
# Другой вариант работы может возникнуть, если вдруг система видит, что для работы активных приложений необходимо
# больше памяти. И система может сама завершить полностью работу activity, которая невидима и находится в фоне. В этом
# случае у activity вызывается метод onStop.
#
# Либо пользователь может нажать на кнопку Back (Назад). В этом случае у activity вызывается метод OnPause, а затем
# метод onStop
#
# onStop() — В этом методе activity переходит в состояние Stopped. В этом состоянии activity полностью невидима. В
# методе onStop освобождаются используемые ресурсы, которые не нужны пользователю, когда он не взаимодействует с
# activity.
#
# При этом во время состояния Stopped activity остается в памяти устройства, сохраняется состояние всех элементов
# интерфейса. К примеру, если в текстовое поле EditText был введен какой-то текст, то после возобновления работы
# activity и перехода ее в состояние Resumed мы вновь увидим в текстовом поле ранее введенный текст.
#
# Если после вызова метода onStop пользователь решит вернуться к прежней activity, тогда система вызовет метод
# onRestart. Если же activity вовсе завершила свою работу, например, из-за закрытия приложения, то вызывается метод
# onDestroy().
#
# onDestroy() — ну и завершается работа activity вызовом метода onDestroy, который возникает, если система решит
# убить activity в силу конфигурационных причин (например, поворот экрана или при многооконном режиме)
#
# Также следует отметить, что при изменении ориентации экрана система завершает activity и затем создает ее заново,
# вызывая метод onCreate.



# -------------------------------------------------------
# Особенности тестирования мобильных приложений
# Тестирование мобильных приложений – это процесс, с помощью которого прикладное ПО, разработанное для портативных
# мобильных устройств, проверяется на его функциональность, удобство использования и совместимость.
#
# На что стоит обратить внимание?
#
# - Гайдлайн - это набор правил для создания приложений, максимально удобных для пользователей разных платформ. Есть для
# Android и для iOS.
# - Разрешение экрана - кол-во пикселей на экране в длину и ширину.
# - Размер экрана - длина и ширина экрана в дюймах.
#
# - Датчики девайса:
#   - Гироскоп (GPS) - отвечает за ориентацию смартфона в пространстве.
#   - Акселерометр - измеряет скорость перемещения смартфона.
#   - Датчик освещённости - измеряет окружающий свет.
#   - NFC-чип - позволяет работать с другими NFC-совместимыми устройствами.
#   - Биометрия - распознавание отпечатка пальца и лица пользователя.
#
# - Прерывание работы приложения:
#   - Входящие и исходящие SMS, MMS, звонки, оповещения других приложений.
#   - Выключение устройства, изъятие аккумулятора, разрядка устройства.
#   - Отключение и подключение провода зарядки.
#   - Переход приложения в период ожидания.
#   - Смена ориентации устройства в режиме ожидания.
#   - Отключение и включение сети, Bluetooth, авиа режима, GPS.
#   - Потеря связи с сервером или прокси.
#   - Отключение и подключение SD-карты, дополнительных устройств вроде физической клавиатуры или гарнитуры.
#   - Работа с акселерометром.
#   - Работа с доп. периферией (если в списке поддерживаемых моделей есть такие).
#
# - Параметры связи:
#   - Тип сети: мобильный интернет или Wi-Fi.
#   - Скорость мобильного интернета: от 2G до LTE.
#   - Авиарежим - отсутствие какой-либо сети, или при подключении к Wi-Fi.
#
# - Производительность
#   - Длительность запуска приложения.
#   - Количество кадров в секунду.
#   - Расход заряда батареи: при работе приложения и когда оно в фоновом режиме.
#   - Утечка памяти. Неграмотное использование ресурсов смартфона влечет за собой сбой.


# ---------------------- Task. -------------------------------
# Отметьте типы мобильных приложений:

# - Веб
# - Нативное
# - Гибридное



# ---------------------- Task. -------------------------------
# Что такое тестирование прерываний?

# - Это тестирование смены фокуса с одного приложения на другое, которое требует немедленной реакции (звонки,
# смс-сообщения, поп-апы и др.)



# =================================================================



# ====================== 7.3 Эмулятор смартфонов на примере Android Studio ==================================

# --------------------------------------------------------------------
# В последнее время эмуляция ОС Android на компьютере стала очень популярной. Пользователям зачастую необязательно
# знать принципы работы, достаточно просто скачать из Интернета специальный эмулятор с уже установленной ОС на борту и
# запустить его. Благо эмуляторов сейчас существует большое множество.
#
# Главным преимуществом эмулятора при тестировании является то, что он дает мгновенный доступ к любой версии Android
# или любому устройству, на котором нужно проверить работу приложения.
#
# К недостатку такого подхода можно отнести то, что нет возможности увидеть, как приложение действительно выглядит на
# устройстве, например, с AMOLED дисплеем. Также у эмуляторов нет доступа к некоторым аппаратным функциями реальных
# устройств.
#
# Рассмотрим как установить и работать с эмулятором от Android Studio.
#
# Эмулятор Android может имитировать работу смартфона, планшета, часов Wear OS и устройств Android TV. Он содержит в
# себе конфигурации популярных типов устройств.
#
# С его помощью можно имитировать входящие звонки и сообщения, указывать местоположение, тестировать различные скорости
# мобильного интернета, повороты экрана и различные датчики, как у реального устройства. Однако не все возможности
# поддерживаются эмулятором, в частности он не поддерживает следующее:
#
# - Bluetooth;
# - NFC;
# - Работу с SD-картой;
# - Работу с наушниками;
# - USB.
#
# Поэтому если вам нужно протестировать что-то из вышеперечисленного, то придется воспользоваться реальным устройством,
# в остальном же эмулятор полностью повторяет его функционал.
#
# Каждый экземпляр эмулятора использует AVD (Android Virtual Device). AVD — это конфигурация определяет характеристики
# устройства, которое нужно эмулировать: форм-фактор, версию Android и различные характеристики.



# ---------------- Настройка ------------------------------

# Для начала создадим новый проект и настроим его. На первой странице выбираем “No Activity”:

# На второй странице указываем название проекта, указываем ЯП нашего приложения и версию Android:

# Для того чтобы создать новый AVD, нужно запустить Device Manager. Для этого нужно в Android Studio в меню
# выбрать Tools — Device Manager. Откроется окно менеджера, в котором будет отображаться список созданных эмуляторов.


# Чтобы создать новый эмулятор, нужно нажать на Create Device в Менеджере AVD. Откроется окно, в котором будет
# предложено выбрать тип устройства и профиль.


# После того как будет выбран профиль, нужно нажать на Next для перехода далее. Здесь нужно выбрать, какой образ
# системы использовать.


# На вкладке Recommended перечислены рекомендуемые образы системы. Другие вкладки содержат более полный список
# доступных образов. Справа приводится информация о выбранном образе (уровень API, версия).
#
# Примечание: образы x86 работают на эмуляторе быстрее всего.
#
# Уровень API важен, поскольку если он будет меньше, чем тот, что указан в манифесте приложения, оно не будет
# установлено на этот эмулятор.
#
# Если образ ранее не был скачан, рядом с названием появится кнопка Download, нажатие на которую начнет процесс
# скачивания.
#
# Чтобы перейти на следующий этап, нужно нажать Next. В новом окне будет предложено изменить дополнительные
# свойства AVD (название AVD, ориентацию экрана).


# После нажатия на Show Advanced Settings откроются дополнительные настройки, в которых можно изменить следующее:
#
# - Фронтальную/основную камеру. Вместо эмуляции изображения есть возможность использовать в качестве камеры подключенную
# вебкамеру;
# - Скорость и качество интернет-соединения;
# - Способ загрузки. Если выбрать Quick Boot, то эмулятор будет сохранять текущее состояние при выключении и загружать
# его при включении. Cold Boot — холодный старт;
# - Количество выделенной оперативной памяти и места на диске;
# - Включение\отключение внешнего вида эмулятора;
# - Включение\отключение ввода с клавиатуры.
#
# Важно! Использование Quick Boot может сильно замедлить работу компьютера, если у него будет недостаточно свободной
# оперативной памяти для загрузки-сохранения данных. В этом случае лучше использовать Cold Boot.
#
# После того как AVD будет настроен, останется только нажать Finish. После этого созданный AVD можно будет увидеть в
# окне Менеджера AVD.
#
# Если нужно будет изменить настройки AVD, это легко можно сделать, нажав на кнопку Edit рядом с нужным эмулятором в
# списке Менеджера AVD.


# Чтобы запустить эмулятор, достаточно в Менеджере AVD нажать на кнопку Run.



# ------------------ Работа с эмулятором -------------------------------------

# Установить приложение на эмулятор можно, перетащив APK-файл на экран эмулятора. Можете скачать APK-файлы
# из https://www.rustore.ru и потренироваться.
#
# Эмулятор Android позволяет тестировать самые разные функции. Их можно настроить, нажав на кнопку Extended Controls в
# меню рядом с эмулятором.


# Откроется окно с настройками, разбитыми на различные категории. Здесь можно настроить отправку данных, различные
# свойства устройства и так далее. Рассмотрим некоторые из категорий.
#
# Вкладка Location позволяет симулировать изменение местоположения устройства. В этом окне можно задавать широту,
# долготу и высоту и отслеживать изменение координат.


# Вкладка Cellular содержит параметры, регулирующие качество связи и мобильного интернета. Например, можно настроить
# тип сети, выбрав LTE, GPRS или другие варианты, силу сигнала и домашний регион/роуминг.


# На вкладке Battery можно установить уровень заряда батареи и ее состояние (заряжается, разряжается и так далее).


# Вкладка Phone позволяет симулировать входящие звонки и смс-сообщения.


# Для того чтобы отправить входящий вызов, достаточно нажать на кнопку Call device, после чего на эмуляторе появится
# соответствующее уведомление. При желании можно также задать свой номер телефона.
#
# Аналогичным образом можно отправить текстовое сообщение, введя текст сообщения в поле SMS Message и
# нажав Send Message.
#
# На вкладке Fingerprint можно симулировать использование датчика отпечатков. На выбор предлагается несколько
# предустановленных отпечатков пальцев для различных тестов. Чтобы сообщить датчику о том, что пользователь
# прикладывает палец, нужно нажать на кнопку Touch the sensor.


# Вкладка Virtual sensors отвечает за симуляцию работы различных датчиков, таких как гироскоп, акселерометр и
# магнитометр.


# С их помощью можно тестировать приложение на предмет изменения положения устройства в пространстве, ориентации или
# того и другого. Эмулятор имитирует способ реагирования датчиков акселерометра и магнитометра при перемещении или
# повороте реального устройства.
#
# P.S.
# Сегодня мы познакомились с инструментом для тестирования мобильных приложений на Android. Android Studio является
# мощным инструментом с огромным количеством возможностей. Чтобы узнать о всех возможностях, следует изучить
# документацию - https://developer.android.com/studio/intro



# ------------------------ Task. -----------------------------------
# Может ли эмулятор полностью заменить реальный смартфон?

# - Нет



# ------------------------ Task. ------------------------------------
# Что такое эмулятор?

# - Программное обеспечение для тестирования мобильных приложений без физического устройства.


# --------------------------- Task. ------------------------------------
# Что такое apk?

# - Android application package


# ------------------------------------------------------------------------


# ========================================================================



# ======================= 7.4 Сниффинг трафика на примере Charles Proxy =================================

# -------------------------------------------------------------------------
# В уроке про тестирование API мы узнали, что с помощью вкладки Network у DevTools мы можем отследить взаимодействие
# клиента и сервера. Дело в том, что браузеры смартфонов не имеют DevTools. Для мониторинга трафика используются
# специальные инструменты - снифферы.
#
# Снифферы - это инструменты для перехвата трафика, проходящих через сеть.
#
#
#
# --------------- Настройка Charles Proxy для Android ------------------------

# Давайте настроим Charles Proxy. Во-первых, нам нужно скачать сертификат, с помощью которого наш телефон будет
# взаимодействовать со сниффером. Во вторых, устройство Android и ПК должны быть в одной сети.
#
# Переходим в раздел Help > SSL Proxying > Install Charles Root Certificate.


# В открывшемся окне Сертификат > Установить сертификат. Выбрать «Текущий пользователь» или «Локальный пользователь».
# Далее вы получите уведомление, что сертификат успешно импортирован.


# Для перехвата трафика у Android-приложения должно быть установлено разрешение в файле
# манифесте - AndroidManifest.xml, который настраивают разработчики приложения. В файле манифесте указывают
# разрешения, которые сторонние приложения обязаны иметь для взаимодействия с компонентами данного приложения. Кстати,
# можете скачать APK-файлы из https://www.rustore.ru и потренироваться.
#
# Теперь настроим сеть. Для этого узнаем IP-адрес ПК: в Charles Proxy перейдем в Help > Local IP Address. Видим, что
# наш IP: 192.168.60.159


# Далее на телефоне идем в Свойства сети → Название сети WiFi → Прокси-сервер
#
# Выбираем вариант вручную и прописываем параметры:
# - Имя хоста: IP-адрес нашего компьютера;
# - Порт: 8888


# При сохранении в Charles на ПК появится запрос, нажимаем Allow.


# Теперь необходимо на телефоне перейти по ссылке chls.pro/ssl, начнется скачивание сертификата. После успешной
# загрузки нужно перейти в настройки и найти пункт установка сертификата, нам нужен Сертификат СА. После чего, выбираем
# скаченный сертификат и устанавливаем.
#
# Все! Ваш телефон готов для сниффинга.


# -------------------------------------------------------------
# -------------- Работа со сниффером ------------------------

# Для мониторинга трафика понадобятся следующие кнопки:

# - Clear the current Session — очищает историю запросов.
# - Start/Stop Recording — включает или выключает записи запросов.
# - Start/Stop SSL Proxying — включает или выключает просмотр запросов.


# На вкладке Structure будут видны запросы отправляемые с вашего устройства, которые можно фильтровать:

# На вкладке Sequence также будут видны запросы отправляемые с вашего устройства, которые можно фильтровать. Интерфейс
# данной вкладки напоминает вкладку Network у DevTools:


# И на вкладке Structure, и на вкладке Sequence можно узнать подробную информацию каждого запроса, нажав на него:
#
# - Overview - общая информация, которая доступна о запросе.
# - Contens - основная вкладка, на которой отображается содержимое запросов/ответов.
# - Summary — информация для сравнения группы запросов.
# - Chart — диаграмма о времени выполнения группы запросов.
# - Notes — личные заметки о запросе.


# P.S.
# На этом наше знакомство со сниффингом подошло к концу. Charles Proxy позволяет не только мониторить трафик, но и
# настраивать запросы и ответы. Чтобы освоить Charles Proxy в полной мере, советуем ознакомиться с докуметацией
# инструмента - https://www.charlesproxy.com/documentation/.



# ------------------------- Task. ----------------------------------
# В каких видах тестирования применяется сниффинг?

# - Тестирование мобильных приложений
# - Тестирование Web приложений
# - Тестирование API



# ------------------------- Task. ----------------------------------
# Как проверить поведение приложения при медленном соедении?

# - Выбрать медленную сеть в эмуляторе



# ------------------------------------------------------------------


# ==================================================================