# ========================== Начало =========================

# Программная ошибка (жарг. баг) — означает ошибку в программе или в системе, из-за которой программа выдает
# неожиданное поведение и, как следствие, результат. Большинство программных ошибок возникают из-за ошибок команды
# разработки.



# Тестирование программного обеспечения — процесс исследования, испытания программного продукта, имеющий своей целью
# проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе
# тестов, выбранных определённым образом. Тестировщик, в свою очередь, моделирует различные ситуации (тесты), которые
# могут возникнуть в процессе использования программы, чтобы разработчики смогли исправить обнаруженные баги.



# Мы воспользуемся популярной техникой тест-дизайна, позволяющей быстро и качественно проверить что-либо:
#
# - Техника выделения классов эквивалентности и граничных значений позволяет уйти от дублирующих проверок.
# Следовательно, мы сократим количество однотипных тестов.
#
# - Классы эквивалентности — это разбиение функционала на наборы данных, которые ведут себя в пределах этих наборов
# одинаково. Например, дети, взрослые и пенсионеры - это все классы эквивалентности.
#
# - Анализ граничных значений — это метод, который улучшает разделение классов эквивалентности. В нашем случае, самые
# близкие значения — это 17 и 66.



# Чек-лист– это список, содержащий ряд необходимых проверок во время тестирования программного продукта. Отмечая пункты
# списка, команда или один тестировщик могут узнать о текущем состоянии выполненной работы и о качестве продукта.

# ===================================================================



# ========================== Теория ==============================


# ------------------------ 2.2. Тестирование и качество ------------------------

# Качество программного обеспечения — способность программного продукта при заданных условиях удовлетворять
# установленным или предполагаемым потребностям.



# Quality assurance, Quality control и Testing. Who is who?

# 1. Testing (тестирование) — самый первый уровень. Это проверка программного продукта на соответствие требованиям
# этого продукта.

# То есть ожидаемый результат и фактический результат совпадают, и это тот минимум, без которого нельзя выпускать
# продукт. Возьмем для примера тестирование в интернет—магазине кнопки «Купить».
# В процесс тестирования будет входить проверка функционала и сверка с макетом. Кнопка нажимается, открывается нужное
# окно, кнопка находится в правом нижнем углу, окрашена в зеленый цвет и т.д.


# 2. QC (Quality Control, контроль качества) — второй уровень, включает в себя тестирование и контроль за соответствием
# заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшн.

# Основная задача контроля качества — предоставить объективную картину того, что происходит с качеством продукта на
# разных этапах разработки. Управление качеством (Quality control) — часть менеджмента качества, направленная на
# выполнение требований к качеству. Это означает, что необходимо выполнять требования, а как это будет
# происходить, зависит от корпоративной культуры.
# Вернемся к интернет-магазину. QC даст отмашку на релиз, если не заполнена страница благодарностей, на которую можно
# перейти из футера (подвала) сайта. Или, например, не даст добро, если страница благодарностей заполнена, а каталог
# пустой.


# 3. QA (Quality Assurance, обеспечение качества) — часть обеспечения согласованного уровня качества продукта. Это уже
# проактивная работа, т.к. основная задача обеспечения качества — это выстроить систему, которая будет работать на
# качество продукта, чтобы при тестировании количество дефектов было минимальным.
#
# В зависимости от специфики проекта сюда может входить тестирование документации, ревью кода на соответствие
# стандартам, внедрение каких-то методик по работе с качеством.
# Обеспечение качества (Quality Assurance) — часть менеджмента качества, направленная на создание уверенности, что
# требования к качеству будут выполнены.

# При более полном понимании можно обратиться к ГОСТ Р ИСО 9000-2015

# -------------------------------------------------------------------------------


# ---------------------------- 2.3. Принципы тестирования ---------------------------------

# Принципов тестирования всего 7. Как и большинство принципов, они редко напрямую используются на практике, но при
# этом любое тестирование предполагает их соблюдение:

# 1) Тестирование не может доказать отсутствие багов(только их наличие);
# 2) Исчерпывающее тестирование невозможно по определению;
# 3) Раннее тестирование позволяет сэкономить ресурсы;
# 4) Парадокс пестицидов;
# 5) Кластеризация багов;
# 6) Тестирование зависит от контекста;
# 7) Заблуждение об отсутствии багов;



# 1) Тестирование не может доказать отсутствие багов(только их наличие);

# Отсутствие багов во время проверки не может гарантировать отсутствия багов при подобных действиях в другое время. Из
# этого делаем вывод, что тестирование не может доказать отсутствие багов.

# Но с другой стороны, мы точно знаем, что баг может возникнуть у пользователя, раз он возник у нас. А раз баг есть,
# значит, что-то его вызывает. Следовательно, нужно найти причину этого бага и устранить ее.
#
# Исходя из этого, мы получаем вторую часть принципа — тестирование может доказать наличие багов.
#
# Здесь может показаться, что тестирование не так уж и нужно, раз не может ничего гарантировать. Да и тестировщик ни
# за что ответственности не несет — пропустил баг и ладно, отсутствие багов никто и не гарантировал. Все совсем не так.
# Как правило, для любого разрабатываемого ПО подразумеваются (и напрямую указываются) некие «нормальные условия», при
# которых оно должно работать, и именно в этих условиях проводятся проверки.

# P.S.
# Довольно хорошо иллюстрирует условия разработка мобильных приложений для устройств на iOS. Есть достаточно
# ограниченный список моделей айфонов и версий их операционной системы. Можно запланировать, что для запуска
# приложения нужна модель не старше определенной и версия iOS также не ниже определенной. При соблюдении этих условий
# приложение будет работать как задумано, в остальных случаях за результат никто не отвечает. И, соответственно,
# тестирование не проводится. С андроидом ситуация похожая, но там все чуть сложнее, т.к. у каждого производителя
# своя линейка моделей. Или вот еще пример: если вы напишете в техподдержку популярного баг-трекера Jira, что он
# некорректно работает на вашем макбуке, то получите ответ, что устройства от Apple официально не поддерживаются. В
# общем, это ваши проблемы, что у вас там не работает. Никто не будет разбираться до тех пор, пока не запустите на
# поддерживаемой конфигурации.



# 2) Исчерпывающее тестирование невозможно по определению;

# Тестировать можно бесконечно, проверяя различные сценарии поведения, но придется потратить оень много времени и
# ресурсов.

# На практике тестировщики выбирают наиболее эффективные проверки, руководствуясь знаниями о тестируемом ПО и здравым
# смыслом. Например, если у нашего поля в коде задано ограничение на ввод только цифр, то с ввода цифр и следует
# начать (положительные проверки всегда идут первыми!). Для негативных проверок достаточно будет несколько раз ударить
# по клавишам в русской раскладке. Ну и на английской, для успокоения совести. Ничего не появилось — ок, буквы не
# принимает. Теперь спецсимволы — как правило, в таком случае просто копируется и вставляется строка в
# духе `~@#$%^&*()_+|-=\{}[]:»;’<>?,./®©£¥¢¦§«»€. Если что-то из этого не заблокировано, оно появится в поле. Плюс надо
# быть особенно внимательным к точкам и запятым, ведь ими может отделяться дробная часть, поэтому попробовать
# ввести «2,» и «5.» тоже стоит. Вот и все, мы ужали годы проверок в пять минут и отправились тестировать следующее
# поле, спасибо второму принципу тестирования.



# 3) Раннее тестирование позволяет сэкономить ресурсы;

# Пожалуй, самый осязаемый, самый материальный принцип. Как вы позже узнаете, процесс тестирования программного
# обеспечения включает в себя не только работу с уже готовым или скорее полуготовым продуктом. По сути
# своей, тестирование сопровождает процесс разработки где-то с момента зарождения идеи. Когда на каждую мысль «Вот
# так будет очень хорошо!» появляется критическая оценка «А правда ли будет?» — это уже можно назвать тестированием.

# Но, возвращаясь к тестированию ПО, чем раньше была найдена ошибка (она же баг, она же дефект и т.д.), тем больше
# ресурсов будет сэкономлено. Ну или меньше потрачено, разницы нет. Под ресурсами мы понимаем, в первую очередь, время
# и деньги.

# Современные подходы говорят о том, что тестирование должно участвовать во всех этапах разработки ПО, а не просто
# получать на руки новую версию и протыкивать ее на предмет багов. Эффективность подобных практик доказана реальными
# результатами, поэтому в идеале команда тестирования должна быть на проекте уже на стадии первых обсуждений и планов.



# 4) Парадокс пестицидов;

# На практике возможна ситуация, когда программист, исправляя неоднократно найденный баг, изменит код таким образом, что
# баг на тех же самых данных перестанет повторяться, а на других продолжит. Предположим, в калькуляторе вместо
# умножения происходит сложение. Тестировщик всегда проверяет умножение, вводя 5х5 и получая 10 вместо 25. Тогда
# разработчик напишет код примерно такого содержания: если А=5 и В=5, то АхВ=25, во всех остальных случаях АхВ=А+В. В
# очередной раз введя 5х5, тестировщик наконец увидит 25 и подтвердит исправление бага. А если бы каждый раз вводил
# разное…
#
# Разумеется, ни один вменяемый разработчик никогда не поступит подобным образом. Но на этом тривиальном примере
# очевидна нелогичность решения. В большой сложной системе может быть непонятно, что новый код не исправляет реальную
# проблему, а лишь делает ее менее заметной.

# Итог:
# если одни и те же тесты повторяются снова и снова, в конечном итоге один и тот же набор тестов больше не обнаружит
# никаких новых дефектов. Чтобы преодолеть этот “парадокс пестицидов”, необходимо регулярно пересматривать и
# пересматривать тестовые примеры, а также писать новые и различные тесты для проверки различных частей программного
# обеспечения или системы на наличие потенциально большего количества дефектов.



# 5) Кластеризация багов;

# Закон Парето справедлив и для дефектов ПО. Это тот, который про 20% одного дает 80% другого. В нашем случае одним
# является функционал, а другим — баги. Ошибки при проверках имеют свойство складываться вместе, образовывая кластер.
# Или кучковаться в одном кластере разрабатываемого ПО — суть не меняется.
#
# Почему так получается? Причин может быть много, одно тянет за собой другое, а каждый случай индивидуален. Например,
# за «проблемный» модуль продукта отвечает программист, который ранее с подобными задачами не сталкивался. Учится по
# ходу дела и допускает много ошибок при выполнении задач. Или у заказчика нет четкого понимания как эта часть
# программы должна работать, он пытается менять решения на ходу, что сильно сказывается на уже сделанных частях. Или
# модуль плохо описан в документации, из-за чего возникает множество разночтений при выполнении.
#
# Докопаться до первопричины, устранить сразу множество имеющихся багов или хотя бы предотвратить появление
# будущих — это очень здорово. Но редко когда удается это сделать. Если разработчик только набирается опыта, он не
# наберется его моментально. На заказчика не снизойдет ясное видение готового продукта. А документация не изменится
# в одночасье.
#
# Для нас, как тестировщиков, важен один вывод из пятого принципа: нашел баг — поищи другой поблизости.
#
# P.S.
# Немного о другом, но все же важном на практике моменте. Согласно принципам программирования, похожие элементы не
# создаются каждый по отдельности. Вместо этого общая часть кода пишется в одном месте и используется уже в коде
# однотипных элементов в виде ссылки, а разнящиеся части дописываются после нее. Таким образом, если баг вызван ошибкой
# в общей части кода, сломаются все использующие общий код элементы. И, будучи найденным в одном элементе, этот баг
# может быть пропущен в другом. Об этом тоже надо помнить и сразу оценивать, что еще мог зацепить найденный баг.



# 6) Тестирование зависит от контекста;

# Это значит, что способ, которым вы тестируете сайт для e-commerce, будет отличаться от способа тестирования
# мобильного приложения. Софт бывает самый разный и подход к его тестированию тоже бывает самый разный. Необходимо
# применять разные подходы, методологии, техники и типы тестирования в зависимости от приложения.

# PS
# Уместна такая аналогия: спортсмен, готовящийся к соревнованиям, занимается спортом 6 часов в день. Офисный работник,
# заботящийся о своем здоровье, занимается спортом 6 часов в неделю.
# Все решают приоритеты, определяемые глобальными и текущими задачами, т.е. тот самый контекст.




# 7) Заблуждение об отсутствии багов;

# Отсутствие багов невозможно, но это мы знали и раньше, так о чем же седьмой принцип? Он о том, что отсутствие багов
# не смогло бы обеспечить серьезных преимуществ. Не надо бояться самого факта наличия багов в системе, баги — это
# нормально.
#
# P.S.
# И это опять-таки не значит, что тестировщик не несет ответственности за пропущенный баг, а на любые претензии может
# ответить «Баги — это нормально». Действительно, пропущенный краш приложения, повторяющийся при смене языка у 0,001%
# пользователей, это не так уж и страшно. Пропущенный краш приложения при запуске, повторяющийся у 99%
# пользователей — свидетельство того, что приложение никто не тестировал. Если хорошо поискать, баги найдутся в любом
# ПО, но очень важно, чтобы эти баги не мешали (ну хотя бы несильно) большинству пользователей.



# Task.
# Известно, что основной поток посетителей приходит по результатам запроса “.......”, сделанного с
# мобильного телефона. Используя сервис https://gs.statcounter.com/, необходимо выбрать три самых популярных браузера;
# на них будем осуществлять проверку.

# - Google Chrome
# - Safari
# - Samsung Internet



# Task.
# Предположим, мы в 1963 году тестируем поле ввода, которое может принимать только символы ASCII. Какое количество
# позитивных проверок будет исчерпывающим для поля, если известно, что ввести возможно только 3 символа?

# - 2 097 152
# (Согласно википедии, изначально (1963 год) ASCII была разработана для кодирования символов, коды которых
# помещались в 7 бит (128 символов; 2^7=128). Количество сочетаний из трёх символов вычисляется с помощью возведения
# общего количества возможных символов в третью степень. 128^3=2 097 152)



# Task.
# Что нужно делать, чтобы избежать парадокса пестицида?

# - Добавлять новые тесты
# - Пересматривать и улучшать тесты
# - Использовать разные тестовые данные



# Task.
# Предположим, у нашего сайта на 5 разных страницах встречаются селекты. Это такие выпадающие списки, вы их точно видели
# и не раз. При этом на 2 страницах селект представляет собой выпадающий список из нескольких вариантов. Назовем этот
# тип Селект 1.

# На 2 страницах список длинный и есть возможность искать по нему, вводя что-либо в поле селекта. Он будет - Селект 2.

# На последней странице при клике по селекту вместо выпадающего списка появляется подсказка «Введите не менее 3
# символов для поиска» и только после ввода появляется соответствующий поиску список возможных вариантов. А он будет
# Селект 3.

# При клике по Селекту 3 он не раскрылся. Какое предположение будет наиболее логичным для поиска аналогичной ошибки:

# - Имеет смысл проверить Селекты 1 и 2, т.к. выпадающий список при клике - общая функциональность всех селектов.



# Task.
# Отметьте виды тестирования, которые следует провести для мобильной игры с аудиторией 1 млн пользователей (в целях
# задачи считать, что ресурсов достаточно для любого объема тестирования):

# - тестирование безопасности
# - тестирование установки
# - тестирование удобства использования
# - функциональное тестирование
# - тестирование производительности
# - нагрузочное тестирование
# - тестирование совместимости



# Task.
# Перед вами требования заказчиков на разных проектах. Используя знание принципов тестирования отметьте те из них,
# которые, скорее всего, НЕ получится выполнить.

# - Да какая документация, приложение маленькое, его можно и так проверить;
# - Приложение должно соответствовать дизайну на любом устройстве;
# - Не выпустимся пока не выловим все баги;
# - Наше ПО рассчитано прежде всего на домохозяек, у них оно баговать не должно;
# - За пару часов до релиза передаём новую версию в тестирование, выпускаемся на всех возможных платформах.


# ====================================================================================



# ========================= 2.4 Методологии разработки =======================================

# SDLC, Waterfall, Agile и CI/CD. Who is who?

# Мы уже понимаем, что любое программное обеспечение создается по определенным правилам или «канонам», если хотите. В
# силу этого обстоятельства существует такое понятие как «жизненный цикл ПО».
#
# Жизненный цикл ПО (SDLC) – это период времени, который начинается с возникновения идеи продукта до прекращения его
# использования — вывода из эксплуатации.
#
# Жизненный цикл программного обеспечения состоит из последовательных этапов:
#
# - Анализ требований. На этом этапе составляется ТЗ(Техническое задание – это документ, содержащий информацию для
# постановки задач на разработку), обозначаются сроки по каждой задаче и план работ. Здесь также нужно учитывать все
# возможные риски. Как только все детали просчитаны и описаны – можно переходить к следующему этапу;

# - Дизайн системы. Разрабатывается прототип, дизайн-макет, платформа для программирования. Все члены команды должны
# быть расписаны по ролям, а также необходимо указать их обязанности;

# - Разработка. Команда пишет код продукта, согласно требованиям технического задания;

# - Тестирование. Проверка продукта, когда код написан. Если все благополучно, работу можно считать практически
# законченной;

# - Техническая поддержка. После релиза продукта, команда разработки поддерживает работу проекта на стабильном
# уровне, собирая обратную связь от пользователей и устраняя баги, если они возникают.



# Waterfall —  водопадная/каскадная модель разработки, описанная в 1970 году, дублирует этапы жизненного цикла ПО.
# Waterfall позволяет решать задачи по последовательному плану без возврата на предыдущие этапы.
#
# Принципы Waterfall:
#
# - Следуйте правилам;
# - Нет ТЗ — нет продукта;
# - Чем подробнее ТЗ, тем лучше продукт;
# - Следите, чтобы не было изменений.


# По мере развития и распространения ПО, нужно было максимально погружаться в проект, чтобы контролировать
# изменения, взаимодействовать с командой, предлагать новые решения. В рамках Waterfall это было невозможно, так как
# водопадная модель разработки не была гибкой. Именно в этот момент и появился Agile.


# Agile — это группа методик для гибкого управления продуктом. Суть этой группы методик заключается в разбивке
# процесса на небольшие временные промежутки — спринты. Во время каждого спринта команда разработки создает часть
# продукта, которую можно протестировать. Такой подход позволяет вносить правки на любом этапе.
#
# В Agile работа над продуктом строится по следующей логике:
#
# - составление ТЗ;
# - проектирование;
# - разработка;
# - тестирование;
# - результат.


# Пример
# Рассмотрим нашу тему на примере производственного процесса:


# Waterfall завод мороженого
#
# Гендиректор поручает технологу разработать новый вид мороженого. В лучшем случае, технолог пойдет в отдел
# маркетинга, чтобы они провели исследования. Но обычно такие идеи возникают не от желания потребителей, основанного
# на маркетинговых исследованиях, а от желания самого директора. По результатам исследований технолог разработает
# мороженое на собственный вкус и приносит его директору. Он пробует новый продукт и решает — переделывать или нет.
# Далее после утверждения директором, варщикам выдают технологические карты, по которым они могут запускать продукт в
# производство. Затем продавцам для реализации – упакованное мороженое. Это стандартный подход. Сотрудники получают
# задания, а оценка производится одним (иногда несколькими) человеком.


# Agile завод мороженого
#
# Гендиректору приходит идея разработать новый вид мороженого, и вот тут начинается чудо. При создании продукции
# будут задействованы не только технологи и сотрудники маркетинга, но также менеджеры по продажам, логисты, повара и
# реальные покупатели. При этом в команде нет никакой иерархии (кроме генерального директора) и итогом работы будет не
# награда конкретного сотрудника, а получение нового вида мороженого для покупателей. При этом все участники команды
# оценивают результат и дают обратную связь для его улучшения.


# Манифест гибкой разработки ПО:
#
# - Люди важнее инструментов.
# - Качество продукта важнее документации.
# - Взаимодействие с заказчиком важнее контракта.
# - Готовность к изменениям важнее установленного плана.



# Непрерывная разработка
# В разработке любого софта есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.

# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.

# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.

# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.

# В рамках непрерывного подхода решаются следующие задачи:
#
# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.

# CI/CD чаще всего зависит от тестировщиков и девопсов:
#
# - Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# - Девопсы автоматизируют процесс доставки ПО.

# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# Расположите этапы жизненного цикла ПО в правильном порядке:

# - Анализ требований
# - Проектирование
# - Разработка
# - Тестирование
# - Техническая поддержка



# Task.
# Выберите принципы методологии Agile:

# - Качество продукта важнее документации
# - Взаимодействие с заказчиком важнее контракта
# - Люди важнее инструментов
# - Готовность к изменениям важнее установленного плана



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Девопсы
# - Тестировщики



# =============================== 2.3 Подходы к разработке ==============================


# -------------------------------------------------
# Подходы к разработке
# -------------------------------------------------
# В разработке любого ПО есть два подхода: итеративный и непрерывный. Они отличаются методами работы и сложностью
# организации.


# При использовании итеративного подхода заказчики или пользователи видят результат только в самом конце этапа, а до
# этого пользуются старой версией.


# Непрерывный подход позволяет пользователям каждый день получать новую версию, которую уже можно использовать.


# Непрерывный подход является самым популярным, на сегодняшний день. Его описывает
# концепция CI/CD (Continuous Integration, Continuous Delivery — непрерывная интеграция и доставка) — это автоматизация
# тестирования и доставки новых модулей ПО конечным пользователям. CI/CD относится к Agile-методологиям.


# В рамках непрерывного подхода решаются следующие задачи:

# - автоматизация последовательной сборки, упаковки и тестирования ПО;
# - автоматизация развертывания ПО в различных окружениях;
# - минимизация ошибок и уязвимостей ПО.


# СI/CD – это современная аналогия конвейерного производства. Их объединяет четкое распределение труда, непрерывный
# поток работы и параллельное выполнение сразу нескольких задач.
#
# CI/CD чаще всего зависит от тестировщиков и разработчиков:
#
# Тестировщики следят за тем, что новые изменения не повлияли на качество продукта;
# Разработчики автоматизируют процесс релиза ПО.
# Благодаря CI/CD пользователи получают новые фичи сразу, а команда разработки получает страховку от возможных сбоев
# при сборке ПО.



# Task.
# К какому подходу разработки относится CI/CD?

# - Непрерывный



# Task.
# Кто, чаще всего, следит за качеством процесса CI/CD?

# - Тестировщики
# - Разработчики



# ================================ 2.5 Процесс тестирования ==========================================

# ISTQB - Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.
#
# Процесс тестирования
# Вопреки ожиданиям, процесс тестирования несколько шире, чем «садишься за комп и тестишь». Помимо непосредственного
# взаимодействия с объектом тестирования, существуют как подготовительные этапы, так и последующие. Для того, чтобы
# проверки стабильно давали точную информацию о качестве продукта, они документируются и регулярно актуализируются.
#
# Для измерения эффективности тестирования и отслеживания общего качества используются специальные метрики. На
# основании полученных результатов и рассчитанных метрик составляются отчеты. По разным оценкам, работа с документацией
# занимает от 50% до 70% времени тестировщика, на само же тестирование тратится оставшаяся часть.
#
# Настроенные процессы — залог успешной реализации проекта, и тестирование в этом успехе играет не последнюю роль.
#
# Четкое понимание того, что, как и в какой момент делать, экономит время, придает уверенность, устанавливает хорошие
# взаимоотношения в команде. Подобно фундаменту здания, который никто не видит, но на который все опирается. Сами по
# себе процессы не могут обеспечить успешность проекта, но могут существенно упростить ее достижение. Процесс
# тестирования не является чем-то отдельным, он плотно переплетается с другими процессами, входящими в разработку и
# выпуск программного обеспечения.
#
# Дисклеймер: в качестве основы для описания процесса тестирования была взята Программа подготовки базового уровня 2018
# года ISTQB, доступная для скачивания по ссылке https://www.rstqb.org/ru/istqb— downloads.html (на русском и
# английском языках)



# -------------------- Планирование -----------------------------
# Прежде всего оговоримся, что весь описываемый процесс не обязательно представляет собой жесткую последовательность.
# Разные этапы могут идти параллельно, потому что тут не успели, а там сделали раньше. Могут возникнуть непредвиденные
# обстоятельства, из-за которых придется возвращаться к сделанному ранее и переделывать по-новому.
#
# Процессы (в том числе тестирования) в разных компаниях или в одной компании на разных проектах могут существенно
# отличаться, поэтому данное описание не является догмой на все 100%. И, наконец, несмотря на то, что мы говорим о
# проекте в целом, процесс может применяться и отдельно к его частям. Например, выпуск новой версии вполне может пройти
# все описанные  здесь этапы. Обо всем этом надо помнить в процессе изучения и осмысления материала.
#
# Планирование тестирования — этап составления планов (внезапно!). Тест-план включает в себя всю общую информацию о
# проекте. Например, требования и дизайн продукта. Под требованиями подразумевается документ(ы), в котором
# сформулировано, какую функциональность продукт должен предоставлять пользователю. Техническое задание, спецификации,
# требования, юзер стори, любые аналогичные документы. Требования могут быть расписаны в разных формах, но они в любом
# случае включают в себя описание работы конечного продукта. Например:
#
# пользователь должен иметь возможность авторизоваться на сайте;
# авторизованный пользователь должен иметь возможность зайти в личный кабинет;
# в личном кабинете пользователь должен иметь возможность прикрепить банковскую карту с целью использования ее для
# будущих покупок на сайте.
#
#
# Дизайном называют макеты будущего продукта, отрисованные в графическом редакторе. Не так давно многое рисовалось в
# фотошопе, но сейчас чаще используются специальные программы, имеющие «заточенный» для этих целей интерфейс и
# функционал. Например, довольно популярна Figma — мы еще столкнемся с ней на следующих уроках, но можете погуглить
# ради интереса уже сейчас. Требования, дизайн и любые другие описывающие будущий продукт вещи называются «тестовым
# базисом».
#
# Помимо этого, план тестирования может включать в себя, например, расписание тестирования, т.е. когда будет
# тестироваться какая часть продукта. Откуда это может быть известно? Нельзя разрабатывать продукт по принципу «когда
# будет готово», все работы имеют временные оценки и установленные сроки реализации. Соответственно, когда будет
# готова конкретная функциональность, тогда и начнется ее тестирование.
#
# Еще к плану тестирования можно приложить анализ рисков, список метрик с формулами, бюджет, критерии начала и
# окончания тестирования, образцы тестовой документации, описание используемых техник и технологий. Вообще что угодно
# из того, о чем можно договориться «на берегу», когда разработка еще не начата. Вся общая информация, хоть как-то
# касающаяся тестирования — здесь.



# ------------------------------- Мониторинг и контроль -----------------------------------

# Этап мониторинга и контроля не является этапом «до» или «после», это этап «во время». Во время всего проекта, если
# быть точнее. Мониторинг и контроль тестирования подразумевают непрерывное отслеживание фактического хода работы и
# сверку его с тестовым планом. Помните, на этапе планирования мы говорили о расписании? Крайне важно не только иметь
# такой документ, но и регулярно к нему обращаться, а в случае расхождения вовремя принимать меры, чтобы
# скорректировать ход работ. Расчет метрик тестирования также входит в мероприятия данного этапа.
#
# Одной из метрик является процент пройденных проверок — завтра у нас выходит новая версия, а сегодня она
# протестирована только на 10% — значит, что-то идет не так. Например, новую версию установили только сегодня. Или
# ее установили неделю назад, а мы ничего не тестировали. Ищем причину, устраняем ее, продолжаем работу в штатном
# режиме.
#
# Разумеется, отчетность — тоже элемент данного этапа. Стандарт ISO/IEC/IEEE 29119-3 выделяет два вида отчетов: отчет
# о ходе тестирования и отчет о завершении тестирования. Форма и содержание отчетов могут сильно отличаться от проекта
# к проекту, а также в зависимости от целей, которые преследуют конкретные отчеты, и аудитории, для которой они
# составляются.
#
# Например, для сложных, формальных проектов с большим числом заинтересованных лиц может потребоваться более подробная
# и строгая отчетность. В гибкой разработке отчеты о ходе тестирования могут быть частью обсуждения на ежедневных
# встречах, поэтому составляются в автоматическом или полуавтоматическом режиме (например, путем выгрузки списка
# задач, по которым велись работы, из баг-трекера).
#
# В целом, для понимания того, что что-то идет не так, требуется отслеживать то, как оно идет в данный момент и знать,
# как оно должно идти. Мониторинг и контроль тестирования это в первую очередь задача руководства. Для рядового же
# сотрудника (как правило) данный этап заканчивается на выполнении регламентированных рутинных действий по ежедневному
# заполнению форм, если они не заполняются автоматически по мере его работы.



# ------------------------------------- Анализ ------------------------------------------------

# На этапе анализа занимаются… анализом (бадум тссс!). Крайне здравый вопрос: «Анализом чего»? И здесь мы приходим к
# фундаментальному принципу трассируемости, о котором будем упоминать постоянно и который красиво выстроится у нас к
# концу этого урока. Мониторинг и контроль стоит как бы в стороне, т.к. идет параллельно всем другим этапам. Но
# поставить его в самое начало или в самый конец списка было бы не очень логично.
#
# Из-за этого он вклинился на второе место и немного поломал последовательность, но это не страшно. Итак, на этапе
# анализа мы анализируем тестовый базис, собранный на этапе планирования. Напомним, что тестовым базисом у нас
# называются описывающие будущий продукт требования и дизайн.
#
# Анализировать их можно с двух сторон:
#
# Анализ базиса на наличие ошибок. Все документы, входящие в базис, тоже можно тестировать и выявлять такие баги, как
# неточность, неоднозначность, противоречивость, избыточность и т.д. Например, если на макете главной страницы
# кнопка «личный кабинет» расположена в десяти разных местах, это вполне может быть поводом уточнить, не стоит ли
# сократить это количество хотя бы до 9. Или требование нарисовать 7 перпендикулярных линий (погуглите, ролик веселый)...
# Анализ базиса с целью выявления тестовых условий. Под тестовыми условиями понимается конкретное утверждение, которое
# можно проверить. Например, «кнопка должна быть красивенькая» — не тестовое условие, а «кнопка должна быть 20х40,
# цвета FF0000, с надписью цвета FFFFFF «Старт» шрифтом Times new roman размера 9,5» — целый набор тестовых условий.
# Таким образом, по завершении этого этапа мы должны получить полностью непротиворечивые, абсолютно точные и
# максимально подробные документы тестового базиса и целый набор таких же качественных тестовых требований.



# --------------------- Проектирование----------------------

# И вот наступает этап проектирования, на котором мы будем… проектировать (никогда не надоест). Но
# вопросы: «Что именно?» и «Как?» здесь более чем уместны, давайте найдем на них ответ. Мы будем писать высокоуровневые
# тест-кейсы на основании тестовых условий. Для начала очень кратко разберем, что такое тест-кейс (подробно о
# тест-кейсах поговорим в модуле 3). Тест-кейс, он же тестовый сценарий, представляет из себя описание
# последовательности конкретных шагов (действий), которые следует пройти для проверки какой-либо функциональности. Как
# правило, для каждого шага прописывается ожидаемый результат, т.е. что должно произойти при выполнении действия,
# например:
#
# Нажать ЛКМ на иконку корзины в правой верхней части страницы — Страница корзины открыта.
#
# По сути своей, это уже тест- кейс — очень короткий, но все же. На практике тест-кейсы обычно длиннее. Например,
# открыть каталог, добавить товар в корзину, потом перейти в нее и убедиться, что товар добавился — уже вполне себе
# тест-кейс «Проверка добавления товара в корзину». Высокоуровневый тест-кейс характеризуется отсутствием привязки к
# конкретным данным — то есть мы не указываем какой именно товар из какого раздела каталога должен быть добавлен. Или,
# скажем, при проверке авторизации пишем «ввести корректный логин и пароль» вместо указания конкретных логина и пароля.
#
# Примечание: в других популярных источниках такое деление на высокоуровневые и обычные тест-кейсы отсутствует, но все
# же ISTQB достаточный авторитет, чтобы о нем рассказать.
#
# Тест-кейсы пишутся на основании тестовых условий. Вспомним нашу кнопку (которая «Старт», а не которая красивенькая),
# нам потребуется проверить ее цвета, надпись и шрифт. Так как тест-кейсы у нас высокоуровневые, мы просто укажем что
# ее параметры корректны, «соответствуют макету» (предположим, что мы взяли их с макета). В такой формулировке
# тест-кейс можно будет применить не только к конкретно этой кнопке, а вообще ко всем кнопкам, изображенным на
# макете (т.е. вообще ко всем кнопкам нашего продукта, т.к. макет должен отображать итоговый вид).
#
# И вот смотрите, как интересно у нас уже выстраиваются рабочие продукты каждого этапа по принципу
# трассируемости: сначала из макета, представляющего тестовый базис, были выделены тестовые условия, а уже на их
# основании написан высокоуровневый тест-кейс. То ли еще будет, идем дальше!



# ------------------------------- Реализация ---------------------------------------------

# На этапе реализации мы, как ни странно, не реализуем. Данный перевод английского implementation хоть и является
# самым распространенным, в данном случае крайне неудачен. В первоисточнике слово употребляется в значении «снабжение
# инструментами» и, собственно, именно это и происходит на данном этапе.
#
# Инструментами в нашем случае являются, например, все необходимые для тестирования вспомогательные программы.
# Баг-трекер, в котором будут описываться все найденные баги и отслеживаться прогресс их исправления. Сначала
# баг-трекер необходимо выбрать, затем оплатить его использование, после чего создать нужное количество учетных записей
# для всех, кто будет участвовать в процессе разработки.
#
# Также понадобится настроить баг-трекер —  уже упомянутая ранее Jira позволяет очень гибко кастомизировать набор
# полей, которые будут использоваться в ходе работы. Помимо банальных заголовка, описания, версии продукта и
# окружения, на котором воспроизводится баг, можно, например, добавить список компонентов продукта (отдельные разделы
# интернет— магазина — каталог, корзина, личный кабинет и т.д.). Или с помощью системы лейблов создать сложную
# детализацию функционала, который затрагивает баг (лучше не надо, но возможность есть). Также инструментами будет
# дополнительное ПО для выполнения каких-то специфических действий —  для работы с базой данных проекта, для
# проведения нагрузочного тестирования и т.д.
#
# Нельзя забывать о настройке стендов для тестировщиков, разработчиков, для других заинтересованных (менеджмента,
# инвесторов). Пусть вас не пугает слово «стенд» —  под ним подразумевается версия продукта, закрытая для доступа
# посторонних. То есть это банально тот же сайт интернет-магазина, что в итоге будет выпущен, но только его ранняя
# версия. С каталогом из 5 товаров, с регулярно отваливающейся корзиной и в принципе половиной функционала в
# состоянии «еще не готово». Зато имеющийся функционал уже надо тестировать.
#
# То есть, если нашим продуктом является сайт bestshop.org, то по адресу test-bestshop.org может располагаться стенд
# для тестировщиков, dev-bestshop.org —  стенд разработчиков, а manage-bestshop.org —  стенд для менеджмента.
#
# Разработчики пишут фичи и смотрят как они работают на своем стенде, потом набор фич объединяется вместе и составляет
# новую версию продукта —  ее раскатывают на стенде тестировщиков и она тестируется, а последняя стабильная
# протестированная версия устанавливается на менеджерский стенд, чтобы начальство могло отслеживать ход работ,
# показывать его заказчику, инвесторам и еще кому угодно, кто должен это увидеть.
#
# Сами стенды могут быть развернуты, например, во внутренней сети компании и извне на них зайти никто никогда не
# сможет. Устройство всей этой системы, в том числе и с «железной» стороны (программы должны запускаться на
# компьютерах, которые еще купить и настроить сначала надо) — тоже часть этапа реализации.
#
# Этот этап тоже мог бы выпасть из принципа трассируемости, если бы на этом его описание и окончилось, но нет. Также
# на этом этапе подготавливаются тестовые данные. Те самые тестовые данные, в отрыве от которых пишутся
# высокоуровневые тест-кейсы. То есть, если мы сложим эти два компонента, то получим что? Правильно, готовые к
# употреблению тест-кейсы.
#
# Тест-кейсы могут укладываться в последовательности в рамках этого этапа (логично сначала протестировать
# авторизацию, а потом личный кабинет — можно сэкономить немного времени).
#
# В целом, этап реализации можно было бы назвать этапом «настройки» или этапом «подготовки к выполнению», но
# первоисточник — есть первоисточник.



# ------------------------------------ Выполнение -----------------------------------------

# Ну что ж, мы прошли долгий путь и теперь, вооруженные до зубов спецификациями, установленными программами,
# настроенными доступами и целой кучей тест-кейсов мы переходим на этап выполнения, на котором будем
# ВЫПОЛНЯТЬ (вы же не думали, что эта шутка могла закончиться?) тестирование. Как мы будем это делать?
#
# Да, в общем-то, вот он, тот самый этап «протыкивания», этап «берешь и тестишь», с которым многие и ассоциируют
# профессию тестировщика (из тех, кто вообще о ней знает). У нас есть набор действий, ожидаемый результат которых
# заранее известен (тест-кейсы). Мы производим эти действия, отслеживая получаемый результат. Если полученный
# результат не совпал с ожидаемым, на это пишется баг-репорт, который уходит разработчикам. Результат каждого
# прохождения тест-кейсов (pass/fail) документируется на протяжении всего времени существования проекта.
#
# Остановимся чуть подробнее на этом моменте, чтобы процесс тестирования ПО стал немного понятнее. До сих пор мы
# описывали все этапы так, как будто однажды завершив один этап, мы переходим к следующему и больше назад не
# возвращаемся. В начале урока был дисклеймер о том, что последовательность не жесткая, вот его-то мы расширим и
# углубим.
#
# К нам на стенд приехала самая первая версия продукта, которую мы должны протестировать. Это маленький кусочек
# функционала, например, страница авторизации. При успешном вводе логина пароля нам показывается заглушка —  страница
# с надписью «авторизация успешна».
#
# Если же логин и пароль не подходят друг к другу, демонстрируется соответствующее сообщение. Функциональность
# протестирована, тест-кейсы пройдены, баг-репорты написаны. Приезжает новая версия, в которой исправлены баги
# предыдущей плюс добавлен новый функционал — вместо заглушки теперь показывается главная страница, только на ней
# ничего не работает (это прикрутят уже в следующей версии).
#
#  И вот важный момент, каковы наши действия:
#
# проверяем, исправлены ли баги предыдущей версии (те, которые разработчики пометили как исправленные и передали нам),
# в зависимости от результата переводим их в статус исправленных или возвращаем разработке на исправление;
# проводим тестирование нового функционала, проходим тест-кейсы, пишем баг-репорты;
# проводим полное тестирование оставшегося функционала (это называется регрессионное тестирование или сокращенно
# регресс), чтобы убедиться, что исправление багов и добавление новых фич его не сломало;
# в ожидании новой версии работаем с документацией, т.е. проверяем актуальность имеющихся тест-кейсов, пишем новые,
# считаем метрики и т.д.;
# Когда на наш стенд установят новую версию, все повторится по новой. Возможно, в какой-то момент будет внедряться
# фича, которая не была изначально запланирована, и в отношении нее весь тестовый процесс начнется сначала, при этом
# реализация запланированных фич прерываться не будет, они также будут выходить в рамках новых версий как было
# задумано изначально. Процессы будут идти параллельно, пока в определенный момент новая фича просто не станет частью
# новой версии продукта.
#
# Надеюсь, нам удалось передать, что процесс тестирования — это не лестница, это река.



# -------------------------------------- Завершение -------------------------------------------

# Этап завершения необязательно подразумевает под собой завершение всего проекта. Речь идет о завершении какой-то части
# работ, которую можно выделить. Это может быть банально выпуск новой версии. Что-то более крупное, например, выход
# продукта в релиз. Завершение проекта — тоже вполне себе подходящий повод, но все же он бывает один раз, а этапов
# завершения в процессе тестирования подразумевается гораздо больше.
#
# Это этап подведения итогов, учета возникших проблем и разработки способов их избежать в будущем. Тот момент, когда
# надо остановиться, оглянуться на проделанную работу и сказать «Хм, а ведь неплохо. Но в будущем можно поменять вот
# тут и тут и получится еще лучше». И обязательно сделать так в следующей версии, следующем релизе, следующем проекте.
# Ведь полученный опыт, дополнительно осмысленный на данном этапе, не позволит повторить допущенные ошибки. Время
# собирать камни.
#
# Вещественно этап воплощается в отчетах о проведенных проверках и их результатах, а также в изменениях в работе
# команды. Об изменениях говорить не будем — они индивидуальны для каждого проекта, каждой команды. А вот на отчетах
# остановимся, снова вспомнив принцип трассируемости в процессе тестирования. Возьмем отчет, в котором прописано, что
# баг А был обнаружен при прохождении тест-кейса Б, который в последней на данный момент версии продукта был пройден
# успешно. Тест-кейс Б был написан на основании тестового условия C, выделенного из пункта D документа E,
# представляющего собой список требований, выявленных аналитиком Ивановым при общении с заказчиком.
#
# На самом деле, правильно называть наш принцип «принципом двунаправленной трассируемости», ведь при его соблюдении
# мы можем проследить путь как от требования к результату в конечном продукте, так и от конечного продукта к
# конкретному требованию. И на этом мы ЗАВЕРШАЕМ теорию процесса тестирования (потому что никто не ждет испанскую
# инквизицию).



# Task.
# Поставь этапы тестирования в правильном порядке, с теоретической точки зрения:

# - Планирование
# - Мониторинг и контроль
# - Анализ
# - Проектирование
# - Реализация
# - Выполнение
# - Завершение



# Task.
# На каком этапе тестировщики получают все необходимое для начала тестирования продукта?

# - реализация



# Task.
# Как думаете, когда можно прекратить тестирование?

# - Если ущерб от незакрытого бага не превышает затрат на его исправление, то исправлять баг не надо
# - Если суммарный ущерб от всех известных незакрытых багов не превышает выгоды от внедрения существующей версии
# системы, то её надо внедрять (пусть даже и с известными незакрытыми багами)
# - Если ущерб от потенциального бага не превышает затрат на его поиск и исправление, то искать баг не надо



# ============================================================================



# =============================== 2.7 Пирамида тестирования =====================================


# --------------------------------------------------------
# Выделяют четыре уровня тестирования:
#
# - Модульное тестирование (Component/Unit testing);
# - Интеграционное тестирование (Integration testing);
# - Системное тестирование (System testing);
# - Приемочное тестирование (Acceptance testing).

# Задачи любого уровня тестирования:
#
# - Снижение риска;
# - Обнаружение дефектов;
# - Предотвращение перехода дефектов на более высокие уровни.



# -------------------------------------------------------------
# Модульное тестирование
# Для обозначения модульного тестирования используется множество синонимичных названий: модульное, юнит или
# компонентное.

# Модульное тестирование проводится, вызывая код,  и позволяет проверить, что отдельные части общего кода работают
# согласно требованиям документации.

# Модульное тестирование, как правило, проводится разработчиками. В качестве примера самого модуля может выступать
# любой отдельный компонент приложения, например, одна веб-страница, объект, функция или класс (страница авторизации,
# поиск товара в интернет магазине, перемещение товара в корзину).

# Например: разработано всего две страницы приложения: страница регистрации и страница авторизации. На этапе
# модульного тестирования нужно убедиться, что каждая страница в отдельности работает правильно, то есть на странице
# регистрации можно зарегистрировать нового пользователя, а на странице авторизации можно авторизоваться уже
# зарегистрированному пользователю.

# Т.е. сначала каждая страница проверяется по отдельности, а потом уже переходим к более высокому уровню
# тестирования - тестирование взаимодействия этих страниц друг с другом.

# Найденные дефекты, при модульном тестировании чаще всего исправляются самим разработчиком, без занесения в
# баг-трекинговую систему (место хранения отчетов о найденных багах).


# Типичные дефекты модульного тестирования:
#
# - Неправильное поведение модуля (несоответствующее документации и требованиям);
# - Неправильный код.



# ------------------------------------------------------------------------
# Интеграционное тестирование
# Это тестирование взаимодействия модулей системы или нескольких систем.
#
# Так как разные модули приложения могут разрабатываться разными программистами - необходимо проверить взаимодействие
# между ними.
#
# Один компонент (модуль) производит выходные данные, а другой компонент эти данные принимает на вход. Проверка
# правильности взаимодействия этих отдельных модулей или систем и называется интеграционным тестированием.
#
# В результате тестирования стоит ожидать, что все смежные системы и модули одной системы должны работать согласованно.
#
# Например, со страницы корзины при нажатии кнопки «Оплатить» происходит переход на страницу платежной системы и
# осуществляется оплата.
#
# Типичные тестовые объекты:
#
# - Подсистемы;
# - Базы данных;
# - Интерфейсы, с помощью которых взаимодействует система;
# - Микросервисы.

# Типичные дефекты:
#
# - Отсутствующие или неправильные данные;
# - Сбои связи между компонентами;
# - Нарушение обязательных правил безопасности.



# -----------------------------------------------------------
# Системное тестирование (System testing)
# Производится после окончания интеграционного. Сначала разработчики создают и тестируют модули, затем интегрируют и
# тестируют модули между собой. В результате получается некая завершенная система, базовая модель приложения.
#
# Цель системного тестирования: проверить все приложение целиком.
#
# На системном уровне тестирования проводится тестирование полного пути (end-to-end/E2E flow) использования продукта.
# Под путем использования понимается вся цепочка взаимодействия от запуска приложения до какого-то конечного результата.
#
# Пример сценария end-to-end для интернет магазина:
#
# - Незарегистрированный пользователь переходит на сайт интернет магазина;
# - Регистрируется на сайте;
# - Авторизуется на сайте;
# - Находит необходимый товар;
# - Добавляет его в корзину;
# - Статус заказа «Ожидает оплаты»;
# - Оплачивает заказ;
# - Деньги поступают на счет компании;
# - Статус заказа меняется на «Оплачен»;
# - После получения заказа пользователем статус заказа меняется на «Получен».

# Типичные дефекты:
#
# - Неожиданное или неверное поведение системы;
# - Система неспособна выполнять end-to-end задачи;
# - Система неспособна правильно работать в различных средах;
# - Система работает не в соответствии с пользовательским руководством.



# --------------------------------------------------------------------------
# Приемочное тестирование (Acceptance testing)
# Проверяет, выполнены ли все бизнес-требования перед выпуском приложения на рынок.
#
# На текущем уровне тестирования обязательно должны применяться реальные данные и реальное использование приложения.
# Такой подход делает приемочное тестирование очень важным этапом цикла выпуска приложения. Это окончательное
# тестирование, выполняемое после завершения модульного, интеграционного и системного тестирования
#
# Критерии приемки — это условия, которым должно удовлетворять приложение, чтобы быть принятым заказчиком.
#
# Приемочное тестирование включает следующие формы:
#
# Пользовательское приемочное тестирование (User acceptance testing)  —  производится пользователями конечного продукта;
# Операционные приемочные испытания (Operational acceptance testing) - как правило, проводят системные администраторы.
# Проверяются функции резервного копирования, установка/ удаление/ обновление системы, проверка безопасности и
# производительности приложения. Необходимо удостовериться, что приложение возможно обслуживать и сопровождать на
# требуемом уровне даже в экстремальных условиях;
# Контрактные и нормативные приемочные испытания (Contractual and regulatory acceptance testing )  —  проверка, что
# приложение соблюдает все нормативные требования, продукт не нарушает чью-то интеллектуальную собственность или не
# использует нелицензионный софт;
# Альфа и бета-тестирование (Alpha and beta testing ).
# Альфа тестирование  включает имитацию реального использования продукта штатными  или сторонними разработчиками, либо
# командой тестировщиков.
#
# Бета-тестирование  —  производится реальными пользователями, с целью получения от них обратной связи и выявления
# максимального числа ошибок для их последующего устранения перед окончательным выходом продукта на рынок (релизом).
#
# Например, в известной компании «WarGaming» есть несколько групп тестирования:
#
# Отдел тестирования WarGaming — сотрудники компании, занимающиеся львиной долей всего тестирования того, или иного
# продукта. Качество любимых танчиков зависит от них, в большей степени;
# Участники «Супертест» — группа опытных игроков, помогающая разработчикам со сбором статистики, которая оставляет
# комментарии и предложения, а главное — способная оценить изменения свежим, «незамыленным» взглядом и обнаружить
# неочевидные ошибки.
# Несложно догадаться, отдел тестирования проводят альфа -тестирование, а «Супертест» участвуют в бета-тестировании.



# ---------------------------------------------------------------
# Task.
# Отметьте четыре главных уровня тестирования:

# - Модульное
# - Интеграционное
# - Системное
# - Приемочное



# -----------------------------------------------------------------
# Task.
# Выберите все синонимы компонентного тестирования:

# - Юнит (Юнит-тестирование)
# - Модуль (Модульное тестирование)



# -------------------------------------------------------------------
# Task.
# В качестве одного модуля (компонента, юнита) могут выступать:

# - Маленькая независимая часть (компонент) приложения



# --------------------------------------------------------------------
# Task.
#   На чем нужно быть сосредоточенным, проводя Интеграционное тестирование (Integration Testing)?

# - На тестировании взаимодействия модулей



# ---------------------------------------------------------------------
# Task.
# Системное тестирование (System testing) проводится сразу после:

# - Интеграционного



# ---------------------------------------------------------------------


# =====================================================================


# ======================= 2.8 Методы тестирования =====================

# --------------------------------------------------------------------
# ISTQB - Совет по сертификации тестирования программного обеспечения, действующий на международном уровне.
#
# White, black и grey box тестирование или «тестирование белого» (прозрачного, открытого, стеклянного), «черного или
# серого» (полупрозрачного) ящика — это методы тестирования, направленные на определение доступа к внутренней
# системе ПО.
#
# Проще говоря мы, как тестировщики, при проверке продукта можем или не можем иметь доступ к его коду. Рассмотрим
# далее каждый из методов
#
# ------------ Метод черного ящика (black box) -----------------

# Тестирование черного ящика ( отсутствие доступа к коду )  — также известное как тестирование, основанное на
# спецификации или тестирование поведения — техника, основанная на работе исключительно с внешними интерфейсами системы.
#
# Согласно ISTQB, тестирование черного ящика — это:
#
# тестирование, как функциональное, так и нефункциональное, не предполагающее знания внутреннего устройства компонента
# или системы;
# тест-дизайн, основанный на технике черного ящика — процедура написания или выбора тест-кейсов на основе анализа
# функциональной или нефункциональной спецификации компонента, или системы без знания ее внутреннего устройства.
# Преимущества:
#
# тестирование производится с позиции конечного пользователя и может помочь обнаружить неточности и противоречия в
# спецификации;
# тестировщику нет необходимости обладать дополнительными знаниями в программировании;
# можно начинать писать тест-кейсы, как только готова спецификация.
# Недостатки:
#
# тестируется только очень ограниченное количество путей выполнения программы;
# без четкой спецификации (а это, скорее, реальность на многих проектах) достаточно трудно составить эффективные
# тест-кейсы;
# некоторые тесты могут оказаться избыточными, если они уже были проведены разработчиком на уровне модульного
# тестирования.
# Пример: обычный калькулятор. У нас нет доступа к внутренней системе, но мы можем предположить как пользователь будет
# им пользоваться и на основе этого произвести тестирование функций: отображение цифр при нажатии на кнопки, работу
# операторов(сложение, вычитание и т.д.), удаление результата и т.д.



# -------------------------------------------------------
# --------------- Метод белого ящика (white box) ----------------------------

# Тестирование белого ящика ( полный доступ к коду / сам писал код ) — метод тестирования ПО, который предполагает, что
# внутренняя структура/устройство/реализация системы известны тестировщику.
#
# Мы выбираем входные значения, основываясь на знании кода, который будет их обрабатывать. Так же мы знаем, каким
# должен быть результат этой обработки.
#
# В данном случае тестируемая программа для тестировщика — прозрачный ящик, содержимое которого он прекрасно видит.
#
# Как правило, таким видом тестирования на проектах занимаются сами программисты, ведь для использования этого метода
# тестировщик должен обладать достаточно высокой квалификацией.
#
# Согласно ISTQB, тестирование белого ящика — это:
#
# тестирование, основанное на анализе внутренней структуры компонента или системы;
# тест-дизайн, основанный на технике белого ящика — процедура написания или выбора тест-кейсов на основе анализа
# внутреннего устройства системы или компонента.
# Преимущества:
#
# тестирование может производиться на ранних этапах: нет необходимости ждать создания пользовательского интерфейса;
# можно провести более тщательное тестирование с покрытием большого количества путей выполнения программы.
# Недостатки:
#
# для выполнения тестирования белого ящика необходимо большое количество специальных знаний;
# упор делается на код, без учета позиции конечного пользователя, вследствие чего могут пропускаться баги.
# Пример: двигатель автомобиля. Для водителя (особенно начинающего) двигатель автомобиля - черный ящик. Но, для
# механика нет. Он, словно программист, понимает логику работы компонентов двигателя и знает его слабые места.



# -----------------------------------------------------------
# --------------------- Метод серого ящика (grey box) -------------------------------

# Тестирование серого ящика ( частичный доступ к коду ) — метод тестирования ПО, который предполагает
# комбинацию White Box и Black Box подходов. То есть, внутреннее устройство программы нам известно лишь частично.
#
# Преимущества:
#
# Тестирование серого ящика включает в себя плюсы тестирования «черного» и «белого». Другими словами, тестировщик
# смотрит на объект тестирования с позиции «черного» ящика, но при этом проводит анализ на основе тех данных, что он
# знает о системе;
# Тестировщик может проектировать и использовать более сложные сценарии тестирования;
# Предоставляет разработчику достаточно времени для исправления дефектов.
# Недостатки:
#
# Возможность анализа кода и тестового покрытия ограничена, так как доступ к исходному коду ограничен.
# Тесты могут быть избыточными в том случае, когда разработчик также проверяет свой код Unit-тестами.
# Пример: разработчик, проверяющий программу, методом черного ящика ИЛИ тестировщик, ознакомившийся с архитектурой
# программы, проверяющий программу, методом черного ящика. Оба понимают логику работы программы, но проверяют ее, с
# точки зрения пользователя.
#
# P.S.
# ISTQB относит тестирование методами белого и черного ящика к методам проектирования тестов. Поэтому, ни о
# каком «среднем» или «промежуточном» методе в этом случае конечно и речи быть не может. Мы либо разрабатываем тесты,
# зная код, либо не зная его. То есть в классификации ISTQB такого вида тестирования не существует.



# ------------------------------------------------------------------
# Task.
# Соотнесите методы тестирования с их определениями:

# Метод черного ящика : Тестирование, основанное на спецификации или тестирование поведения — техника, основанная на
# работе исключительно с внешними интерфейсами системы.

# Метод белого ящика : Метод тестирования ПО, который предполагает, что внутренняя структура/устройство/реализация
# системы известны тестировщику.

# Метод серого ящика : Метод тестирования ПО, который предполагает комбинацию White Box и Black Box подходов. То есть,
# внутреннее устройство программы нам известно лишь частично.



# --------------------------------------------------
# Task.
# Какой метод не описан в ISTQB?

# - Метод серого ящика



# --------------------------------------------------
# Task.
# Из представленных утверждений выберите верное:

# - Тестирование методами черного ящика более близко к поведению пользователя, чем остальные.



# -----------------------------------------------


# =================================================


# ===================== 2.9 Подходы к тестированию ================================

# ----------------------------------------------------------
# Рассмотрим подходы к тестированию по степени формализации:
#
# Формальность —  это «иметь общепризнанную форму, структуру или набор правил».
#
# 1.  Тестирование на основе тест-кейсов (виды тестовой документации будут рассмотрены в 3 разделе
# курса) — формализованный подход, в котором тестирование производится на основе заранее подготовленных тест- кейсов
# и иной документации.
#
# Тест-кейс — это совокупность входных данных, условий выполнения и ожидаемого результата, необходимых для проверки
# реализации функционала тестируемого программного обеспечения (ПО) или какого-то его свойства.
#
# Эта информация включает в себя четкое описание действий, которые нужно выполнить, шаг за шагом. После выполнения
# действий нужно сравнить ожидаемый результат работы приложения с тем, который получен.
#
# Это самый распространенный способ тестирования, который также позволяет достичь максимальной полноты исследования
# продукта за счет строгой систематизации процесса.
#
# 2.  Исследовательское тестирование (Exploratory testing) — это частично формализованный подход тестирования ПО, при
# котором тестовые наборы не создаются заранее, а тестировщик проверяет приложение «на лету».
#
# Тестировщик выполняет работу с продуктом по выбранному сценарию, который, в свою очередь, дорабатывается в процессе
# выполнения с целью более полного исследования приложения.
#
# Исследовательское тестирование ориентировано больше на тестирование как на мыслительную деятельность, а не как на
# бездумное воспроизведение по заранее написанному сценарию. При тестировании по сценарию ты сначала разрабатываешь
# тестовые случаи, а затем исполняешь их. Исследовательское тестирование — это одновременный процесс разработки и
# выполнения тестов.
#
# В качестве альтернативы сценариям при выборе действий с приложением иногда могут использоваться чек-листы.
#
# Также в результате исследовательского тестирования могут появиться новые тест- кейсы. То есть мы можем выполнять
# исследовательское тестирование и с целью написания новых тест-кейсов.
#
# 3.  Свободное (интуитивное) тестирование (Ad Hoc Testing или Monkey Testing) полностью неформализованный подход, в
# котором не предполагается использования ни тест-кейсов, ни чек-листов, ни сценариев.
#
# Тестировщик полностью опирается на свою интуицию для спонтанного выполнения с продуктом действий, которые, как он
# считает, могут обнаружить ошибку.
#
# В прямом смысле — «куда хочу, туда и кликаю, в порядке каком хочу».
#
# Такое тестирование не требует никакой документации, планирования, наличия процессов, которых следует придерживаться
# при выполнении тестирования. Таким образом, метод не структурирован, и, следовательно, дефекты, обнаруженные с
# помощью этого метода, может быть труднее воспроизвести, но и вместе с этим возможно найти «Хитрые баги».
#
# В свою очередь Интуитивное тестирование подразделяется на 2 вида:
#
# buddy testing (совместное тестирование) — когда 2 человека, как правило разработчик + тестировщик, работают
# параллельно и находят дефекты в одном и том же модуле. Такой вид тестирования помогает тестировщику выполнять
# необходимые проверки, а программисту фиксить баги на ранних этапах.
#
# pair testing (парное тестирование) —  когда 2 тестировщика проверяют один модуль и помогают друг другу. К примеру,
# один может искать дефекты, а второй —  их документировать.
#
# Используя различные подходы к тестированию, можно выбирать один или комбинацию подходов, для более глубокого и
# обширного тестирования. Какой именно подход выбирать — зависит от конкретного проекта и целей поставленных перед
# тестировщиком.



# ------------------------------------------------------
# Task.
# Что такое Исследовательское тестирование?

# - Методика тестирования ПО, при которой тестовые наборы не создаются заранее, а тестировщик проверяет
# приложение "на ходу"



# --------------------------------------------------------
# Task.
# Дано требование для валидации поля для введения пароля: Длина поля не должна превышать 5 символов. Можно использовать
# любые буквы латинского алфавита и числа. Поле не может быть пустым. Выберите возможные варианты валидного пароля:

# - 58R44
# - 65
# - 98765



# ---------------------------------------------------------
# Task.
# Укажите вариант для обозначения текста ошибки при авторизации пользователя при неверно введенном логине и/или
# пароле, который считается самым безопасным с точки зрения недопущения раскрытия этих данных злоумышленнику:

# - Пароль или логин введены неверно



# -----------------------------------------------------------


# ===========================================================



# ======================= 2.10 Виды тестирования ===================================

# ---------------------------------------------------------
# Стоит начать с того, что по критерию запуска программы тестирование делится на два типа: Статическое и Динамическое.
# Статическое тестирование (Static Testing) — тип тестирования, при котором код программы не исполняется во время
# проведения тестов.
#
# Статическое тестирование включает тестирование спецификации и прочей документации, файлов, либо тестирование и анализ
# программного кода (code review) или скомпилированного кода без его запуска. Может производиться как вручную, так и с
# помощью специальных инструментальных средств, т.е .автоматизировано.
#
# Код-ревью (code review) может выполняться одним из участников команды разработчиков или тестировщиком. Как
# правило, на код-ревью проверяются качество кода, стандарты использования, решения реализации, оставляются
# комментарии. Это помогает предотвратить дефект на начальном этапе.
#
# Динамическое  тестирование (Dynamic Testing) — тестирование, при котором выполняется код программы и проверяется
# поведение приложения во время работы. Тут происходит взаимодействие с интерфейсом запущенной программы, ее формами,
# сервером, базой данных и т.д.
#
# Если проводятся тесты на работающем приложении — значит, это динамические тесты.
#
# По степени автоматизации тестирование делится на Ручное и Автоматизированное.
# Ручное тестирование - это вид тестирования, при котором тестировщики вручную выполняют тесты без использования
# инструментов автоматизации.
#
# Каждое приложение должно быть протестировано вручную, прежде чем тесты можно будет автоматизировать. Это делается
# для того, чтобы определить, нужно ли вообще внедрять автоматизацию. Для проведения ручного тестирования необязательно
# владеть навыками использования какого-либо инструмента. Один из основных принципов тестирования заключается в
# том, что 100% автоматизация невозможна. Поэтому ручное тестирование неизбежно во всех проектах.
#
# Автоматизированное тестирование - это вид тестирования, при котором тесты проверяются автоматически с помощью
# специальных инструментов. Например, Selenium или Appium.
#
# Как только тесты автоматизированы, человек практически не принимает участие в выполнении тестов. Поэтому
# автоматизированное тестирование является эффективным видом тестирования. Цель автоматизации - сократить количество
# тестов, которые необходимо выполнять вручную, чтобы сократить время на тестирование.
#
# По ожидаемому поведению тестирование разделяется на:
# Позитивное тестирование (Positive Testing) — тестирование с применением сценариев, которые соответствуют ожидаемому
# поведению приложения.
#
# Позитивные тестовые сценарии проверяют, что приложение работает соответственно требованиям, если пользователь
# предоставляет допустимые, валидные данные или выполняет предусмотренные действия.
#
# Пример позитивного сценария: для Авторизации в системе уже зарегистрированного пользователя необходимо ввести
# существующий логин, правильный пароль, нажать кнопку «Войти». Ожидаемый результат — произошел вход в систему.
#
# Негативное тестирование (Negative Testing) — тестирование с применением сценариев, которые соответствуют внештатному
# поведению приложения.
#
# Негативные тестовые сценарии проверяют, как приложение справляется с данными, которые выходят за границы,
# предусмотренные требованиями, или неожиданными действиями пользователя.
#
# Пример негативного сценария: для Авторизации в системе уже зарегистрированного пользователя ввести несуществующий
# логин, или неправильный пароль, нажать кнопку «Войти». Ожидаемый результат – появляется сообщение о неправильности
# введенных данных.



# --------------------------------------------------
# По хронологии тестирование разделяют на:
# Дымовое тестирование (Smoke Testing) - включает в себя минимальный набор тестов на самые очевидные ошибки. Дымовое
# тестирование проверяет работоспособность критически важных функциональных частей приложения.
#
# Например, регистрация нового пользователя, создание нового заказа, выставление счета клиенту, получение оплаты. Это
# базовый функционал, который регулярно контролируется Smoke-тестами.
#
# Санитарное тестирование (Sanity Testing) — проводится после незначительных изменений в функционале, коде или починке
# багов. Проверяет, что исправленный код или новый функционал работает, как и ожидалось.
#
# Как пример, программисты устранили дефект на странице создания нового заказа. В этом случае санитарные тесты должны
# проверить общее состояние приложения и нацелены на то, чтобы избежать потерь времени и усилий, чтобы быстрее
# определить возможные недостатки ПО и их критичность, а также стоит ли переходить в фазу более тщательного
# тестирования. Обычно выполняется вручную.
#
# Регрессионное тестирование (Regression Testing) — тестирование приложения, направленное на обнаружение ошибок в уже
# проверенных участках программ (или исходных кодах). Помогает убедиться, что недавние изменения не сломали работающую
# функциональность приложения. Регрессионные тесты должны проводиться при любых изменениях кода, потому полная
# автоматизация — лучшая практика в этом типе тестирования.
#
# В регрессию включаются тесты, которые покрывают тестирование безопасности, критических и важных функций. Включаются
# те области, которые часто меняются в ходе разработки, где высока вероятность ошибки.
#
# Повторное тестирование (Retesting) — проводится после устранения дефекта в части функционала с целью подтверждения
# исправления ошибки.  Перепроверяет и подтверждает то, что ранее неудачные тест-кейсы успешно проходятся после
# того, как эти дефекты были исправлены. При этом используются те же самые тест-кейсы, которые выявили дефект — с
# использованием тех же данных, на том же окружении, но с различным набором входных данных.
#
# Тестирование делится также на Функциональное тестирование и Нефункциональное тестирование.
# Функциональное тестирование (Functional Testing) включает в себя тесты, оценивающие функции приложения. Функции
# системы — это то, «что» должна делать система.
#
# С помощью этого вида приложение проверяется на способность выполнять свои функции. Сюда входят: модульное,
# интеграционное, системное и приемочное тестирование. Кроме того, регрессионное и дымовое тестирования тоже являются
# подвидами функционального. Исполняется функциональное тестирование на основании требований в виде спецификаций или
# пользовательских историй.
#
# Нефункциональное тестирование (Non-functional Testing) оценивает характеристики систем и программного обеспечения,
# такие как надежность, производительность, удобство использования, эффективность работы или его безопасность.
# Нефункциональное тестирование — это проверка того, «насколько хорошо» ведет себя система.



# --------------------------------------------------------
# Рассмотрим Нефункционального тестирование подробнее:
#
# - Тестирование пользовательского интерфейса (User interface testing) — проверка соответствия интерфейса ПО требованиям
# дизайна. Например, проверка наличия всех требуемых элементов на странице, их размеров и расположения, тестирование
# шрифтов, цветов, изображений.
#
# - Тестирование удобства пользования (Usability Testing) — определение удобства использования приложения. Проверяется
# эргономичность интерфейсов. Например, оформление и графические элементы с точки зрения удобства восприятия, удобство
# навигации. В этот вид входит Тестирование доступности.
#
# - Тестирование Доступности (Accessibility Testing) — проверка доступности приложения для пользователей с нарушением
# слуха, зрения и цветовосприятия, а также людей, у которых нет возможности использовать клавиатуру. Например,
# использование определенной цветовой гаммы, добавление субтитров на видео или озвучивание всей страницы.
#
# - Тестирование производительности (Performance Testing) — тестирование скорости работы приложения под определённой
# нагрузкой.
#
# - Нагрузочное тестирование (Load testing) — данный тип тестирования позволяет оценить поведение системы при нормальных
# условиях и возрастающей нагрузке, целью нагрузочного тестирования является также определение максимальной нагрузки,
# которую может выдержать система. Например, мы рассчитываем, что одновременно приложением будет пользоваться 500
# пользователей, и через специальные программы (например Jmeter) создаются условия, которые моделируют использование
# приложения одновременно чуть менее 500 пользователями.
#
# - Стресс-тестирование (Stress testing) — используется для определения устойчивости системы или модуля при пороговых
# значениях рабочей нагрузки или за ее пределом. К примеру моделируются условия одновременного использования 500 или
# немногим более пользователей.
#
# - Объемное тестирование (Volume testing) — тестирование позволяет оценить производительность системы при увеличении
# объемов данных как самого приложения, так и его базы данных. Когда те же 500 пользователей отправляют одновременно
# какой-то объем информации.
#
# - Тестирование надежности  (Reliability Testing) — проверка работоспособности приложения при длительном тестировании
# с ожидаемым уровнем нагрузки.
#
# - Тестирование безопасности (Security Testing) — оценка уязвимости приложения к различным атакам. Оценка безопасности
# пользовательских данных, на сколько просто неавторизованный пользователь может получить доступ к системе или данным.
#
# - Тестирование установки  (Installation Testing) — проверка успешной инсталляции, настройки, обновления и удаления.
#
# - Тестирование совместимости (Compatibility Testing) — проверка корректной работы приложения в определенном окружении,
# например, устройстве, операционной системе (кроссплатформенное тестирование) или браузере (кроссбраузерное
# тестирование).
#
# - Тестирование на отказ и восстановление (Recovery Testing) — проверка насколько хорошо приложение может оправиться от
# аварий и сбоев оборудования.
#
# - Тестирование локализации (Localization Testing, l10n) — тестирования локализованной версии приложения: проверка
# правильности перевода интерфейса пользователя, системных сообщений и ошибок, раздела "Помощь"/"Справка",
# документации, контроль формата даты и времени.
#
# - Тестирование интернационализации (Internationalization Testing, i18n) — Насколько продукт может адаптироваться для
# той или иной локали при выходе на другие рынки. Например, возможность поддержки вертикального текста Азиатских
# стран, чтение справа налево в арабских странах.
#
# В целом, можно сказать, что нет строгой системы распределения по видам и типам тестирования. Есть «скелет», а
# остальные виды могут мигрировать.



# ----------------------------------------------------------------
# Task.
# Что такое нефункциональное тестирование?

# - Проверка того, "насколько хорошо" ведет себя система



# ----------------------------------------------------------------
# Task.
# К какому типу тестирования относятся модульное, интеграционное, системное, приемочное?

# - Функциональное



# ----------------------------------------------------------------
# Task.
# Дайте определение тестированию пользовательского интерфейса

# - Проверка соответствия интерфейса ПО требованиям дизайна



# ----------------------------------------------------------------
# Task.
# Выберите опции, которые необходимо проверить в рамках тестирования доступности

# - Соответствует ли звуковое воспроизведение информации, указанной в приложении
# - Удобны ли для восприятия цвета, используемые в приложении



# -----------------------------------------------------------------
# Task.
# Что такое стресс-тестирование?

# - Определение устойчивости системы или модуля при пороговых значениях рабочей нагрузки или за ее пределом



# -----------------------------------------------------------------
# Task.
# Какой вид тестирования отвечает за проверку работы базового/критичного функционала?

# - Дымовое



# ------------------------------------------------------------------
# Task.
# Что такое статическое тестирование?

# - Тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться



# ------------------------------------------------------------------
# Task.
# Выберите действия, которые относятся к статическому тестированию

# - Инспекция проектной документации
# - Анализ программного кода



# --------------------------------------------------------------------
# Task.
# На какие виды подразделяется тестирование по критерию запуска программы?

# - Статическое
# - Динамическое



# --------------------------------------------------------------------



# ====================================================================